[
        {
                "data_len": 12
        },
        [
                {
                        "id": "test_mercury_data_521",
                        "content": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.\nAn uncommon subsequence between two strings is a string that is a subsequence of one but not the other.\nA subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\nFor example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).\nExample 1:\nInput: a = \"aba\", b = \"cdc\"\nOutput: 3\nExplanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\nNote that \"cdc\" is also a longest uncommon subsequence.\nExample 2:\nInput: a = \"aaa\", b = \"bbb\"\nOutput: 3\nExplanation:\u00a0The longest uncommon subsequences are \"aaa\" and \"bbb\".\nExample 3:\nInput: a = \"aaa\", b = \"aaa\"\nOutput: -1\nExplanation:\u00a0Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a.\nConstraints:\n1 <= a.length, b.length <= 100\na and b consist of lower-case English letters.\nclass Solution(object):\ndef findLUSlength(self, a, b):\n\"\"\"\n:type a: str\n:type b: str\n:rtype: int\n\"\"\"\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\nreturn -1 if a == b else max(len(a), len(b))\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\nif a == b:\nreturn -1\nreturn max(len(a), len(b))\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\nreturn  -1 if a==b else max(len(a), len(b))\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\nif a==b:\nreturn -1\nelse:\nreturn max(len(a),len(b))\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\nif a==b:\nreturn -1\nelse:\nreturn max(len(a),len(b))\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\nif a == b:\nreturn -1\nreturn max(len(a), len(b))\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\n#         l = -1\n#         a_char = list(a)\n#         c_char = list(b)\n#         s1 = a\n#         s2 = b\n#         i = 0\n#         while len(s1) > 0 and len(s1) > l:\n#         print(a_char, a)\n#         return l\nif a == b:\nreturn -1\nreturn max(len(a), len(b))\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\nfor i in range(len(b)):\nif a==b:\nreturn -1\nelse:\nreturn(max(len(a),len(b)))\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\nif b.find(a) != -1 and a.find(b) != -1:\nreturn -1\nelif b.find(a) != -1 and a.find(b) == -1:\nreturn len(b)\nelif b.find(a) == -1 and a.find(b) != -1:\nreturn len(a)\nelse:\nreturn max(len(b), len(a))\nclass Solution:\ndef findLUSlength(self, a: str, b: str) -> int:\nif a == b:\nreturn -1\nelif len(a) > len(b):\nreturn len(a)\nelse:\nreturn len(b)\n",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 1690
                },
                {
                        "id": "pretrain_python_data_6401256",
                        "content": "\"\"\"\nGiven two strings a\u00a0and b, find the length of the\u00a0longest uncommon subsequence\u00a0between them.\nA\u00a0subsequence\u00a0of\u00a0a string\u00a0s\u00a0is a string that can be obtained after deleting any number of characters from s. For example, \"abc\"\u00a0is a subsequence of \"aebdc\"\u00a0because you can delete the underlined characters in\u00a0\"aebdc\"\u00a0to get \"abc\". Other subsequences of\u00a0\"aebdc\"\u00a0include\u00a0\"aebdc\",\u00a0\"aeb\",\u00a0and\u00a0\"\"\u00a0(empty string).\nAn\u00a0uncommon subsequence\u00a0between two strings\u00a0is a string that is a subsequence of one\u00a0but not the other.\nReturn the length of the longest uncommon subsequence\u00a0between a\u00a0and b. If the longest uncommon subsequence doesn't exist, return -1.\nExample 1:\nInput: a = \"aba\", b = \"cdc\"\nOutput: 3\nExplanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\nNote that \"cdc\" is also a longest uncommon subsequence.\nExample 2:\nInput: a = \"aaa\", b = \"bbb\"\nOutput: 3\nExplanation:\u00a0The longest uncommon subsequences are \"aaa\" and \"bbb\".\nExample 3:\nInput: a = \"aaa\", b = \"aaa\"\nOutput: -1\nExplanation:\u00a0Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a.\nConstraints:\n1 <= a.length, b.length <= 100\na and b consist of lower-case English letters.\n\"\"\"\nclass Solution(object):\ndef findLUSlength(self, a, b):\n\"\"\"\n:type a: str\n:type b: str\n:rtype: int\n\"\"\"\nif a == b:\nreturn -1\nreturn max(len(a), len(b))",
                        "max_stars_repo_name": "marcus-aurelianus/leetcode-solutions",
                        "max_stars_count": 141,
                        "max_stars_repo_path": "questions/longest-uncommon-subsequence-i/Solution.py",
                        "__cluster__": 1690
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_mercury_data_1551",
                        "content": "You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e.,\u00a00 <= i < n).\nIn one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\nGiven an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].\nExample 2:\nInput: n = 6\nOutput: 9\nConstraints:\n1 <= n <= 10\u2074\nclass Solution(object):\ndef minOperations(self, n):\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nclass Solution:\ndef minOperations(self, n):\nreturn n**2 // 4 if n % 2 == 0 else (n**2 - 1) // 4\nclass Solution(object):\ndef minOperations(self, n):\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nres = 0\nfor i in range(n // 2):\nl = (i*2) + 1\nr = (n-1-i)*2 + 1\nres += (r-l)/2\nreturn res\nclass Solution(object):\ndef minOperations(self, n):\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nreturn n*n//4\nclass Solution(object):\ndef minOperations(self, n):\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nmid = n // 2\nmedian = (2 * mid) + 1\nif n % 2 == 0:\nmedian -= 1\nret = 0\nfor i in range(n):\nret += abs((2 * i) + 1 - median)\nreturn ret // 2\nclass Solution(object):\ndef minOperations(self, n):\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nreturn sum((n - i) for i in range(1, n, 2))\nclass Solution:\ndef minOperations(self, n):\n# Calculate the median element\nmedian = (n - 1) // 2\n# Calculate the total number of operations needed to make all elements equal\ntotal_operations = sum(abs((2 * i) + 1 - (2 * median + 1)) // 2 for i in range(n))\nreturn total_operations\nclass Solution(object):\ndef minOperations(self, n):\nif n%2 == 0: return n**2/4\nreturn (n-1)*(n+1)/4\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nclass Solution(object):\ndef minOperations(self, n):\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nmid_point = (2*n + 1)/2\ntotal = 0\nfor i in range(n):\ntotal += abs(2*i + 1 - mid_point)\nreturn total/2\nclass Solution(object):\ndef minOperations(self, n):\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nresult = 0\nwhile n > 0:\nresult += n - 1\nn -= 2\nreturn result\nclass Solution(object):\ndef minOperations(self, n):\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nreturn sum([ i for i in range( abs(n % 2 - 1) ,n, 2)])",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 586
                },
                {
                        "id": "pretrain_python_data_9950015",
                        "content": "<filename>questions/minimum-operations-to-make-array-equal/Solution.py\n\"\"\"\nYou have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e. 0 <= i < n).\nIn one operation, you can select two indices x\u00a0and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y]\u00a0(i.e. perform arr[x] -=1\u00a0and arr[y] += 1).\u00a0The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\nGiven an integer n, the length of the array. Return the minimum number of operations needed to make\u00a0all the elements of arr equal.\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].\nExample 2:\nInput: n = 6\nOutput: 9\nConstraints:\n1 <= n <= 10^4\n\"\"\"\nclass Solution:\ndef minOperations(self, n: int) -> int:\nstart, end = 0, n - 1\nret = 0\nwhile start < end:\nret += (end - start)\nend -= 1\nstart += 1\nreturn ret",
                        "max_stars_repo_name": "achow113/LeetCode",
                        "max_stars_count": 141,
                        "max_stars_repo_path": "questions/minimum-operations-to-make-array-equal/Solution.py",
                        "__cluster__": 586
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_6811408",
                        "content": "<reponame>chyidl/leetcode<gh_stars>1-10\n# Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\n#\n# There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\n#\n# Do not modify the linked list.\n#\n#\n# Example 1:\n#\n#\n# Input: head = [3,2,0,-4], pos = 1\n# Output: tail connects to node index 1\n# Explanation: There is a cycle in the linked list, where tail connects to the second node.\n#\n#\n# Example 2:\n#\n#\n# Input: head = [1,2], pos = 0\n# Output: tail connects to node index 0\n# Explanation: There is a cycle in the linked list, where tail connects to the first node.\n#\n#\n# Example 3:\n#\n#\n# Input: head = [1], pos = -1\n# Output: no cycle\n# Explanation: There is no cycle in the linked list.\n#\n#\n#\n# Constraints:\n#\n#\n# \tThe number of the nodes in the list is in the range [0, 104].\n# \t-105 <= Node.val <= 105\n# \tpos is -1 or a valid index in the linked-list.\n#\n#\n#\n# Follow up: Can you solve it using O(1) (i.e. constant) memory?\n#\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution:\ndef detectCycle(self, head: ListNode) -> ListNode:\ncur = head\nvisited = set()\nwhile cur:\nif cur in visited:\nreturn cur\nvisited.add(cur)\ncur = cur.next\nreturn None",
                        "max_stars_repo_name": "chyidl/leetcode",
                        "max_stars_count": 2,
                        "max_stars_repo_path": "0142-linked-list-cycle-ii/linked-list-cycle-ii.py",
                        "__cluster__": 1614
                },
                {
                        "id": "test_mercury_data_142",
                        "content": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\nExample 3:\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.\nConstraints:\nThe number of the nodes in the list is in the range [0, 10\u2074].\n-10\u2075 <= Node.val <= 10\u2075\npos is -1 or a valid index in the linked-list.\nFollow up: Can you solve it using O(1) (i.e. constant) memory?\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\nif head == None or head.next == None:\nreturn None\nslow = fast = entry = head\nwhile fast.next != None and fast.next.next != None:\nslow = slow.next\nfast = fast.next.next\nif fast == slow:\nwhile slow != entry:\nslow = slow.next\nentry = entry.next\nreturn entry\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nhashset = set()\nwhile head != None:\nif head in hashset:\nreturn head\nhashset.add(head)\nhead = head.next\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nnodemap = set()\nwhile head:\nif head in nodemap:\nreturn head\nelse:\nnodemap.add(head)\nhead= head.next\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nslow = fast = head\nwhile fast and fast.next:\nslow = slow.next\nfast = fast.next.next\nif slow == fast:\nslow = head\nwhile slow != fast:\nslow = slow.next\nfast = fast.next\nreturn slow\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\nslow = head\nfast = head\nwhile fast and fast.next:\nslow = slow.next\nfast = fast.next.next\nif slow == fast:\nslow = head\nwhile slow != fast:\nslow = slow.next\nfast = fast.next\nreturn slow\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\ni = head\nj = head\nwhile j and j.next:\ni = i.next\nj = j.next.next\nif i == j:\ni = head\nwhile i != j:\ni = i.next\nj = j.next\nreturn i\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nfound = dict()\ncounter = 0\ncur = head\nwhile cur:\nif cur in found:\nreturn cur\nfound[cur] = counter\ncounter += 1\ncur = cur.next\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nseen = set()\ncurr = head\nwhile curr != None:\nif curr.next in seen:\nreturn curr.next\nseen.add(curr)\ncurr = curr.next\nreturn None",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 1614
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_mercury_data_1357",
                        "content": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.\nExample 1:\nInput\n[\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\nOutput\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\nExplanation\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.\n// bill = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.\n// bill = 10 * 300 + 10 * 100 = 4000.\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.\n// Original bill = 1600\n// Actual bill = 1600 * ((100 - 50) / 100) = 800.\ncashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.\ncashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.\n// Original bill = 14700, but with\n// Actual bill = 14700 * ((100 - 50) / 100) = 7350.\ncashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  7th customer, no discount.\nConstraints:\n1 <= n <= 10\u2074\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.dic = dict(zip(products,prices))\nself.count = 0\nself.n = n\nself.discount = discount\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.count +=1\nget = 0.0\nv = len(product)\nfor i in range(v):\nget += (self.dic[product[i]] * amount[i])\nif (self.count%self.n == 0):\nget = get * (100 - self.discount)/100\nreturn get\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.n = n\nself.discount =discount\nself.products = products\nself.prices=prices\nself.count = 0\nself.products_prices = {products[i]:prices[i] for i in range(len(products))}\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.count+=1\ntotalPrice = 0\nfor i in range(len(product)):\ntotalPrice += (self.products_prices[product[i]]*amount[i])\nprint(self.count%self.n)\nprint(self.count)\nif (self.count)%(self.n) == 0:\ntotalPrice*=(1-(float(self.discount)/100))\nprint(totalPrice)\nreturn totalPrice\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.pri = {}\nleng = len(products)\nfor i in range(leng):\nself.pri[products[i]] = prices[i]\nself.n = n\nself.d = (100 - discount) / 100.0\nself.c = 1\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nm = 1.0 if self.c % self.n else self.d\nself.c += 1\ntot = 0\nfor i,p in enumerate(product):\ntot += self.pri[p] * amount[i]\nreturn tot * m\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.n=n\nself.d=discount\nself.pr={}\nfor i in range(len(products)):\nself.pr[products[i]]=prices[i]\nself.c=0\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.c+=1\nk=sum([self.pr[product[i]]*amount[i] for i in range(len(product))])\nif self.c%self.n==0:\nreturn k*float(100-self.d)/100\nelse:\nreturn k\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.n=n\nself.d=discount\nself.prod=products\nself.pric=prices\nself.c=0\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.c+=1\nk=0\nfor i in range(len(product)):\nk+=self.pric[self.prod.index(product[i])]*amount[i]\nif self.c%self.n==0:\nreturn k*float(100-self.d)/100\nelse:\nreturn k\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.n=n\nself.d=discount\nself.pr=dict(zip(products,prices))\nself.c=0\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.c+=1\nk=0\nfor i in range(len(amount)):\nk+=self.pr[product[i]]*amount[i]\nif self.c%self.n==0:\nreturn k*(100-self.d)/100.0\nelse:\nreturn k\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.n=n\nself.d=discount\nself.prod=products\nself.pric=prices\nself.c=0\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.c+=1\nk=0\nfor i in range(len(product)):\nk+=self.pric[self.prod.index(product[i])]*amount[i]\nif self.c%self.n==0:\nreturn k*(float(100-self.d)/100)\nelse:\nreturn k\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.n=n\nself.d=discount\nself.pr={}\nfor i in range(len(products)):\nself.pr[products[i]]=prices[i]\nself.c=0\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.c+=1\nk=0\nfor i in range(len(amount)):\nk+=self.pr[product[i]]*amount[i]\nif self.c%self.n==0:\nreturn k*float(100-self.d)/100\nelse:\nreturn k\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.cnt, self.n, self.discount = 0, n, discount\nself.product_dict = {products[i]: prices[i] for i in range(len(products))}\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.cnt += 1\ntotal = 0\nfor index in range(len(product)):\ntotal += self.product_dict[product[index]] * amount[index]\nif self.cnt == self.n:\nself.cnt = 0\ntotal = 1.0 * (100 - self.discount) / 100 * total\nreturn total\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.n=n\nself.d=discount\nself.pr=dict(zip(products,prices))\nself.c=0\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.c+=1\nk=0\nfor i in range(len(amount)):\nk+=self.pr[product[i]]*amount[i]\nif self.c%self.n==0:\nreturn k*float(100-self.d)/100\nelse:\nreturn k\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 585
                },
                {
                        "id": "pretrain_python_data_6954933",
                        "content": "<filename>Competitive Programming/System Design/Apply Discount Every n Orders.py\n'''https://leetcode.com/problems/apply-discount-every-n-orders/\n1357. Apply Discount Every n Orders\nMedium\n100\n143\nAdd to List\nShare\nThere is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.\nExample 1:\nInput\n[\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\nOutput\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\nExplanation\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.\n// bill = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.\n// bill = 10 * 300 + 10 * 100 = 4000.\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.\n// Original bill = 1600\n// Actual bill = 1600 * ((100 - 50) / 100) = 800.\ncashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.\ncashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.\n// Original bill = 14700, but with\n// Actual bill = 14700 * ((100 - 50) / 100) = 7350.\ncashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  6th customer, no discount.\nConstraints:\n1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.'''\n# Time:  ctor:    O(m), m is the number of all products\n#        getBill: O(p), p is the number of products to bill\n# Space: O(m)\nclass Cashier(object):\ndef __init__(self, n, discount, products, prices):\n\"\"\"\n:type n: int\n:type discount: int\n:type products: List[int]\n:type prices: List[int]\n\"\"\"\nself.__n = n\nself.__discount = discount\nself.__curr = 0\nself.__lookup = {p: prices[i] for i, p in enumerate(products)}\ndef getBill(self, product, amount):\n\"\"\"\n:type product: List[int]\n:type amount: List[int]\n:rtype: float\n\"\"\"\nself.__curr = (self.__curr+1) % self.__n\nresult = 0.0\nfor i, p in enumerate(product):\nresult += self.__lookup[p]*amount[i]\nreturn result * (1.0 - self.__discount/100.0 if self.__curr == 0 else 1.0)\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)",
                        "max_stars_repo_name": "shreejitverma/GeeksforGeeks",
                        "max_stars_count": 2,
                        "max_stars_repo_path": "Competitive Programming/System Design/Apply Discount Every n Orders.py",
                        "__cluster__": 585
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_mercury_data_173",
                        "content": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\nExample 1:\nInput\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\nConstraints:\nThe number of nodes in the tree is in the range [1, 10\u2075].\n0 <= Node.val <= 10\u2076\nAt most 10\u2075 calls will be made to hasNext, and next.\nFollow up:\nCould you implement next() and hasNext() to run in average O(1) time and use\u00a0O(h) memory, where h is the height of the tree?\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.res = []\nstack = []\ncurrent = root\nwhile stack or current:\nwhile current:\nstack.append(current)\ncurrent = current.left\ncurrent = stack.pop()\nself.res.append(current.val)\ncurrent = current.right\n#print(self.res)\nself.pointer = 0\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nif self.hasNext():\nself.pointer+=1\nreturn self.res[self.pointer-1]\nreturn 0\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn True if self.pointer<len(self.res) else False\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\ndef inorder(root):\nif root:\nreturn inorder(root.left) + [root.val] + inorder(root.right)\nelse:\nreturn []\nself.order = [-float('inf')] + inorder(root)\nself.cur = 0\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nif self.hasNext():\nself.cur += 1\nreturn self.order[self.cur]\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn self.cur != len(self.order)-1\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef giveOrder(self,tree):\nif tree ==None:\nreturn\nelse:\nself.giveOrder(tree.left)\nself.order.append(tree.val)\nself.giveOrder(tree.right)\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.order = []\nself.giveOrder(root)\nself.counter = 0\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nself.counter += 1\nreturn self.order[self.counter-1]\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn len(self.order) > self.counter\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.stack = []\nself.__leftMostNodes(root)\ndef __leftMostNodes(self, root):\nwhile root:\nself.stack.append(root)\nroot = root.left\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\ntop = self.stack.pop()\nif top.right:\nself.__leftMostNodes(top.right)\nreturn top.val\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn len(self.stack) > 0\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.node = root\nself.stack = []\nwhile self.node and self.node.left:\nself.stack.append(self.node)\nself.node = self.node.left\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nval = self.node.val\nself.node = self.node.right\nif self.node:\nwhile self.node and self.node.left:\nself.stack.append(self.node)\nself.node = self.node.left\nelse:\nif self.stack:\nself.node = self.stack.pop()\nreturn val\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn self.stack or self.node\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.list = []\nself.fillValues(root)\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nnode = self.list.pop()\nself.fillValues(node.right)\nreturn node.val\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn len(self.list) > 0\ndef fillValues(self, node):\nwhile node:\nself.list.append(node)\nnode = node.left\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.nodes = []\nself.index = -1\nself.inorder(root)\ndef inorder(self, root):\nif not root:\nreturn\nself.inorder(root.left)\nself.nodes.append(root.val)\nself.inorder(root.right)\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nself.index += 1\nreturn self.nodes[self.index]\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\n# the last element index is len(self.nodes)-1\nreturn self.index < len(self.nodes)-1\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.stack = []\nself.pushLeft(root)\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nif self.stack:\ntmp = self.stack.pop()\nself.pushLeft(tmp.right)\nreturn tmp.val\nelse:\nreturn -1\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nif self.stack:\nreturn True\nreturn False\ndef pushLeft(self,root):\nwhile root:\nself.stack.append(root)\nroot = root.left\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.cur = root\nself.stack = []\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nif self.cur:\nwhile self.cur:\nself.stack.append(self.cur)\nself.cur = self.cur.left\nnode = self.stack.pop()\nself.cur = node.right\nreturn node.val\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn self.cur or self.stack\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n[7, 3]\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\ncur_node = root\nself.node_q = []\nwhile cur_node.left:\nself.node_q.append(cur_node)\ncur_node = cur_node.left\nself.node = TreeNode(right = cur_node)\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nif self.node.right:\ncur_node = self.node.right\nwhile cur_node.left:\nself.node_q.append(cur_node)\ncur_node = cur_node.left\nself.node = cur_node\nelse:\nself.node = self.node_q.pop()\nreturn self.node.val\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nif (len(self.node_q) > 0 or self.node.right):\nreturn True\nreturn False\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.mystack = []\nself.current = root\nwhile self.current and self.current.left:\nself.mystack.append(self.current)\nself.current = self.current.left\nself.current.left = TreeNode(self.current.val-1, None, None)\nself.mystack.append(self.current)\nself.current = self.current.left\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nif self.current.right:\nself.mystack.append(self.current)\nself.current = self.current.right\nwhile self.current.left:\nself.mystack.append(self.current)\nself.current = self.current.left\nelse:\nwhile self.mystack[-1].right == self.current:\nself.current = self.mystack.pop()\nself.current = self.mystack.pop()\nreturn self.current.val\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nif self.current.right: return True\nif len(self.mystack) > 0 and self.mystack[-1].left == self.current: return True\nfor i in range(0,len(self.mystack)-1):\nif self.mystack[i].left == self.mystack[i+1]: return True\nreturn False\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.stack = []\nwhile root:\nself.stack.append(root)\nroot = root.left\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nnode = self.stack.pop()\nx = node.right\nwhile x:\nself.stack.append(x)\nx = x.left\nreturn node.val\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn len(self.stack) > 0\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\n# Build up list\ndef build_tree(node):\nif(node == None):\nreturn []\nreturn build_tree(node.left) + [node.val] + build_tree(node.right)\nself.order = build_tree(root)\nself.curr = 0\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nres = self.order[self.curr]\nself.curr += 1\nreturn res\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn (self.curr < len(self.order))\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass BSTIterator(object):\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself._stack = deque()\nwhile root:\nself._stack.append(root)\nroot = root.left\nself._current_node = None\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nself._current_node = self._stack.pop()\nnode = self._current_node\nnode = node.right\nwhile node:\nself._stack.append(node)\nnode = node.left\nreturn self._current_node.val\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn len(self._stack) != 0\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\ndef giveOrder(self,tree):\nif tree ==None:\nreturn\nelse:\nself.giveOrder(tree.left)\nself.order.append(tree.val)\nself.giveOrder(tree.right)\ndef __init__(self, root):\n\"\"\"\n:type root: TreeNode\n\"\"\"\nself.order = []\nself.giveOrder(root)\ndef next(self):\n\"\"\"\n:rtype: int\n\"\"\"\nreturn self.order.pop(0)\ndef hasNext(self):\n\"\"\"\n:rtype: bool\n\"\"\"\nreturn len(self.order) != 0\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 1613
                },
                {
                        "id": "pretrain_python_data_789502",
                        "content": "<reponame>bhimeshchauhan/competitive_programming\n\"\"\"\nBinary Search Tree Iterator\nImplement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\nExample 1:\nInput\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\nConstraints:\nThe number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 106\nAt most 105 calls will be made to hasNext, and next.\nFollow up:\nCould you implement next() and hasNext() to run in average O(1) time and use O(h) memory, where h is the height of the tree?\n\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass BSTIterator:\ndef __init__(self, root: Optional[TreeNode]):\nself.nodes = deque()\ndef dfs(node):\nif not node:\nreturn None\ndfs(node.left)\nself.nodes.append(node.val)\ndfs(node.right)\ndfs(root)\ndef next(self) -> int:\nif self.nodes:\nreturn self.nodes.popleft()\ndef hasNext(self) -> bool:\nreturn len(self.nodes)\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()",
                        "max_stars_repo_name": "bhimeshchauhan/competitive_programming",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "scripts/practice/FB-reRun/BinarySearchTreeIterator-Inorder.py",
                        "__cluster__": 1613
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_mercury_data_592",
                        "content": "Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.\nThe final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.\nExample 1:\nInput: expression = \"-1/2+1/2\"\nOutput: \"0/1\"\nExample 2:\nInput: expression = \"-1/2+1/2+1/3\"\nOutput: \"1/3\"\nExample 3:\nInput: expression = \"1/3-1/2\"\nOutput: \"-1/6\"\nConstraints:\nThe input string only contains '0' to '9', '/', '+' and '-'. So does the output.\nEach fraction (input and output) has the format \u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.\nThe input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.\nThe number of given fractions will be in the range [1, 10].\nThe numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nclass Solution(object):\ndef evaluate_fraction(self, fraction_string):\nnumerator, denominator = map(int, fraction_string.split(\"/\"))\nreturn float(numerator) / float(denominator)\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nfraction_list = expression.replace('-', '+-').split(\"+\")\ntotal_numerator = 0\ntotal_denominator = 1\nfor item in fraction_list:\nif item:\nnumerator, denominator = map(int, item.split(\"/\"))\ntotal_numerator = total_numerator * denominator + numerator * total_denominator\ntotal_denominator *= denominator\ngcd_value = self.gcd(total_numerator, total_denominator)\nsimplified_numerator = total_numerator // gcd_value\nsimplified_denominator = total_denominator // gcd_value\nreturn str(simplified_numerator) + \"/\" + str(simplified_denominator)\ndef gcd(self, a, b):\nwhile b:\na, b = b, a % b\nreturn a\nfrom fractions import Fraction\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nres = sum(map(Fraction, expression.replace('+', ' +').replace('-', ' -').split()))\nreturn str(res.numerator) + '/' + str(res.denominator)\nfrom fractions import Fraction\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nres = sum(map(Fraction, expression.replace('+', ' +').replace('-', ' -').split()))\nreturn str(res.numerator) + '/' + str(res.denominator)\nfrom fractions import Fraction\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\"\"\"\nres = sum(map(Fraction, expression.replace('+', ' +').replace('-', ' -').split()))\nreturn str(res.numerator) + '/' + str(res.denominator)\nfrom fractions import Fraction\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nexpression = expression.replace('+', ' +').replace('-', ' -')\nres = sum(map(Fraction,expression.split()))\nreturn str(res.numerator) + '/' + str(res.denominator)\nclass Solution(object):\ndef find_gcd(self, a, b):\nwhile b:\na, b = b, a%b\nreturn a\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nimport re\ntemp = re.findall('[+-]?\\d+', expression)\nints = map(int, re.findall('[+-]?\\d+', expression))\nA, B = 0, 1\nfor i in range(0,len(ints),2):\na = ints[i]\nb = ints[i+1]\nA = A * b + a * B\nB *= b\ng = self.find_gcd(A, B)\nA //= g\nB //= g\nreturn '%d/%d' % (A, B)",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 859
                },
                {
                        "id": "pretrain_python_data_5401634",
                        "content": "# Time:  O(nlogx), x is the max denominator\n# Space: O(n)\n# Given a string representing an expression of fraction addition and subtraction,\n# you need to return the calculation result in string format.\n# The final result should be irreducible fraction. If your final result is an integer, say 2,\n# you need to change it to the format of fraction that has denominator 1.\n# So in this case, 2 should be converted to 2/1.\n#\n# Example 1:\n# Input:\"-1/2+1/2\"\n# Output: \"0/1\"\n# Example 2:\n# Input:\"-1/2+1/2+1/3\"\n# Output: \"1/3\"\n# Example 3:\n# Input:\"1/3-1/2\"\n# Output: \"-1/6\"\n# Example 4:\n# Input:\"5/3+1/3\"\n# Output: \"2/1\"\n# Note:\n# The input string only contains '0' to '9', '/', '+' and '-'. So does the output.\n# Each fraction (input and output) has format \u00b1numerator/denominator.\n# If the first input fraction or the output is positive, then '+' will be omitted.\n# The input only contains valid irreducible fractions,\n# where the numerator and denominator of each fraction will\n# always be in the range [1,10]. If the denominator is 1,\n# it means this fraction is actually an integer in a fraction format defined above.\n# The number of given fractions will be in the range [1,10].\n# The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\ndef gcd(a, b):\nwhile b:\na, b = b, a%b\nreturn a\nints = map(int, re.findall('[+-]?\\d+', expression))\nA, B = 0, 1\nfor i in xrange(0, len(ints), 2):\na, b = ints[i], ints[i+1]\nA = A * b + a * B\nB *= b\ng = gcd(A, B)\nA //= g\nB //= g\nreturn '%d/%d' % (A, B)",
                        "max_stars_repo_name": "ruikunl/LeetCode",
                        "max_stars_count": 5,
                        "max_stars_repo_path": "Python/fraction-addition-and-subtraction.py",
                        "__cluster__": 859
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_4049287",
                        "content": "\"\"\"\nLINK: https://leetcode.com/problems/linked-list-cycle-ii/\nGiven a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\nNotice that you should not modify the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\nExample 3:\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.\nConstraints:\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.\nFollow up: Can you solve it using O(1) (i.e. constant) memory?\n\"\"\"\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\ndef detectCycle(head):\nslow, fast = head, head\ncycle = False\nwhile fast is not None and fast.next is not None:\nslow = slow.next\nfast = fast.next.next\nif slow==fast:\ncycle = True\nbreak\nif not cycle:\nreturn None\nelse:\nwhile slow!=head:\nhead = head.next\nslow = slow.next\nreturn head",
                        "max_stars_repo_name": "lorenzophys/coding-problems-playground",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "LeetCode/Medium/142-LinkedListCycleII.py",
                        "__cluster__": 1614
                },
                {
                        "id": "test_mercury_data_142",
                        "content": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\nExample 3:\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.\nConstraints:\nThe number of the nodes in the list is in the range [0, 10\u2074].\n-10\u2075 <= Node.val <= 10\u2075\npos is -1 or a valid index in the linked-list.\nFollow up: Can you solve it using O(1) (i.e. constant) memory?\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\nif head == None or head.next == None:\nreturn None\nslow = fast = entry = head\nwhile fast.next != None and fast.next.next != None:\nslow = slow.next\nfast = fast.next.next\nif fast == slow:\nwhile slow != entry:\nslow = slow.next\nentry = entry.next\nreturn entry\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nhashset = set()\nwhile head != None:\nif head in hashset:\nreturn head\nhashset.add(head)\nhead = head.next\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nnodemap = set()\nwhile head:\nif head in nodemap:\nreturn head\nelse:\nnodemap.add(head)\nhead= head.next\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nslow = fast = head\nwhile fast and fast.next:\nslow = slow.next\nfast = fast.next.next\nif slow == fast:\nslow = head\nwhile slow != fast:\nslow = slow.next\nfast = fast.next\nreturn slow\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\nslow = head\nfast = head\nwhile fast and fast.next:\nslow = slow.next\nfast = fast.next.next\nif slow == fast:\nslow = head\nwhile slow != fast:\nslow = slow.next\nfast = fast.next\nreturn slow\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\ni = head\nj = head\nwhile j and j.next:\ni = i.next\nj = j.next.next\nif i == j:\ni = head\nwhile i != j:\ni = i.next\nj = j.next\nreturn i\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nfound = dict()\ncounter = 0\ncur = head\nwhile cur:\nif cur in found:\nreturn cur\nfound[cur] = counter\ncounter += 1\ncur = cur.next\nreturn None\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution(object):\ndef detectCycle(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nseen = set()\ncurr = head\nwhile curr != None:\nif curr.next in seen:\nreturn curr.next\nseen.add(curr)\ncurr = curr.next\nreturn None",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 1614
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_4188184",
                        "content": "# Math\n# Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1.\n#\n# Example 1:\n# Input:\"-1/2+1/2\"\n# Output: \"0/1\"\n# Example 2:\n# Input:\"-1/2+1/2+1/3\"\n# Output: \"1/3\"\n# Example 3:\n# Input:\"1/3-1/2\"\n# Output: \"-1/6\"\n# Example 4:\n# Input:\"5/3+1/3\"\n# Output: \"2/1\"\n# Note:\n# The input string only contains '0' to '9', '/', '+' and '-'. So does the output.\n# Each fraction (input and output) has format \u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.\n# The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.\n# The number of given fractions will be in the range [1,10].\n# The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.\nfrom fractions import Fraction\nclass Solution:\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nres = sum(map(Fraction, expression.replace('+',' +').replace('-', ' -').split()))\nreturn str(res.numerator) + '/' + str(res.denominator)",
                        "max_stars_repo_name": "gesuwen/Algorithms",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "LeetCode/592 Fraction Addition and Subtraction.py",
                        "__cluster__": 859
                },
                {
                        "id": "test_mercury_data_592",
                        "content": "Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.\nThe final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.\nExample 1:\nInput: expression = \"-1/2+1/2\"\nOutput: \"0/1\"\nExample 2:\nInput: expression = \"-1/2+1/2+1/3\"\nOutput: \"1/3\"\nExample 3:\nInput: expression = \"1/3-1/2\"\nOutput: \"-1/6\"\nConstraints:\nThe input string only contains '0' to '9', '/', '+' and '-'. So does the output.\nEach fraction (input and output) has the format \u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.\nThe input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.\nThe number of given fractions will be in the range [1, 10].\nThe numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nclass Solution(object):\ndef evaluate_fraction(self, fraction_string):\nnumerator, denominator = map(int, fraction_string.split(\"/\"))\nreturn float(numerator) / float(denominator)\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nfraction_list = expression.replace('-', '+-').split(\"+\")\ntotal_numerator = 0\ntotal_denominator = 1\nfor item in fraction_list:\nif item:\nnumerator, denominator = map(int, item.split(\"/\"))\ntotal_numerator = total_numerator * denominator + numerator * total_denominator\ntotal_denominator *= denominator\ngcd_value = self.gcd(total_numerator, total_denominator)\nsimplified_numerator = total_numerator // gcd_value\nsimplified_denominator = total_denominator // gcd_value\nreturn str(simplified_numerator) + \"/\" + str(simplified_denominator)\ndef gcd(self, a, b):\nwhile b:\na, b = b, a % b\nreturn a\nfrom fractions import Fraction\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nres = sum(map(Fraction, expression.replace('+', ' +').replace('-', ' -').split()))\nreturn str(res.numerator) + '/' + str(res.denominator)\nfrom fractions import Fraction\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nres = sum(map(Fraction, expression.replace('+', ' +').replace('-', ' -').split()))\nreturn str(res.numerator) + '/' + str(res.denominator)\nfrom fractions import Fraction\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\"\"\"\nres = sum(map(Fraction, expression.replace('+', ' +').replace('-', ' -').split()))\nreturn str(res.numerator) + '/' + str(res.denominator)\nfrom fractions import Fraction\nclass Solution(object):\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nexpression = expression.replace('+', ' +').replace('-', ' -')\nres = sum(map(Fraction,expression.split()))\nreturn str(res.numerator) + '/' + str(res.denominator)\nclass Solution(object):\ndef find_gcd(self, a, b):\nwhile b:\na, b = b, a%b\nreturn a\ndef fractionAddition(self, expression):\n\"\"\"\n:type expression: str\n:rtype: str\n\"\"\"\nimport re\ntemp = re.findall('[+-]?\\d+', expression)\nints = map(int, re.findall('[+-]?\\d+', expression))\nA, B = 0, 1\nfor i in range(0,len(ints),2):\na = ints[i]\nb = ints[i+1]\nA = A * b + a * B\nB *= b\ng = self.find_gcd(A, B)\nA //= g\nB //= g\nreturn '%d/%d' % (A, B)",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 859
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_7343166",
                        "content": "\"\"\"\n1603. Design Parking System\nEasy\nDesign a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\nImplement the ParkingSystem class:\nParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.\nbool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.\nExample 1:\nInput\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\nOutput\n[null, true, true, false, false]\nExplanation\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\nConstraints:\n0 <= big, medium, small <= 1000\ncarType is 1, 2, or 3\nAt most 1000 calls will be made to addCar\n\"\"\"\nclass ParkingSystem:\ndef __init__(self, big: int, medium: int, small: int):\nself.A = [big, medium, small]\ndef addCar(self, carType: int) -> bool:\nself.A[carType - 1] -= 1\nreturn self.A[carType - 1] >= 0\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)",
                        "max_stars_repo_name": "VinceW0/Leetcode_Python_solutions",
                        "max_stars_count": 4,
                        "max_stars_repo_path": "Algorithms_easy/1603. Design Parking System.py",
                        "__cluster__": 245
                },
                {
                        "id": "test_mercury_data_1603",
                        "content": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\nImplement the ParkingSystem class:\nParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.\nbool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.\nExample 1:\nInput\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\nOutput\n[null, true, true, false, false]\nExplanation\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\nConstraints:\n0 <= big, medium, small <= 1000\ncarType is 1, 2, or 3\nAt most 1000 calls will be made to addCar\nclass ParkingSystem(object):\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\nclass ParkingSystem(object):\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\nself.space={}\nself.space[1]=big\nself.space[2]=medium\nself.space[3] = small\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\nif self.space[carType]>0:\nself.space[carType]-=1\nreturn True\nreturn False\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\nclass ParkingSystem(object):\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\nself.e = [big, medium, small]\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\nif self.e[carType - 1] > 0:\nself.e[carType - 1] -= 1\nreturn True\nreturn False\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\nclass ParkingSystem(object):\n# 1 = BIG\n# 2 = MEDIUM\n# 3 = SMALL\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\nself.parking_system = {1:big, 2:medium, 3:small}\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\nspaces = self.parking_system[carType]\nif spaces > 0:\nself.parking_system[carType] = spaces-1\nreturn True\nelse:\nreturn False\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\nclass ParkingSystem(object):\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\nself.bigCount = big\nself.mediumCount = medium\nself.smallCount = small\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\nif carType == 1:\nself.bigCount -= 1\nreturn self.bigCount >= 0\nelif carType == 2:\nself.mediumCount -= 1\nreturn self.mediumCount >= 0\nelif carType == 3:\nself.smallCount -= 1\nreturn self.smallCount >= 0\nclass ParkingSystem(object):\n__slots__ = [\"slots\"]\ndef __init__(self, big, medium, small):\nself.slots = [big, medium, small]\ndef addCar(self, carType):\nif self.slots[carType - 1] > 0:\nself.slots[carType - 1] -= 1\nreturn True\nelse:\nreturn False\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\nclass ParkingSystem(object):\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\nself.big = big\nself.medium = medium\nself.small = small\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\nif carType == 1:\nif self.big > 0 :\nself.big -= 1\nreturn True\nelse:\nreturn False\nif carType == 2:\nif self.medium > 0 :\nself.medium -= 1\nreturn True\nelse:\nreturn False\nif carType == 3:\nif self.small > 0 :\nself.small -= 1\nreturn True\nelse:\nreturn False\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\nclass ParkingSystem(object):\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\nself.empty = [big, medium, small]\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\nif self.empty[carType-1] > 0:\nself.empty[carType-1] -= 1\nreturn True\nreturn False\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\nclass ParkingSystem(object):\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\nself.big = big\nself.medium = medium\nself.small = small\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\nif carType == 1:\nif self.big == 0:\nreturn False\nelse:\nself.big = self.big - 1\nreturn True\nif carType == 2:\nif self.medium == 0:\nreturn False\nelse:\nself.medium = self.medium - 1\nreturn True\nif carType == 3:\nif self.small == 0:\nreturn False\nelse:\nself.small = self.small - 1\nreturn True\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\nclass ParkingSystem:\ndef __init__(self, big, medium, small):\nself.spots = [big, medium, small]\ndef addCar(self, carType):\nif self.spots[carType - 1] > 0:\nself.spots[carType - 1] -= 1\nreturn True\nreturn False\nclass ParkingSystem(object):\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\nself.big = big\nself.medium = medium\nself.small = small\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\nif carType == 1: #big\nif self.big >= 1:\nself.big -= 1\nreturn True\nreturn False\nelif carType == 2: #medium\nif self.medium >= 1:\nself.medium -= 1\nreturn True\nreturn False\nelse: #small\nif self.small >= 1:\nself.small -= 1\nreturn True\nreturn False\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\nclass ParkingSystem(object):\ndef __init__(self, big, medium, small):\n\"\"\"\n:type big: int\n:type medium: int\n:type small: int\n\"\"\"\nself.cars = {}\nself.cars[1] = big\nself.cars[2] = medium\nself.cars[3] = small\ndef addCar(self, carType):\n\"\"\"\n:type carType: int\n:rtype: bool\n\"\"\"\nif self.cars[carType] > 0:\nself.cars[carType] -= 1\nreturn True\nreturn False\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 245
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_mercury_data_722",
                        "content": "Given a C++ program, remove comments from it. The program source is an array of strings source where source[i] is the ith line of the source code. This represents the result of splitting the original source code string by the newline character '\\n'.\nIn C++, there are two types of comments, line comments, and block comments.\nThe string \"//\" denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored.\nThe string \"/*\" denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of \"*/\" should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string \"/*/\" does not yet end the block comment, as the ending would be overlapping the beginning.\nThe first effective comment takes precedence over others.\nFor example, if the string \"//\" occurs in a block comment, it is ignored.\nSimilarly, if the string \"/*\" occurs in a line or block comment, it is also ignored.\nIf a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\nThere will be no control characters, single quote, or double quote characters.\nFor example, source = \"string s = \"/* Not a comment. */\";\" will not be a test case.\nAlso, nothing else such as defines or macros will interfere with the comments.\nIt is guaranteed that every open block comment will eventually be closed, so \"/*\" outside of a line or block comment always starts a new comment.\nFinally, implicit newline characters can be deleted by block comments. Please see the examples below for details.\nAfter removing the comments from the source code, return the source code in the same format.\nExample 1:\nInput: source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]\nOutput: [\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]\nExplanation: The line by line code is visualized as below:\n/*Test program */\nint main()\n{\n// variable declaration\nint a, b, c;\n/* This is a test\nmultiline\ncomment for\ntesting */\na = b + c;\n}\nThe string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.\nThe line by line output code is visualized as below:\nint main()\n{\nint a, b, c;\na = b + c;\n}\nExample 2:\nInput: source = [\"a/*comment\", \"line\", \"more_comment*/b\"]\nOutput: [\"ab\"]\nExplanation: The original source string is \"a/*comment\\nline\\nmore_comment*/b\", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string \"ab\", which when delimited by newline characters becomes [\"ab\"].\nConstraints:\n1 <= source.length <= 100\n0 <= source[i].length <= 80\nsource[i] consists of printable ASCII characters.\nEvery open block comment is eventually closed.\nThere are no single-quote or\u00a0double-quote in the input.\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\nclass Solution:\ndef removeComments(self, source):\nans, inComment = [], False\nnew_str = \"\"\nfor c in source:\nif not inComment: new_str = \"\"\ni, n = 0, len(c)\n# inComment, we find */\nwhile i < n:\nif inComment:\nif c[i:i + 2] == '*/' and i + 1 < n:\ni += 2\ninComment = False\ncontinue\ni += 1\n# not in Comment, we find /* // and common character\nelse:\nif c[i:i + 2] == '/*':\ni += 2\ninComment = True\ncontinue\nif c[i:i + 2] == '//' and i + 1 < n:\nbreak\nnew_str += c[i]\ni += 1\nif new_str and not inComment:\nans.append(new_str)\nreturn ans\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\ninComment = False\nres = []\ncurr = \"\"\nfor line in source:\nif not inComment:\ncurr = \"\"\ni, n = 0, len(line)\nwhile i < n:\nif inComment:\nif line[i:i+2] == \"*/\":\ni += 2\ninComment = False\nelse:\ni += 1\nelse:\nif line[i:i+2] == \"/*\":\ni += 2\ninComment = True\nelif line[i:i+2] == \"//\":\nbreak\nelse:\ncurr += line[i]\ni += 1\nif curr and not inComment:\nres.append(curr)\nreturn res\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\nres=[]\nk=0\nfor m,line in enumerate(source):\nif k==0:\nkept=\"\"\nfor i in range(len(line)):\nif k == 0 and line[i:i+2] == \"//\":\n#kept=\"\"\nbreak\nif k== 0 and line[i:i+2] == \"/*\":\nk =1\nmark=[m,i]\n#\nif k == 1 and len(line)>=2 and line[i-1:i+1] == \"*/\":\nif m==mark[0] and len(line[mark[1]:i+1])==3: #set(line[mark[1]:i])==set(\"/*\"):\nk=1\nelse:\nk=0\ncontinue\n# if i != len(line)-1:\n#     kept = kept  + line[i+1]\n# if len(kept)!=0 and k==0:\n#     res.append(kept)\n#     kept=\"\"\n# break\nif k==0 :\nkept = kept  + line[i]\nprint(kept,res)\nif kept and k==0:\nres.append(kept)\nreturn res\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\n# create empty arrays for the emptied comments, then remove those empty arrays afterwards\n# how to keep track of block level comment across lines?\n# boolean value to not include\n# if we encounter a / , then check if element after /\n# is /\n# move onto the next line\n# is *\n# change boolean to true (we are in a comment)\n# if we encounter a *, check if element after is a /\n# change boolean to false (we are no longer in a comment)\nincomment = False\nneedjoin = False\nans = []\nfor line in source:\ntempstring = \"\"\nx = 0\nwhile x < len(line):\n# print(line[x])\nif line[x] == \"/\":\nif not incomment:\nif x == len(line)-1:\ntempstring += line[x]\nbreak\nif line[x+1] == \"/\":\nbreak\nif line[x+1] == \"*\":\nincomment = True\nx += 1\nelse:\ntempstring += line[x]\nelif line[x] == \"*\":\nif not incomment:\ntempstring += line[x]\nelif x < len(line)-1 and line[x+1] == \"/\":\nincomment = False\n# skip two\nx += 1\nelif not incomment:\ntempstring += line[x]\nx += 1\n# print(tempstring)\nif len(tempstring) > 0:\nprint(tempstring)\nif needjoin:\nans[-1] = ans[-1] + tempstring\nneedjoin = False\nelse:\nans.append(tempstring)\nif incomment:\nneedjoin = True\nelif needjoin and not incomment:\nneedjoin = False\nreturn ans\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\nans, inComment = [], False\nnew_str = \"\"\nfor c in source:\nif not inComment: new_str = \"\"\ni, n = 0, len(c)\n# inComment, we find */\nwhile i < n:\nif inComment:\nif c[i:i + 2] == '*/':\ni += 2\ninComment = False\ncontinue\ni += 1\n# not in Comment, we find /* // and common character\nelse:\nif c[i:i + 2] == '/*':\ni += 2\ninComment = True\ncontinue\nif c[i:i + 2] == '//':\nbreak\nnew_str += c[i]\ni += 1\nif new_str and not inComment:\nans.append(new_str)\nreturn ans\n# res = []\n# start = False\n# for line in source:\n#     if start == True:\n#         if '*/' in line:\n#             start = False\n#             position = line.rindex('*/')\n#             if position == len(line)-2:\n#                 continue\n#             else:\n#                 temp_line += line[position+2:]\n#                 res.append(temp_line)\n#                 continue\n#         else:\n#             continue\n#     if '//' in line:\n#         position = line.index('//')\n#         if line[:position]:\n#             res.append(line[:position])\n#     elif '/*' in line:\n#         position = line.index('/*')\n#         temp_line = ''\n#         temp_line += line[:position]\n#         if '*/' in line:\n#             position = line.rindex('*/')\n#             temp_line += line[position+2:]\n#             if len(temp_line) != 0:\n#                 res.append(temp_line)\n#         else:\n#             start = True\n#     else:\n#         res.append(line)\n# return [i for i in res if i]\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\n# create empty arrays for the emptied comments, then remove those empty arrays afterwards\n# how to keep track of block level comment across lines?\n# boolean value to not include\n# if we encounter a / , then check if element after\n# if it's last element in the line, add it\n# is /\n# move onto the next line\n# is *\n# change boolean to true (we are in a comment)\n# skip two elements to ignore both / and *\n# if we encounter a *, check if element after is a /\n# change boolean to false (we are no longer in a comment)\n# skip two elements to ignore both * and /\nincomment = False\nneedjoin = False\nans = []\nfor line in source:\ntempstring = \"\"\nx = 0\nwhile x < len(line):\n# print(line[x])\nif line[x] == \"/\":\nif not incomment:\nif x == len(line)-1:\ntempstring += line[x]\nbreak\nif line[x+1] == \"/\":\nbreak\nif line[x+1] == \"*\":\nincomment = True\nx += 1\nelse:\ntempstring += line[x]\nelif line[x] == \"*\":\nif not incomment:\ntempstring += line[x]\nelif x < len(line)-1 and line[x+1] == \"/\":\nincomment = False\n# skip two\nx += 1\nelif not incomment:\ntempstring += line[x]\nx += 1\n# print(tempstring)\nif len(tempstring) > 0:\nprint(tempstring)\nif needjoin:\nans[-1] = ans[-1] + tempstring\nneedjoin = False\nelse:\nans.append(tempstring)\nif incomment:\nneedjoin = True\nelif needjoin and not incomment:\nneedjoin = False\nreturn ans\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\nres=[]\nk=0\nfor m,line in enumerate(source):\nif k==0:\nkept=\"\"\nfor i in range(len(line)):\nif k == 0 and line[i:i+2] == \"//\":\nbreak\nif k== 0 and line[i:i+2] == \"/*\":\nk =1\nmark=[m,i]\nif k == 1 and len(line)>=2 and line[i-1:i+1] == \"*/\":\nif m==mark[0] and len(line[mark[1]:i+1])==3:\nk=1\nelse:\nk=0\ncontinue\nif k==0 :\nkept = kept  + line[i]\nprint(kept,res)\nif kept and k==0:\nres.append(kept)\nreturn res\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\nres, inComment = [], False\nnew_str = \"\"\nfor c in source:\nif not inComment: new_str = \"\"\ni, n = 0, len(c)\nwhile i < n:\nif inComment:\nif c[i:i+2] == \"*/\" and i + 1 < n:\ni += 2\ninComment = False\ncontinue\ni += 1\nelse:\nif c[i:i+2] == \"/*\" and i+1 < n:\ni += 2\ninComment = True\ncontinue\nif c[i:i+2] == \"//\" and i + 1 < n:\nbreak\nnew_str += c[i]\ni += 1\nif new_str and not inComment:\nres.append(new_str)\nreturn res\nclass Solution(object):\ndef removeComments(self, source):\noutput = []\ninBlock = False\nline = []\nfor s in source:\ni = 0\nif not inBlock:\nline = []\nwhile i < len(s):\nif i+1 < len(s) and s[i:i+2] == \"/*\" and not inBlock:\ninBlock = True\ni += 1\nelif i+1 < len(s) and s[i:i+2] == \"*/\" and inBlock:\ninBlock = False\ni += 1\nelif i+1 < len(s) and s[i:i+2] == \"//\" and not inBlock:\nbreak\nelif not inBlock:\nline.append(s[i])\ni += 1\n# If we are not inside a block comment and line is not empty, add it to the result\nif line and not inBlock:\noutput.append(\"\".join(line))\nreturn output\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\nans, inComment = [], False\nnew_str = ''\nfor line in source:\nif not inComment: new_str = ''\ni, n = 0, len(line)\nwhile i < n:\nif inComment:\nif line[i:i+2] == '*/':\ninComment = False\ni += 2\ncontinue\ni += 1\nelse:\nif line[i:i+2] == '/*':\ninComment = True\ni += 2\ncontinue\nif line[i:i+2] == '//':\nbreak\nnew_str += line[i]\ni += 1\nif new_str and not inComment:\nans.append(new_str)\nreturn ans\nclass Solution(object):\ndef removeComments(self, source):\nout=[]\ninblock=False\ncur=\"\"\nfor s in source:\nn=len(s)\nptr=0\nwhile(ptr<n):\nif inblock:\nif s[ptr:ptr+2]==\"*/\":\nptr+=2\ninblock=False\nelse:\nptr+=1\nelse:\nif s[ptr:ptr+2]==\"//\":\nbreak\nif s[ptr:ptr+2]==\"/*\":\nptr+=2\ninblock=True\nelse:\ncur+=s[ptr]\nptr+=1\nif not inblock and cur:\nout.append(cur)\ncur=\"\"\nreturn out",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 1162
                },
                {
                        "id": "pretrain_python_data_4286910",
                        "content": "'''\nGiven a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code. This represents the result of splitting the original source code string by the newline character \\n.\nIn C++, there are two types of comments, line comments, and block comments.\nThe string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.\nThe string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.\nThe first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.\nIf a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\nThere will be no control characters, single quote, or double quote characters. For example, source = \"string s = \"/* Not a comment. */\";\" will not be a test case. (Also, nothing else such as defines or macros will interfere with the comments.)\nIt is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.\nFinally, implicit newline characters can be deleted by block comments. Please see the examples below for details.\nAfter removing the comments from the source code, return the source code in the same format.\nExample 1:\nInput:\nsource = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]\nThe line by line code is visualized as below:\n/*Test program */\nint main()\n{\n// variable declaration\nint a, b, c;\n/* This is a test\nmultiline\ncomment for\ntesting */\na = b + c;\n}\nOutput: [\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]\nThe line by line code is visualized as below:\nint main()\n{\nint a, b, c;\na = b + c;\n}\nExplanation:\nThe string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.\nExample 2:\nInput:\nsource = [\"a/*comment\", \"line\", \"more_comment*/b\"]\nOutput: [\"ab\"]\nExplanation: The original source string is \"a/*comment\\nline\\nmore_comment*/b\", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string \"ab\", which when delimited by newline characters becomes [\"ab\"].\nNote:\nThe length of source is in the range [1, 100].\nThe length of source[i] is in the range [0, 80].\nEvery open block comment is eventually closed.\nThere are no single-quote, double-quote, or control characters in the source code.\n'''\nclass Solution(object):\ndef removeComments(self, source):\n\"\"\"\n:type source: List[str]\n:rtype: List[str]\n\"\"\"\nres = []\ntmp = ''\nin_comment = False\nfor i in xrange(len(source)):\nj = 0\nwhile j < len(source[i]):\nif in_comment:\nif j+1 < len(source[i]) and source[i][j:j+2] == '*/':\nin_comment = False\nj += 2\nelse:\nj += 1\nelse:\nif j+1 < len(source[i]) and source[i][j:j+2] == '/*':\nin_comment = True\nj += 2\nelif j+1 < len(source[i]) and source[i][j:j+2] == '//':\nbreak\nelse:\ntmp += source[i][j]\nj += 1\nif not in_comment:\nif tmp:\nres.append(tmp)\ntmp = ''\nreturn res",
                        "max_stars_repo_name": "sugia/leetcode",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "Remove Comments.py",
                        "__cluster__": 1162
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_1251123",
                        "content": "\"\"\"\nSearch in Rotated Sorted Array II - Non Distinct\nThere is an integer array nums sorted in\nnon-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is\nrotated at an unknown pivot index k (0 <= k < nums.length)\nsuch that the resulting array is [nums[k], nums[k+1], ...,\nnums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed).\nFor example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot\nindex 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target,\nreturn true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\nConstraints:\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums is guaranteed to be rotated at some pivot.\n-104 <= target <= 104\nFollow up: This problem is similar to Search in Rotated Sorted Array, but\nnums may contain duplicates. Would this affect the runtime complexity?\nHow and why?\n\"\"\"\n# Binary Search\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nl, h = 0, len(nums)-1\nwhile l <= h:\nm = ((h-l) >> 1)+l\nif nums[m] == target:\nreturn True\nelif nums[m] > nums[l]:  # left is ordered\nif nums[l] <= target < nums[m]:\nh = m - 1\nelse:\nl = m + 1\nelif nums[m] < nums[l]:  # right is ordered\nif nums[m] < target <= nums[h]:\nl = m + 1\nelse:\nh = m - 1\nelse:  # cannot determine\nl += 1\nreturn False\n\"\"\"\nTime complexity depends on inputs. For distinct values, it's O(logN).\nThe worst case is O(N) for all same values\n\"\"\"",
                        "max_stars_repo_name": "bhimeshchauhan/competitive_programming",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "scripts/fb/SearchInRotatedSortedArrayNon-Distinct.py",
                        "__cluster__": 1815
                },
                {
                        "id": "test_mercury_data_81",
                        "content": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\nConstraints:\n1 <= nums.length <= 5000\n-10\u2074 <= nums[i] <= 10\u2074\nnums is guaranteed to be rotated at some pivot.\n-10\u2074 <= target <= 10\u2074\nFollow up: This problem is similar to\u00a0Search in Rotated Sorted Array, but\u00a0nums may contain duplicates. Would this affect the runtime complexity? How and why?\nclass Solution(object):\ndef search(self, nums, target):\n\"\"\"\n:type nums: List[int]\n:type target: int\n:rtype: bool\n\"\"\"\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nif target in nums:\nreturn True\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\n# if not nums or len(nums) == 0:return False\nl, r = 0, len(nums) - 1\nwhile(l <= r):\nmid = (l + r) // 2\nif nums[mid] == target:\nreturn True\n# \u526a\u679d\nif nums[l] == nums[mid]:\nl += 1\ncontinue\nif nums[mid] >= nums[l]:\nif target > nums[mid] or target < nums[l]:\nl = mid + 1\nelse:\nr = mid - 1\nelse:\nif target < nums[mid] or target > nums[r]:\nr = mid - 1\nelse:\nl = mid + 1\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nreturn target in nums\nlow, high = 0, len(nums) - 1\nwhile low <= high:\nmid = low + (high - low) // 2\nif nums[mid] == target: return True\nif nums[low] < nums[mid]:\nif nums[low] <= target < nums[mid]:\nhigh = mid - 1\nelse:\nlow = mid + 1\nelif nums[low] > nums[mid]:\nif nums[mid] < target <= nums[high]:\nlow = mid + 1\nelse:\nhigh = mid - 1\nelse:\nlow += 1\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nlow, high = 0, len(nums) - 1\nwhile low <= high:\nmid = (low + high) // 2\nif nums[mid] == target:\nreturn True\nif nums[low] == nums[mid] == nums[high]:\nlow += 1\nhigh -= 1\n#left half is sorted\nelif nums[low] <= nums[mid]:\nif nums[low] <= target and target <= nums[mid]:\nhigh = mid - 1\nelse:\nlow = mid + 1\n#right half is sorted\nelif nums[high] >= nums[mid]:\nif nums[high] >= target and target >= nums[mid]:\nlow = mid + 1\nelse:\nhigh = mid - 1\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nif len(nums)==1:\nif nums[0]!=target:\nreturn False\nelse:\nreturn True\nlow=0\nhigh=len(nums)-1\nwhile(low<=high):\nwhile low<high and nums[low] == nums[low+1]:\nlow+=1\nwhile low<high and nums[high] == nums[high-1]:\nhigh-=1\nmid=(low+high)//2\nif nums[mid]==target:\nreturn True\nelif nums[low]<=nums[mid]:\nif nums[mid]>=target and nums[low]<=target:\nhigh=mid-1\nelse:\nlow=mid+1\nelse:\nif target>=nums[mid] and target<=nums[high]:\nlow=mid+1\nelse:\nhigh=mid-1\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nreturn target in nums\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nif not nums:\nreturn False\nl, r = 0, len(nums) - 1\nwhile l < r:\nwhile l < r and nums[l] == nums[l+1]:\nl += 1\nwhile l < r and nums[r] == nums[r-1]:\nr -= 1\nm = (l + r)// 2\nif target == nums[m]:\nreturn True\nif nums[l] <= nums[m] < target or nums[m] < target <= nums[r] or target <= nums[r] <= nums[m]:\nl = m + 1\nelse:\nr = m - 1\nif nums[r] == target:\nreturn True\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nlow = 0\nhigh = len(nums)-1\nwhile low <= high:\nmid = (low+high)//2\nif nums[mid]==target:\nreturn True\nelif nums[low]==nums[mid] and nums[high]==nums[mid]:\nlow += 1\nhigh -= 1\ncontinue\nelif nums[low]<=nums[mid]:\nif target<=nums[mid] and target>=nums[low]:\nhigh = mid-1\nelse:\nlow = mid+1\nelse:\nif target>=nums[mid] and target<=nums[high]:\nlow = mid+1\nelse:\nhigh = mid-1\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nif target in nums:\nreturn True\nelse:\nreturn False\nclass Solution:\ndef search(self, arr: List[int], k: int) -> bool:\narr.sort()\nn=len(arr)\nl=0\nh=n-1\nwhile l<=h:\nmid=(l+h)//2\nif arr[mid]==k:\nreturn 1\nif arr[l]<=arr[mid]:\nif arr[l]<=k and k<=arr[mid]:\nh=mid-1\nelse:\nl=mid+1\nelse:\nif arr[mid]<=k and k<=arr[h]:\nl=mid+1\nelse:\nh=mid-1\nreturn 0\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nleft = 0\nright = len(nums) - 1\nwhile left <= right:\nwhile left < right and nums[left] == nums[left+1]:\nleft += 1\nwhile left < right and nums[right] == nums[right-1]:\nright -= 1\nmid = (left + right) // 2\nif nums[mid] == target:\nreturn True\nif nums[left] <= nums[mid]:\nif nums[mid] >= target and nums[left] <= target:\nright = mid - 1\nelse:\nleft = mid + 1\nelse:\nif nums[mid] <= target and nums[right] >= target:\nleft = mid + 1\nelse:\nright = mid - 1\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nleft, right = 0, len(nums) - 1\nwhile left < right:\nmid = (left + right) // 2\nif nums[left] == target:\nreturn True\n# subarray on mid's left is sorted\nif nums[mid] > nums[left]:\nif target >= nums[left] and target <= nums[mid]:\nright = mid\nelse:\nleft = mid + 1\n# subarray on mid's right is sorted\nelif nums[mid] < nums[right]:\nif target > nums[mid] and target <= nums[right]:\nleft = mid + 1\nelse:\nright = mid\nelse:\nleft += 1\nif nums[left] == target:\nreturn True\nelse:\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nl = 0\nr = len(nums) - 1\nwhile l <= r:\nmid = l + (r - l) // 2\nif nums[mid] == target:\nreturn True\nif nums[mid] < nums[r]:\nif nums[mid] < target <= nums[r]:\nl = mid + 1\nelse:\nr = mid - 1\nelif nums[mid] > nums[r]:\nif nums[l] <= target < nums[mid]:\nr = mid - 1\nelse:\nl = mid + 1\nelse:\nr -= 1\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nleft, right = 0, len(nums) - 1\nwhile left <= right:\nif nums[left] == target or nums[right] == target:\nreturn True\nleft += 1\nright -= 1\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nlow=0\nn=len(nums)\nhigh = n - 1\nwhile low <= high:\nmid = (low + high) // 2\nif nums[mid] == target:\nreturn True\nif nums[low]==nums[mid] and nums[mid]==nums[high]:\nlow+=1\nhigh-=1\ncontinue\nif nums[low] <=nums[mid]:\nif nums[low] <= target and target <= nums[mid]:\nhigh = mid - 1\nelse:\nlow = mid + 1\nelse:\nif nums[mid] <= target and target<= nums[high]:\nlow = mid + 1\nelse:\nhigh = mid - 1\nreturn False\nclass Solution:\ndef search(self, nums: List[int], target: int) -> bool:\nleft, right = 0, len(nums) - 1\nwhile left <= right:\nmid = (left + right) >> 1\nif nums[mid] == target:\nreturn True\nif nums[left] == nums[mid]:\nleft += 1\ncontinue\nif nums[left] <= nums[mid]:\nif nums[left] <= target < nums[mid]:\nright  = mid - 1\nelse:\nleft = mid + 1\nelse:\nif nums[mid] < target <= nums[right]:\nleft = mid + 1\nelse:\nright = mid - 1\nreturn False",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 1815
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_10912529",
                        "content": "<gh_stars>10-100\n# Given two arrays of integers nums and index.\n# Your task is to create target array under the following rules:\n# Initially target array is empty.\n# From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.\n# Repeat the previous step until there are no elements to read in nums and index.\n# Return the target array.\n# It is guaranteed that the insertion operations will be valid.\n# Example 1:\n# Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]\n# Output: [0,4,1,3,2]\n# Explanation:\n# nums       index     target\n# 0            0        [0]\n# 1            1        [0,1]\n# 2            2        [0,1,2]\n# 3            2        [0,1,3,2]\n# 4            1        [0,4,1,3,2]\n# Example 2:\n# Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]\n# Output: [0,1,2,3,4]\n# Explanation:\n# nums       index     target\n# 1            0        [1]\n# 2            1        [1,2]\n# 3            2        [1,2,3]\n# 4            3        [1,2,3,4]\n# 0            0        [0,1,2,3,4]\n# Example 3:\n# Input: nums = [1], index = [0]\n# Output: [1]\n# Constraints:\n# 1 <= nums.length, index.length <= 100\n# nums.length == index.length\n# 0 <= nums[i] <= 100\n# 0 <= index[i] <= i\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\n# \u6a21\u62df\ntarget = []\nfor i in range(len(index)):\ntarget.insert(index[i], nums[i])  # insert(\u4f4d\u7f6e, \u503c)\nreturn target\n",
                        "max_stars_repo_name": "WatsonWangZh/CodingPractice",
                        "max_stars_count": 11,
                        "max_stars_repo_path": "LeetCode/Python3/Array/1389. Create Target Array in the Given Order.py",
                        "__cluster__": 1037
                },
                {
                        "id": "test_mercury_data_1389",
                        "content": "Given two arrays of integers\u00a0nums and index. Your task is to create target array under the following rules:\nInitially target array is empty.\nFrom left to right read nums[i] and index[i], insert at index index[i]\u00a0the value nums[i]\u00a0in\u00a0target array.\nRepeat the previous step until there are no elements to read in nums and index.\nReturn the target array.\nIt is guaranteed that the insertion operations will be valid.\nExample 1:\nInput: nums = [0,1,2,3,4], index = [0,1,2,2,1]\nOutput: [0,4,1,3,2]\nExplanation:\nnums       index     target\n0            0        [0]\n1            1        [0,1]\n2            2        [0,1,2]\n3            2        [0,1,3,2]\n4            1        [0,4,1,3,2]\nExample 2:\nInput: nums = [1,2,3,4,0], index = [0,1,2,3,0]\nOutput: [0,1,2,3,4]\nExplanation:\nnums       index     target\n1            0        [1]\n2            1        [1,2]\n3            2        [1,2,3]\n4            3        [1,2,3,4]\n0            0        [0,1,2,3,4]\nExample 3:\nInput: nums = [1], index = [0]\nOutput: [1]\nConstraints:\n1 <= nums.length, index.length <= 100\nnums.length == index.length\n0 <= nums[i] <= 100\n0 <= index[i] <= i\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\nclass Solution(object):\ndef createTargetArray(self, nums, index):\ntarget = []\nfor i,j in zip(nums,index):\ntarget.insert(j,i)\nreturn target\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\ntarget = []\nfor i in range(0,len(nums)):\ntarget.insert(index[i], nums[i])\nreturn target\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\ntarget = []\nfor i in range(len(nums)):\nnum = nums[i]\nidx = index[i]\ntarget.insert(idx, num)\nreturn target\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\ntarget =[]\nfor i in range (len(nums)):\ntarget.insert(index[i], nums[i])\nreturn target\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\nthe_list = []\nfor a, b in zip(index, nums):\nthe_list.insert(a, b)\nreturn the_list\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\nout = []\nfor i in range(len(nums)):\nout.insert(index[i], nums[i])\nreturn out\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\nl=[]\nfor i in range(len(nums)):\nl.insert(index[i],nums[i])\nreturn l\nclass Solution(object):\ndef createTargetArray(self, nums, index):\ntarget = []\nn = len(nums)\nfor i in range(n):\nif index[i] > n - 1:\ntarget.append(nums[i])\nelse:\ntarget = target[:index[i]] + [nums[i]] + target[index[i]:]\nreturn target\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\ntarget=[]\nfor i in range(len(nums)):\ntarget.insert(index[i],nums[i])\nreturn target\nclass Solution(object):\ndef createTargetArray(self, nums, index):\n\"\"\"\n:type nums: List[int]\n:type index: List[int]\n:rtype: List[int]\n\"\"\"\nres = []\nfor i in range(len(index)):\nres[index[i]:index[i]] = [nums[i]]\nreturn res\nclass Solution(object):\ndef createTargetArray(self, nums, index):\narr=[]\nfor i in range(len(index)):\narr.insert(index[i], nums[i])\nreturn arr\nclass Solution(object):\ndef createTargetArray(self, nums, index):\ntarget=[]\nfor i in range(0,len(nums)):\ntarget.insert(index[i],nums[i])\nreturn target\nclass Solution(object):\ndef createTargetArray(self, nums, index):\ntarget = []\nfor i in range(len(nums)):\npossible = len(target) - 1\nif index[i] > possible:\ntarget.append(nums[i])\nelse:\ntarget = target[:index[i]] + [nums[i]] + target[index[i]:]\nreturn target\n",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 1037
                },
                {
                        "real_dup": "2"
                }
        ]
]