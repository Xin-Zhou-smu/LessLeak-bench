[
        {
                "data_len": 8
        },
        [
                {
                        "id": "test_d2a_code_data_43066",
                        "content": "int find_info_tag(char *arg, int arg_size, const char *tag1, const char *info)\n{\nconst char *p;\nchar tag[128], *q;\np = info;\nif (*p == '?')\np++;\nfor(;;) {\nq = tag;\nwhile (*p != '\\0' && *p != '=' && *p != '&') {\nif ((q - tag) < sizeof(tag) - 1)\n*q++ = *p;\np++;\n}\n*q = '\\0';\nq = arg;\nif (*p == '=') {\np++;\nwhile (*p != '&' && *p != '\\0') {\nif ((q - arg) < arg_size - 1) {\nif (*p == '+')\n*q++ = ' ';\nelse\n*q++ = *p;\n}\np++;\n}\n*q = '\\0';\n}\nif (!strcmp(tag, tag1))\nreturn 1;\nif (*p != '&')\nbreak;\np++;\n}\nreturn 0;\n}",
                        "max_stars_repo_path": "https://github.com/libav/libav/blob/3ec394ea823c2a6e65a6abbdb2041ce1c66964f8/libavformat/utils.c/#L2829",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 274
                },
                {
                        "id": "pretrain_c_data_6556515",
                        "content": "<reponame>FXShu/123\n#include \"split.h\"\nint find_info_tag(char *arg, int arg_size, const char *tag1, const char *info) {\nconst char *p;\nchar tag[128], *q;\np = info;\nif (*p == '?')\np++;\nfor(;;) {\nq = tag;\nwhile (*p != '\\0' && *p != '=' && *p != '&') {\nif ((q - tag) < sizeof(tag) - 1)\n*q++ = *p;\np++;\n}\n*q = '\\0';\nq = arg;\nif (*p == '=') {\np++;\nwhile(*p != '&' && *p != '\\0') {\nif ((q - arg) < arg_size - 1) {\nif (*p == '+')\n*q++ = ' ';\nelse\n*q++ = *p;\n}\np++;\n}\n}\n*q = '\\0';\nif (!strcmp(tag, tag1))\nreturn 1;\nif (*p != '&')\nbreak;\np++;\n}\nreturn 0;\n}",
                        "max_stars_repo_path": "src/utils/split.c",
                        "max_stars_count": 6.0,
                        "max_stars_repo_name": "FXShu/123",
                        "__cluster__": 274
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_d2a_code_data_41628",
                        "content": "int find_info_tag(char *arg, int arg_size, const char *tag1, const char *info)\n{\nconst char *p;\nchar tag[128], *q;\np = info;\nif (*p == '?')\np++;\nfor(;;) {\nq = tag;\nwhile (*p != '\\0' && *p != '=' && *p != '&') {\nif ((q - tag) < sizeof(tag) - 1)\n*q++ = *p;\np++;\n}\n*q = '\\0';\nq = arg;\nif (*p == '=') {\np++;\nwhile (*p != '&' && *p != '\\0') {\nif ((q - arg) < arg_size - 1) {\nif (*p == '+')\n*q++ = ' ';\nelse\n*q++ = *p;\n}\np++;\n}\n*q = '\\0';\n}\nif (!strcmp(tag, tag1))\nreturn 1;\nif (*p != '&')\nbreak;\np++;\n}\nreturn 0;\n}",
                        "max_stars_repo_path": "https://github.com/libav/libav/blob/3ec394ea823c2a6e65a6abbdb2041ce1c66964f8/libavformat/utils.c/#L2829",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 274
                },
                {
                        "id": "pretrain_c_data_6556515",
                        "content": "<reponame>FXShu/123\n#include \"split.h\"\nint find_info_tag(char *arg, int arg_size, const char *tag1, const char *info) {\nconst char *p;\nchar tag[128], *q;\np = info;\nif (*p == '?')\np++;\nfor(;;) {\nq = tag;\nwhile (*p != '\\0' && *p != '=' && *p != '&') {\nif ((q - tag) < sizeof(tag) - 1)\n*q++ = *p;\np++;\n}\n*q = '\\0';\nq = arg;\nif (*p == '=') {\np++;\nwhile(*p != '&' && *p != '\\0') {\nif ((q - arg) < arg_size - 1) {\nif (*p == '+')\n*q++ = ' ';\nelse\n*q++ = *p;\n}\np++;\n}\n}\n*q = '\\0';\nif (!strcmp(tag, tag1))\nreturn 1;\nif (*p != '&')\nbreak;\np++;\n}\nreturn 0;\n}",
                        "max_stars_repo_path": "src/utils/split.c",
                        "max_stars_count": 6.0,
                        "max_stars_repo_name": "FXShu/123",
                        "__cluster__": 274
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_d2a_code_data_44987",
                        "content": "int find_info_tag(char *arg, int arg_size, const char *tag1, const char *info)\n{\nconst char *p;\nchar tag[128], *q;\np = info;\nif (*p == '?')\np++;\nfor(;;) {\nq = tag;\nwhile (*p != '\\0' && *p != '=' && *p != '&') {\nif ((q - tag) < sizeof(tag) - 1)\n*q++ = *p;\np++;\n}\n*q = '\\0';\nq = arg;\nif (*p == '=') {\np++;\nwhile (*p != '&' && *p != '\\0') {\nif ((q - arg) < arg_size - 1) {\nif (*p == '+')\n*q++ = ' ';\nelse\n*q++ = *p;\n}\np++;\n}\n*q = '\\0';\n}\nif (!strcmp(tag, tag1))\nreturn 1;\nif (*p != '&')\nbreak;\np++;\n}\nreturn 0;\n}",
                        "max_stars_repo_path": "https://github.com/libav/libav/blob/3ec394ea823c2a6e65a6abbdb2041ce1c66964f8/libavformat/utils.c/#L2829",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 274
                },
                {
                        "id": "pretrain_c_data_6556515",
                        "content": "<reponame>FXShu/123\n#include \"split.h\"\nint find_info_tag(char *arg, int arg_size, const char *tag1, const char *info) {\nconst char *p;\nchar tag[128], *q;\np = info;\nif (*p == '?')\np++;\nfor(;;) {\nq = tag;\nwhile (*p != '\\0' && *p != '=' && *p != '&') {\nif ((q - tag) < sizeof(tag) - 1)\n*q++ = *p;\np++;\n}\n*q = '\\0';\nq = arg;\nif (*p == '=') {\np++;\nwhile(*p != '&' && *p != '\\0') {\nif ((q - arg) < arg_size - 1) {\nif (*p == '+')\n*q++ = ' ';\nelse\n*q++ = *p;\n}\np++;\n}\n}\n*q = '\\0';\nif (!strcmp(tag, tag1))\nreturn 1;\nif (*p != '&')\nbreak;\np++;\n}\nreturn 0;\n}",
                        "max_stars_repo_path": "src/utils/split.c",
                        "max_stars_count": 6.0,
                        "max_stars_repo_name": "FXShu/123",
                        "__cluster__": 274
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_6618891",
                        "content": "static int CVE_2011_3973_VULN_decode_mb_i(AVSContext *h, int cbp_code) {\nGetBitContext *gb = &h->s.gb;\nint block, pred_mode_uv;\nuint8_t top[18];\nuint8_t *left = NULL;\nuint8_t *d;\nff_cavs_init_mb(h);\n/* get intra prediction modes from stream */\nfor(block=0;block<4;block++) {\nint nA,nB,predpred;\nint pos = ff_cavs_scan3x3[block];\nnA = h->pred_mode_Y[pos-1];\nnB = h->pred_mode_Y[pos-3];\npredpred = FFMIN(nA,nB);\nif(predpred == NOT_AVAIL) // if either is not available\npredpred = INTRA_L_LP;\nif(!get_bits1(gb)){\nint rem_mode= get_bits(gb, 2);\npredpred = rem_mode + (rem_mode >= predpred);\n}\nh->pred_mode_Y[pos] = predpred;\n}\npred_mode_uv = get_ue_golomb(gb);\nif(pred_mode_uv > 6) {\nav_log(h->s.avctx, AV_LOG_ERROR, \"illegal intra chroma pred mode\\n\");\nreturn -1;\n}\nff_cavs_modify_mb_i(h, &pred_mode_uv);\n/* get coded block pattern */\nif(h->pic_type == AV_PICTURE_TYPE_I)\ncbp_code = get_ue_golomb(gb);\nif(cbp_code > 63){\nav_log(h->s.avctx, AV_LOG_ERROR, \"illegal intra cbp\\n\");\nreturn -1;\n}\nh->cbp = cbp_tab[cbp_code][0];\nif(h->cbp && !h->qp_fixed)\nh->qp = (h->qp + get_se_golomb(gb)) & 63; //qp_delta\n/* luma intra prediction interleaved with residual decode/transform/add */\nfor(block=0;block<4;block++) {\nd = h->cy + h->luma_scan[block];\nff_cavs_load_intra_pred_luma(h, top, &left, block);\nh->intra_pred_l[h->pred_mode_Y[ff_cavs_scan3x3[block]]]\n(d, top, left, h->l_stride);\nif(h->cbp & (1<<block))\ndecode_residual_block(h,gb,ff_cavs_intra_dec,1,h->qp,d,h->l_stride);\n}\n/* chroma intra prediction */\nff_cavs_load_intra_pred_chroma(h);\nh->intra_pred_c[pred_mode_uv](h->cu, &h->top_border_u[h->mbx*10],\nh->left_border_u, h->c_stride);\nh->intra_pred_c[pred_mode_uv](h->cv, &h->top_border_v[h->mbx*10],\nh->left_border_v, h->c_stride);\ndecode_residual_chroma(h);\nff_cavs_filter(h,I_8X8);\nset_mv_intra(h);\nreturn 0;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2011_3973_VULN_decode_mb_i.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 223
                },
                {
                        "id": "test_d2a_code_data_41577",
                        "content": "static int decode_mb_i(AVSContext *h, int cbp_code) {\nGetBitContext *gb = &h->s.gb;\nint block, pred_mode_uv;\nuint8_t top[18];\nuint8_t *left = NULL;\nuint8_t *d;\nff_cavs_init_mb(h);\nfor(block=0;block<4;block++) {\nint nA,nB,predpred;\nint pos = ff_cavs_scan3x3[block];\nnA = h->pred_mode_Y[pos-1];\nnB = h->pred_mode_Y[pos-3];\npredpred = FFMIN(nA,nB);\nif(predpred == NOT_AVAIL)\npredpred = INTRA_L_LP;\nif(!get_bits1(gb)){\nint rem_mode= get_bits(gb, 2);\npredpred = rem_mode + (rem_mode >= predpred);\n}\nh->pred_mode_Y[pos] = predpred;\n}\npred_mode_uv = get_ue_golomb(gb);\nif(pred_mode_uv > 6) {\nav_log(h->s.avctx, AV_LOG_ERROR, \"illegal intra chroma pred mode\\n\");\nreturn -1;\n}\nff_cavs_modify_mb_i(h, &pred_mode_uv);\nif(h->pic_type == FF_I_TYPE)\ncbp_code = get_ue_golomb(gb);\nif(cbp_code > 63){\nav_log(h->s.avctx, AV_LOG_ERROR, \"illegal intra cbp\\n\");\nreturn -1;\n}\nh->cbp = cbp_tab[cbp_code][0];\nif(h->cbp && !h->qp_fixed)\nh->qp = (h->qp + get_se_golomb(gb)) & 63;\nfor(block=0;block<4;block++) {\nd = h->cy + h->luma_scan[block];\nff_cavs_load_intra_pred_luma(h, top, &left, block);\nh->intra_pred_l[h->pred_mode_Y[ff_cavs_scan3x3[block]]]\n(d, top, left, h->l_stride);\nif(h->cbp & (1<<block))\ndecode_residual_block(h,gb,ff_cavs_intra_dec,1,h->qp,d,h->l_stride);\n}\nff_cavs_load_intra_pred_chroma(h);\nh->intra_pred_c[pred_mode_uv](h->cu, &h->top_border_u[h->mbx*10],\nh->left_border_u, h->c_stride);\nh->intra_pred_c[pred_mode_uv](h->cv, &h->top_border_v[h->mbx*10],\nh->left_border_v, h->c_stride);\ndecode_residual_chroma(h);\nff_cavs_filter(h,I_8X8);\nset_mv_intra(h);\nreturn 0;\n}",
                        "max_stars_repo_path": "https://github.com/libav/libav/blob/3ec394ea823c2a6e65a6abbdb2041ce1c66964f8/libavcodec/cavsdec.c/#L204",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 223
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "test_d2a_code_data_43439",
                        "content": "static int read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd)\n{\nALSSpecificConfig *sconf = &ctx->sconf;\nAVCodecContext *avctx    = ctx->avctx;\nGetBitContext *gb        = &ctx->gb;\nunsigned int k;\nunsigned int s[8];\nunsigned int sx[8];\nunsigned int sub_blocks, log2_sub_blocks, sb_length;\nunsigned int start      = 0;\nunsigned int opt_order;\nint          sb;\nint32_t      *quant_cof = bd->quant_cof;\nint32_t      *current_res;\n*bd->const_block = 0;\n*bd->opt_order  = 1;\nbd->js_blocks   = get_bits1(gb);\nopt_order       = *bd->opt_order;\nif (!sconf->bgmc && !sconf->sb_part) {\nlog2_sub_blocks = 0;\n} else {\nif (sconf->bgmc && sconf->sb_part)\nlog2_sub_blocks = get_bits(gb, 2);\nelse\nlog2_sub_blocks = 2 * get_bits1(gb);\n}\nsub_blocks = 1 << log2_sub_blocks;\nif (bd->block_length & (sub_blocks - 1)) {\nav_log(avctx, AV_LOG_WARNING,\n\"Block length is not evenly divisible by the number of subblocks.\\n\");\nreturn -1;\n}\nsb_length = bd->block_length >> log2_sub_blocks;\nif (sconf->bgmc) {\ns[0] = get_bits(gb, 8 + (sconf->resolution > 1));\nfor (k = 1; k < sub_blocks; k++)\ns[k] = s[k - 1] + decode_rice(gb, 2);\nfor (k = 0; k < sub_blocks; k++) {\nsx[k]   = s[k] & 0x0F;\ns [k] >>= 4;\n}\n} else {\ns[0] = get_bits(gb, 4 + (sconf->resolution > 1));\nfor (k = 1; k < sub_blocks; k++)\ns[k] = s[k - 1] + decode_rice(gb, 0);\n}\nif (get_bits1(gb))\n*bd->shift_lsbs = get_bits(gb, 4) + 1;\n*bd->store_prev_samples = (bd->js_blocks && bd->raw_other) || *bd->shift_lsbs;\nif (!sconf->rlslms) {\nif (sconf->adapt_order) {\nint opt_order_length = av_ceil_log2(av_clip((bd->block_length >> 3) - 1,\n2, sconf->max_order + 1));\n*bd->opt_order       = get_bits(gb, opt_order_length);\n} else {\n*bd->opt_order = sconf->max_order;\n}\nopt_order = *bd->opt_order;\nif (opt_order) {\nint add_base;\nif (sconf->coef_table == 3) {\nadd_base = 0x7F;\nquant_cof[0] = 32 * parcor_scaled_values[get_bits(gb, 7)];\nif (opt_order > 1)\nquant_cof[1] = -32 * parcor_scaled_values[get_bits(gb, 7)];\nfor (k = 2; k < opt_order; k++)\nquant_cof[k] = get_bits(gb, 7);\n} else {\nint k_max;\nadd_base = 1;\nk_max = FFMIN(opt_order, 20);\nfor (k = 0; k < k_max; k++) {\nint rice_param = parcor_rice_table[sconf->coef_table][k][1];\nint offset     = parcor_rice_table[sconf->coef_table][k][0];\nquant_cof[k] = decode_rice(gb, rice_param) + offset;\n}\nk_max = FFMIN(opt_order, 127);\nfor (; k < k_max; k++)\nquant_cof[k] = decode_rice(gb, 2) + (k & 1);\nfor (; k < opt_order; k++)\nquant_cof[k] = decode_rice(gb, 1);\nquant_cof[0] = 32 * parcor_scaled_values[quant_cof[0] + 64];\nif (opt_order > 1)\nquant_cof[1] = -32 * parcor_scaled_values[quant_cof[1] + 64];\n}\nfor (k = 2; k < opt_order; k++)\nquant_cof[k] = (quant_cof[k] << 14) + (add_base << 13);\n}\n}\nif (sconf->long_term_prediction) {\n*bd->use_ltp = get_bits1(gb);\nif (*bd->use_ltp) {\nint r, c;\nbd->ltp_gain[0]   = decode_rice(gb, 1) << 3;\nbd->ltp_gain[1]   = decode_rice(gb, 2) << 3;\nr                 = get_unary(gb, 0, 4);\nc                 = get_bits(gb, 2);\nbd->ltp_gain[2]   = ltp_gain_values[r][c];\nbd->ltp_gain[3]   = decode_rice(gb, 2) << 3;\nbd->ltp_gain[4]   = decode_rice(gb, 1) << 3;\n*bd->ltp_lag      = get_bits(gb, ctx->ltp_lag_length);\n*bd->ltp_lag     += FFMAX(4, opt_order + 1);\n}\n}\nif (bd->ra_block) {\nif (opt_order)\nbd->raw_samples[0] = decode_rice(gb, avctx->bits_per_raw_sample - 4);\nif (opt_order > 1)\nbd->raw_samples[1] = decode_rice(gb, FFMIN(s[0] + 3, ctx->s_max));\nif (opt_order > 2)\nbd->raw_samples[2] = decode_rice(gb, FFMIN(s[0] + 1, ctx->s_max));\nstart = FFMIN(opt_order, 3);\n}\nif (sconf->bgmc) {\nint          delta[8];\nunsigned int k    [8];\nunsigned int b = av_clip((av_ceil_log2(bd->block_length) - 3) >> 1, 0, 5);\nunsigned int i = start;\nunsigned int high;\nunsigned int low;\nunsigned int value;\nff_bgmc_decode_init(gb, &high, &low, &value);\ncurrent_res = bd->raw_samples + start;\nfor (sb = 0; sb < sub_blocks; sb++, i = 0) {\nk    [sb] = s[sb] > b ? s[sb] - b : 0;\ndelta[sb] = 5 - s[sb] + k[sb];\nff_bgmc_decode(gb, sb_length, current_res,\ndelta[sb], sx[sb], &high, &low, &value, ctx->bgmc_lut, ctx->bgmc_lut_status);\ncurrent_res += sb_length;\n}\nff_bgmc_decode_end(gb);\ni = start;\ncurrent_res = bd->raw_samples + start;\nfor (sb = 0; sb < sub_blocks; sb++, i = 0) {\nunsigned int cur_tail_code = tail_code[sx[sb]][delta[sb]];\nunsigned int cur_k         = k[sb];\nunsigned int cur_s         = s[sb];\nfor (; i < sb_length; i++) {\nint32_t res = *current_res;\nif (res == cur_tail_code) {\nunsigned int max_msb =   (2 + (sx[sb] > 2) + (sx[sb] > 10))\n<< (5 - delta[sb]);\nres = decode_rice(gb, cur_s);\nif (res >= 0) {\nres += (max_msb    ) << cur_k;\n} else {\nres -= (max_msb - 1) << cur_k;\n}\n} else {\nif (res > cur_tail_code)\nres--;\nif (res & 1)\nres = -res;\nres >>= 1;\nif (cur_k) {\nres <<= cur_k;\nres  |= get_bits_long(gb, cur_k);\n}\n}\n*current_res++ = res;\n}\n}\n} else {\ncurrent_res = bd->raw_samples + start;\nfor (sb = 0; sb < sub_blocks; sb++, start = 0)\nfor (; start < sb_length; start++)\n*current_res++ = decode_rice(gb, s[sb]);\n}\nif (!sconf->mc_coding || ctx->js_switch)\nalign_get_bits(gb);\nreturn 0;\n}",
                        "max_stars_repo_path": "https://github.com/libav/libav/blob/3cf8db9447a6c77550033acea84e30be2af7ad2c/libavcodec/alsdec.c/#L662",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 2085
                },
                {
                        "id": "pretrain_c_data_3607250",
                        "content": "<reponame>kppw99/enVAS\nstatic int CVE_2012_2790_VULN_read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd)\n{\nALSSpecificConfig *sconf = &ctx->sconf;\nAVCodecContext *avctx    = ctx->avctx;\nGetBitContext *gb        = &ctx->gb;\nunsigned int k;\nunsigned int s[8];\nunsigned int sx[8];\nunsigned int sub_blocks, log2_sub_blocks, sb_length;\nunsigned int start      = 0;\nunsigned int opt_order;\nint          sb;\nint32_t      *quant_cof = bd->quant_cof;\nint32_t      *current_res;\n// ensure variable block decoding by reusing this field\n*bd->const_block = 0;\n*bd->opt_order  = 1;\nbd->js_blocks   = get_bits1(gb);\nopt_order       = *bd->opt_order;\n// determine the number of subblocks for entropy decoding\nif (!sconf->bgmc && !sconf->sb_part) {\nlog2_sub_blocks = 0;\n} else {\nif (sconf->bgmc && sconf->sb_part)\nlog2_sub_blocks = get_bits(gb, 2);\nelse\nlog2_sub_blocks = 2 * get_bits1(gb);\n}\nsub_blocks = 1 << log2_sub_blocks;\n// do not continue in case of a damaged stream since\n// block_length must be evenly divisible by sub_blocks\nif (bd->block_length & (sub_blocks - 1)) {\nav_log(avctx, AV_LOG_WARNING,\n\"Block length is not evenly divisible by the number of subblocks.\\n\");\nreturn -1;\n}\nsb_length = bd->block_length >> log2_sub_blocks;\nif (sconf->bgmc) {\ns[0] = get_bits(gb, 8 + (sconf->resolution > 1));\nfor (k = 1; k < sub_blocks; k++)\ns[k] = s[k - 1] + decode_rice(gb, 2);\nfor (k = 0; k < sub_blocks; k++) {\nsx[k]   = s[k] & 0x0F;\ns [k] >>= 4;\n}\n} else {\ns[0] = get_bits(gb, 4 + (sconf->resolution > 1));\nfor (k = 1; k < sub_blocks; k++)\ns[k] = s[k - 1] + decode_rice(gb, 0);\n}\nif (get_bits1(gb))\n*bd->shift_lsbs = get_bits(gb, 4) + 1;\n*bd->store_prev_samples = (bd->js_blocks && bd->raw_other) || *bd->shift_lsbs;\nif (!sconf->rlslms) {\nif (sconf->adapt_order) {\nint opt_order_length = av_ceil_log2(av_clip((bd->block_length >> 3) - 1,\n2, sconf->max_order + 1));\n*bd->opt_order       = get_bits(gb, opt_order_length);\n} else {\n*bd->opt_order = sconf->max_order;\n}\nopt_order = *bd->opt_order;\nif (opt_order) {\nint add_base;\nif (sconf->coef_table == 3) {\nadd_base = 0x7F;\n// read coefficient 0\nquant_cof[0] = 32 * parcor_scaled_values[get_bits(gb, 7)];\n// read coefficient 1\nif (opt_order > 1)\nquant_cof[1] = -32 * parcor_scaled_values[get_bits(gb, 7)];\n// read coefficients 2 to opt_order\nfor (k = 2; k < opt_order; k++)\nquant_cof[k] = get_bits(gb, 7);\n} else {\nint k_max;\nadd_base = 1;\n// read coefficient 0 to 19\nk_max = FFMIN(opt_order, 20);\nfor (k = 0; k < k_max; k++) {\nint rice_param = parcor_rice_table[sconf->coef_table][k][1];\nint offset     = parcor_rice_table[sconf->coef_table][k][0];\nquant_cof[k] = decode_rice(gb, rice_param) + offset;\n}\n// read coefficients 20 to 126\nk_max = FFMIN(opt_order, 127);\nfor (; k < k_max; k++)\nquant_cof[k] = decode_rice(gb, 2) + (k & 1);\n// read coefficients 127 to opt_order\nfor (; k < opt_order; k++)\nquant_cof[k] = decode_rice(gb, 1);\nquant_cof[0] = 32 * parcor_scaled_values[quant_cof[0] + 64];\nif (opt_order > 1)\nquant_cof[1] = -32 * parcor_scaled_values[quant_cof[1] + 64];\n}\nfor (k = 2; k < opt_order; k++)\nquant_cof[k] = (quant_cof[k] << 14) + (add_base << 13);\n}\n}\n// read LTP gain and lag values\nif (sconf->long_term_prediction) {\n*bd->use_ltp = get_bits1(gb);\nif (*bd->use_ltp) {\nint r, c;\nbd->ltp_gain[0]   = decode_rice(gb, 1) << 3;\nbd->ltp_gain[1]   = decode_rice(gb, 2) << 3;\nr                 = get_unary(gb, 0, 4);\nc                 = get_bits(gb, 2);\nbd->ltp_gain[2]   = ltp_gain_values[r][c];\nbd->ltp_gain[3]   = decode_rice(gb, 2) << 3;\nbd->ltp_gain[4]   = decode_rice(gb, 1) << 3;\n*bd->ltp_lag      = get_bits(gb, ctx->ltp_lag_length);\n*bd->ltp_lag     += FFMAX(4, opt_order + 1);\n}\n}\n// read first value and residuals in case of a random access block\nif (bd->ra_block) {\nif (opt_order)\nbd->raw_samples[0] = decode_rice(gb, avctx->bits_per_raw_sample - 4);\nif (opt_order > 1)\nbd->raw_samples[1] = decode_rice(gb, FFMIN(s[0] + 3, ctx->s_max));\nif (opt_order > 2)\nbd->raw_samples[2] = decode_rice(gb, FFMIN(s[0] + 1, ctx->s_max));\nstart = FFMIN(opt_order, 3);\n}\n// read all residuals\nif (sconf->bgmc) {\nint          delta[8];\nunsigned int k    [8];\nunsigned int b = av_clip((av_ceil_log2(bd->block_length) - 3) >> 1, 0, 5);\nunsigned int i = start;\n// read most significant bits\nunsigned int high;\nunsigned int low;\nunsigned int value;\nff_bgmc_decode_init(gb, &high, &low, &value);\ncurrent_res = bd->raw_samples + start;\nfor (sb = 0; sb < sub_blocks; sb++, i = 0) {\nk    [sb] = s[sb] > b ? s[sb] - b : 0;\ndelta[sb] = 5 - s[sb] + k[sb];\nff_bgmc_decode(gb, sb_length, current_res,\ndelta[sb], sx[sb], &high, &low, &value, ctx->bgmc_lut, ctx->bgmc_lut_status);\ncurrent_res += sb_length;\n}\nff_bgmc_decode_end(gb);\n// read least significant bits and tails\ni = start;\ncurrent_res = bd->raw_samples + start;\nfor (sb = 0; sb < sub_blocks; sb++, i = 0) {\nunsigned int cur_tail_code = tail_code[sx[sb]][delta[sb]];\nunsigned int cur_k         = k[sb];\nunsigned int cur_s         = s[sb];\nfor (; i < sb_length; i++) {\nint32_t res = *current_res;\nif (res == cur_tail_code) {\nunsigned int max_msb =   (2 + (sx[sb] > 2) + (sx[sb] > 10))\n<< (5 - delta[sb]);\nres = decode_rice(gb, cur_s);\nif (res >= 0) {\nres += (max_msb    ) << cur_k;\n} else {\nres -= (max_msb - 1) << cur_k;\n}\n} else {\nif (res > cur_tail_code)\nres--;\nif (res & 1)\nres = -res;\nres >>= 1;\nif (cur_k) {\nres <<= cur_k;\nres  |= get_bits_long(gb, cur_k);\n}\n}\n*current_res++ = res;\n}\n}\n} else {\ncurrent_res = bd->raw_samples + start;\nfor (sb = 0; sb < sub_blocks; sb++, start = 0)\nfor (; start < sb_length; start++)\n*current_res++ = decode_rice(gb, s[sb]);\n}\nif (!sconf->mc_coding || ctx->js_switch)\nalign_get_bits(gb);\nreturn 0;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2012_2790_VULN_read_var_block_data.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 2085
                },
                {
                        "real_dup": "3"
                }
        ],


        [
                {
                        "id": "test_d2a_code_data_44204",
                        "content": "int vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\nconst uint8_t *buf, int buf_size)\n{\nvp56_context_t *s = avctx->priv_data;\nAVFrame *const p = s->framep[VP56_FRAME_CURRENT];\nint is_alpha, alpha_offset;\nif (s->has_alpha) {\nalpha_offset = bytestream_get_be24(&buf);\nbuf_size -= 3;\n}\nfor (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) {\nint mb_row, mb_col, mb_row_flip, mb_offset = 0;\nint block, y, uv, stride_y, stride_uv;\nint golden_frame = 0;\nint res;\ns->modelp = &s->models[is_alpha];\nres = s->parse_header(s, buf, buf_size, &golden_frame);\nif (!res)\nreturn -1;\nif (!is_alpha) {\np->reference = 1;\nif (avctx->get_buffer(avctx, p) < 0) {\nav_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\nreturn -1;\n}\nif (res == 2)\nif (vp56_size_changed(avctx)) {\navctx->release_buffer(avctx, p);\nreturn -1;\n}\n}\nif (p->key_frame) {\np->pict_type = FF_I_TYPE;\ns->default_models_init(s);\nfor (block=0; block<s->mb_height*s->mb_width; block++)\ns->macroblocks[block].type = VP56_MB_INTRA;\n} else {\np->pict_type = FF_P_TYPE;\nvp56_parse_mb_type_models(s);\ns->parse_vector_models(s);\ns->mb_type = VP56_MB_INTER_NOVEC_PF;\n}\ns->parse_coeff_models(s);\nmemset(s->prev_dc, 0, sizeof(s->prev_dc));\ns->prev_dc[1][VP56_FRAME_CURRENT] = 128;\ns->prev_dc[2][VP56_FRAME_CURRENT] = 128;\nfor (block=0; block < 4*s->mb_width+6; block++) {\ns->above_blocks[block].ref_frame = -1;\ns->above_blocks[block].dc_coeff = 0;\ns->above_blocks[block].not_null_dc = 0;\n}\ns->above_blocks[2*s->mb_width + 2].ref_frame = 0;\ns->above_blocks[3*s->mb_width + 4].ref_frame = 0;\nstride_y  = p->linesize[0];\nstride_uv = p->linesize[1];\nif (s->flip < 0)\nmb_offset = 7;\nfor (mb_row=0; mb_row<s->mb_height; mb_row++) {\nif (s->flip < 0)\nmb_row_flip = s->mb_height - mb_row - 1;\nelse\nmb_row_flip = mb_row;\nfor (block=0; block<4; block++) {\ns->left_block[block].ref_frame = -1;\ns->left_block[block].dc_coeff = 0;\ns->left_block[block].not_null_dc = 0;\n}\nmemset(s->coeff_ctx, 0, sizeof(s->coeff_ctx));\nmemset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));\ns->above_block_idx[0] = 1;\ns->above_block_idx[1] = 2;\ns->above_block_idx[2] = 1;\ns->above_block_idx[3] = 2;\ns->above_block_idx[4] = 2*s->mb_width + 2 + 1;\ns->above_block_idx[5] = 3*s->mb_width + 4 + 1;\ns->block_offset[s->frbi] = (mb_row_flip*16 + mb_offset) * stride_y;\ns->block_offset[s->srbi] = s->block_offset[s->frbi] + 8*stride_y;\ns->block_offset[1] = s->block_offset[0] + 8;\ns->block_offset[3] = s->block_offset[2] + 8;\ns->block_offset[4] = (mb_row_flip*8 + mb_offset) * stride_uv;\ns->block_offset[5] = s->block_offset[4];\nfor (mb_col=0; mb_col<s->mb_width; mb_col++) {\nvp56_decode_mb(s, mb_row, mb_col, is_alpha);\nfor (y=0; y<4; y++) {\ns->above_block_idx[y] += 2;\ns->block_offset[y] += 16;\n}\nfor (uv=4; uv<6; uv++) {\ns->above_block_idx[uv] += 1;\ns->block_offset[uv] += 8;\n}\n}\n}\nif (p->key_frame || golden_frame) {\nif (s->framep[VP56_FRAME_GOLDEN]->data[0] &&\ns->framep[VP56_FRAME_GOLDEN] != s->framep[VP56_FRAME_GOLDEN2])\navctx->release_buffer(avctx, s->framep[VP56_FRAME_GOLDEN]);\ns->framep[VP56_FRAME_GOLDEN] = p;\n}\nif (s->has_alpha) {\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_GOLDEN],\ns->framep[VP56_FRAME_GOLDEN2]);\nbuf += alpha_offset;\nbuf_size -= alpha_offset;\n}\n}\nif (s->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN] ||\ns->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN2]) {\nif (s->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN] &&\ns->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN2])\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],\ns->framep[VP56_FRAME_UNUSED]);\nelse\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],\ns->framep[VP56_FRAME_UNUSED2]);\n} else if (s->framep[VP56_FRAME_PREVIOUS]->data[0])\navctx->release_buffer(avctx, s->framep[VP56_FRAME_PREVIOUS]);\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_CURRENT],\ns->framep[VP56_FRAME_PREVIOUS]);\n*(AVFrame*)data = *p;\n*data_size = sizeof(AVFrame);\nreturn buf_size;\n}",
                        "max_stars_repo_path": "https://github.com/libav/libav/blob/3ec394ea823c2a6e65a6abbdb2041ce1c66964f8/libavcodec/vp56.c/#L621",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 452
                },
                {
                        "id": "pretrain_c_data_695276",
                        "content": "<filename>dataset/source/NVD/CVE_2012_2783_PATCHED_ff_vp56_decode_frame.c<gh_stars>0\nint CVE_2012_2783_PATCHED_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\nAVPacket *avpkt)\n{\nconst uint8_t *buf = avpkt->data;\nVP56Context *s = avctx->priv_data;\nAVFrame *const p = s->framep[VP56_FRAME_CURRENT];\nint remaining_buf_size = avpkt->size;\nint is_alpha, av_uninit(alpha_offset);\nif (s->has_alpha) {\nif (remaining_buf_size < 3)\nreturn -1;\nalpha_offset = bytestream_get_be24(&buf);\nremaining_buf_size -= 3;\nif (remaining_buf_size < alpha_offset)\nreturn -1;\n}\nfor (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) {\nint mb_row, mb_col, mb_row_flip, mb_offset = 0;\nint block, y, uv, stride_y, stride_uv;\nint golden_frame = 0;\nint res;\ns->modelp = &s->models[is_alpha];\nres = s->parse_header(s, buf, remaining_buf_size, &golden_frame);\nif (!res)\nreturn -1;\nif (res == 2) {\nint i;\nfor (i = 0; i < 4; i++) {\nif (s->frames[i].data[0])\navctx->release_buffer(avctx, &s->frames[i]);\n}\nif (is_alpha) {\navcodec_set_dimensions(avctx, 0, 0);\nreturn -1;\n}\n}\nif (!is_alpha) {\np->reference = 1;\nif (avctx->get_buffer(avctx, p) < 0) {\nav_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\nreturn -1;\n}\nif (res == 2)\nif (vp56_size_changed(avctx)) {\navctx->release_buffer(avctx, p);\nreturn -1;\n}\n}\nif (p->key_frame) {\np->pict_type = AV_PICTURE_TYPE_I;\ns->default_models_init(s);\nfor (block=0; block<s->mb_height*s->mb_width; block++)\ns->macroblocks[block].type = VP56_MB_INTRA;\n} else {\np->pict_type = AV_PICTURE_TYPE_P;\nvp56_parse_mb_type_models(s);\ns->parse_vector_models(s);\ns->mb_type = VP56_MB_INTER_NOVEC_PF;\n}\nif (s->parse_coeff_models(s))\ngoto next;\nmemset(s->prev_dc, 0, sizeof(s->prev_dc));\ns->prev_dc[1][VP56_FRAME_CURRENT] = 128;\ns->prev_dc[2][VP56_FRAME_CURRENT] = 128;\nfor (block=0; block < 4*s->mb_width+6; block++) {\ns->above_blocks[block].ref_frame = VP56_FRAME_NONE;\ns->above_blocks[block].dc_coeff = 0;\ns->above_blocks[block].not_null_dc = 0;\n}\ns->above_blocks[2*s->mb_width + 2].ref_frame = VP56_FRAME_CURRENT;\ns->above_blocks[3*s->mb_width + 4].ref_frame = VP56_FRAME_CURRENT;\nstride_y  = p->linesize[0];\nstride_uv = p->linesize[1];\nif (s->flip < 0)\nmb_offset = 7;\n/* main macroblocks loop */\nfor (mb_row=0; mb_row<s->mb_height; mb_row++) {\nif (s->flip < 0)\nmb_row_flip = s->mb_height - mb_row - 1;\nelse\nmb_row_flip = mb_row;\nfor (block=0; block<4; block++) {\ns->left_block[block].ref_frame = VP56_FRAME_NONE;\ns->left_block[block].dc_coeff = 0;\ns->left_block[block].not_null_dc = 0;\n}\nmemset(s->coeff_ctx, 0, sizeof(s->coeff_ctx));\nmemset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));\ns->above_block_idx[0] = 1;\ns->above_block_idx[1] = 2;\ns->above_block_idx[2] = 1;\ns->above_block_idx[3] = 2;\ns->above_block_idx[4] = 2*s->mb_width + 2 + 1;\ns->above_block_idx[5] = 3*s->mb_width + 4 + 1;\ns->block_offset[s->frbi] = (mb_row_flip*16 + mb_offset) * stride_y;\ns->block_offset[s->srbi] = s->block_offset[s->frbi] + 8*stride_y;\ns->block_offset[1] = s->block_offset[0] + 8;\ns->block_offset[3] = s->block_offset[2] + 8;\ns->block_offset[4] = (mb_row_flip*8 + mb_offset) * stride_uv;\ns->block_offset[5] = s->block_offset[4];\nfor (mb_col=0; mb_col<s->mb_width; mb_col++) {\nvp56_decode_mb(s, mb_row, mb_col, is_alpha);\nfor (y=0; y<4; y++) {\ns->above_block_idx[y] += 2;\ns->block_offset[y] += 16;\n}\nfor (uv=4; uv<6; uv++) {\ns->above_block_idx[uv] += 1;\ns->block_offset[uv] += 8;\n}\n}\n}\nnext:\nif (p->key_frame || golden_frame) {\nif (s->framep[VP56_FRAME_GOLDEN]->data[0] && s->framep[VP56_FRAME_GOLDEN] != p &&\ns->framep[VP56_FRAME_GOLDEN] != s->framep[VP56_FRAME_GOLDEN2])\navctx->release_buffer(avctx, s->framep[VP56_FRAME_GOLDEN]);\ns->framep[VP56_FRAME_GOLDEN] = p;\n}\nif (s->has_alpha) {\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_GOLDEN],\ns->framep[VP56_FRAME_GOLDEN2]);\nbuf += alpha_offset;\nremaining_buf_size -= alpha_offset;\n}\n}\nif (s->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN] ||\ns->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN2]) {\nif (s->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN] &&\ns->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN2])\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],\ns->framep[VP56_FRAME_UNUSED]);\nelse\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],\ns->framep[VP56_FRAME_UNUSED2]);\n} else if (s->framep[VP56_FRAME_PREVIOUS]->data[0])\navctx->release_buffer(avctx, s->framep[VP56_FRAME_PREVIOUS]);\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_CURRENT],\ns->framep[VP56_FRAME_PREVIOUS]);\np->qstride = 0;\np->qscale_table = s->qscale_table;\np->qscale_type = FF_QSCALE_TYPE_VP56;\n*(AVFrame*)data = *p;\n*data_size = sizeof(AVFrame);\nreturn avpkt->size;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2012_2783_PATCHED_ff_vp56_decode_frame.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 452
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "test_d2a_code_data_41806",
                        "content": "int vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\nconst uint8_t *buf, int buf_size)\n{\nvp56_context_t *s = avctx->priv_data;\nAVFrame *const p = s->framep[VP56_FRAME_CURRENT];\nint is_alpha, alpha_offset;\nif (s->has_alpha) {\nalpha_offset = bytestream_get_be24(&buf);\nbuf_size -= 3;\n}\nfor (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) {\nint mb_row, mb_col, mb_row_flip, mb_offset = 0;\nint block, y, uv, stride_y, stride_uv;\nint golden_frame = 0;\nint res;\ns->modelp = &s->models[is_alpha];\nres = s->parse_header(s, buf, buf_size, &golden_frame);\nif (!res)\nreturn -1;\nif (!is_alpha) {\np->reference = 1;\nif (avctx->get_buffer(avctx, p) < 0) {\nav_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\nreturn -1;\n}\nif (res == 2)\nif (vp56_size_changed(avctx)) {\navctx->release_buffer(avctx, p);\nreturn -1;\n}\n}\nif (p->key_frame) {\np->pict_type = FF_I_TYPE;\ns->default_models_init(s);\nfor (block=0; block<s->mb_height*s->mb_width; block++)\ns->macroblocks[block].type = VP56_MB_INTRA;\n} else {\np->pict_type = FF_P_TYPE;\nvp56_parse_mb_type_models(s);\ns->parse_vector_models(s);\ns->mb_type = VP56_MB_INTER_NOVEC_PF;\n}\ns->parse_coeff_models(s);\nmemset(s->prev_dc, 0, sizeof(s->prev_dc));\ns->prev_dc[1][VP56_FRAME_CURRENT] = 128;\ns->prev_dc[2][VP56_FRAME_CURRENT] = 128;\nfor (block=0; block < 4*s->mb_width+6; block++) {\ns->above_blocks[block].ref_frame = -1;\ns->above_blocks[block].dc_coeff = 0;\ns->above_blocks[block].not_null_dc = 0;\n}\ns->above_blocks[2*s->mb_width + 2].ref_frame = 0;\ns->above_blocks[3*s->mb_width + 4].ref_frame = 0;\nstride_y  = p->linesize[0];\nstride_uv = p->linesize[1];\nif (s->flip < 0)\nmb_offset = 7;\nfor (mb_row=0; mb_row<s->mb_height; mb_row++) {\nif (s->flip < 0)\nmb_row_flip = s->mb_height - mb_row - 1;\nelse\nmb_row_flip = mb_row;\nfor (block=0; block<4; block++) {\ns->left_block[block].ref_frame = -1;\ns->left_block[block].dc_coeff = 0;\ns->left_block[block].not_null_dc = 0;\n}\nmemset(s->coeff_ctx, 0, sizeof(s->coeff_ctx));\nmemset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));\ns->above_block_idx[0] = 1;\ns->above_block_idx[1] = 2;\ns->above_block_idx[2] = 1;\ns->above_block_idx[3] = 2;\ns->above_block_idx[4] = 2*s->mb_width + 2 + 1;\ns->above_block_idx[5] = 3*s->mb_width + 4 + 1;\ns->block_offset[s->frbi] = (mb_row_flip*16 + mb_offset) * stride_y;\ns->block_offset[s->srbi] = s->block_offset[s->frbi] + 8*stride_y;\ns->block_offset[1] = s->block_offset[0] + 8;\ns->block_offset[3] = s->block_offset[2] + 8;\ns->block_offset[4] = (mb_row_flip*8 + mb_offset) * stride_uv;\ns->block_offset[5] = s->block_offset[4];\nfor (mb_col=0; mb_col<s->mb_width; mb_col++) {\nvp56_decode_mb(s, mb_row, mb_col, is_alpha);\nfor (y=0; y<4; y++) {\ns->above_block_idx[y] += 2;\ns->block_offset[y] += 16;\n}\nfor (uv=4; uv<6; uv++) {\ns->above_block_idx[uv] += 1;\ns->block_offset[uv] += 8;\n}\n}\n}\nif (p->key_frame || golden_frame) {\nif (s->framep[VP56_FRAME_GOLDEN]->data[0] &&\ns->framep[VP56_FRAME_GOLDEN] != s->framep[VP56_FRAME_GOLDEN2])\navctx->release_buffer(avctx, s->framep[VP56_FRAME_GOLDEN]);\ns->framep[VP56_FRAME_GOLDEN] = p;\n}\nif (s->has_alpha) {\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_GOLDEN],\ns->framep[VP56_FRAME_GOLDEN2]);\nbuf += alpha_offset;\nbuf_size -= alpha_offset;\n}\n}\nif (s->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN] ||\ns->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN2]) {\nif (s->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN] &&\ns->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN2])\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],\ns->framep[VP56_FRAME_UNUSED]);\nelse\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],\ns->framep[VP56_FRAME_UNUSED2]);\n} else if (s->framep[VP56_FRAME_PREVIOUS]->data[0])\navctx->release_buffer(avctx, s->framep[VP56_FRAME_PREVIOUS]);\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_CURRENT],\ns->framep[VP56_FRAME_PREVIOUS]);\n*(AVFrame*)data = *p;\n*data_size = sizeof(AVFrame);\nreturn buf_size;\n}",
                        "max_stars_repo_path": "https://github.com/libav/libav/blob/3ec394ea823c2a6e65a6abbdb2041ce1c66964f8/libavcodec/vp56.c/#L622",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 452
                },
                {
                        "id": "pretrain_c_data_695276",
                        "content": "<filename>dataset/source/NVD/CVE_2012_2783_PATCHED_ff_vp56_decode_frame.c<gh_stars>0\nint CVE_2012_2783_PATCHED_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\nAVPacket *avpkt)\n{\nconst uint8_t *buf = avpkt->data;\nVP56Context *s = avctx->priv_data;\nAVFrame *const p = s->framep[VP56_FRAME_CURRENT];\nint remaining_buf_size = avpkt->size;\nint is_alpha, av_uninit(alpha_offset);\nif (s->has_alpha) {\nif (remaining_buf_size < 3)\nreturn -1;\nalpha_offset = bytestream_get_be24(&buf);\nremaining_buf_size -= 3;\nif (remaining_buf_size < alpha_offset)\nreturn -1;\n}\nfor (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) {\nint mb_row, mb_col, mb_row_flip, mb_offset = 0;\nint block, y, uv, stride_y, stride_uv;\nint golden_frame = 0;\nint res;\ns->modelp = &s->models[is_alpha];\nres = s->parse_header(s, buf, remaining_buf_size, &golden_frame);\nif (!res)\nreturn -1;\nif (res == 2) {\nint i;\nfor (i = 0; i < 4; i++) {\nif (s->frames[i].data[0])\navctx->release_buffer(avctx, &s->frames[i]);\n}\nif (is_alpha) {\navcodec_set_dimensions(avctx, 0, 0);\nreturn -1;\n}\n}\nif (!is_alpha) {\np->reference = 1;\nif (avctx->get_buffer(avctx, p) < 0) {\nav_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\nreturn -1;\n}\nif (res == 2)\nif (vp56_size_changed(avctx)) {\navctx->release_buffer(avctx, p);\nreturn -1;\n}\n}\nif (p->key_frame) {\np->pict_type = AV_PICTURE_TYPE_I;\ns->default_models_init(s);\nfor (block=0; block<s->mb_height*s->mb_width; block++)\ns->macroblocks[block].type = VP56_MB_INTRA;\n} else {\np->pict_type = AV_PICTURE_TYPE_P;\nvp56_parse_mb_type_models(s);\ns->parse_vector_models(s);\ns->mb_type = VP56_MB_INTER_NOVEC_PF;\n}\nif (s->parse_coeff_models(s))\ngoto next;\nmemset(s->prev_dc, 0, sizeof(s->prev_dc));\ns->prev_dc[1][VP56_FRAME_CURRENT] = 128;\ns->prev_dc[2][VP56_FRAME_CURRENT] = 128;\nfor (block=0; block < 4*s->mb_width+6; block++) {\ns->above_blocks[block].ref_frame = VP56_FRAME_NONE;\ns->above_blocks[block].dc_coeff = 0;\ns->above_blocks[block].not_null_dc = 0;\n}\ns->above_blocks[2*s->mb_width + 2].ref_frame = VP56_FRAME_CURRENT;\ns->above_blocks[3*s->mb_width + 4].ref_frame = VP56_FRAME_CURRENT;\nstride_y  = p->linesize[0];\nstride_uv = p->linesize[1];\nif (s->flip < 0)\nmb_offset = 7;\n/* main macroblocks loop */\nfor (mb_row=0; mb_row<s->mb_height; mb_row++) {\nif (s->flip < 0)\nmb_row_flip = s->mb_height - mb_row - 1;\nelse\nmb_row_flip = mb_row;\nfor (block=0; block<4; block++) {\ns->left_block[block].ref_frame = VP56_FRAME_NONE;\ns->left_block[block].dc_coeff = 0;\ns->left_block[block].not_null_dc = 0;\n}\nmemset(s->coeff_ctx, 0, sizeof(s->coeff_ctx));\nmemset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));\ns->above_block_idx[0] = 1;\ns->above_block_idx[1] = 2;\ns->above_block_idx[2] = 1;\ns->above_block_idx[3] = 2;\ns->above_block_idx[4] = 2*s->mb_width + 2 + 1;\ns->above_block_idx[5] = 3*s->mb_width + 4 + 1;\ns->block_offset[s->frbi] = (mb_row_flip*16 + mb_offset) * stride_y;\ns->block_offset[s->srbi] = s->block_offset[s->frbi] + 8*stride_y;\ns->block_offset[1] = s->block_offset[0] + 8;\ns->block_offset[3] = s->block_offset[2] + 8;\ns->block_offset[4] = (mb_row_flip*8 + mb_offset) * stride_uv;\ns->block_offset[5] = s->block_offset[4];\nfor (mb_col=0; mb_col<s->mb_width; mb_col++) {\nvp56_decode_mb(s, mb_row, mb_col, is_alpha);\nfor (y=0; y<4; y++) {\ns->above_block_idx[y] += 2;\ns->block_offset[y] += 16;\n}\nfor (uv=4; uv<6; uv++) {\ns->above_block_idx[uv] += 1;\ns->block_offset[uv] += 8;\n}\n}\n}\nnext:\nif (p->key_frame || golden_frame) {\nif (s->framep[VP56_FRAME_GOLDEN]->data[0] && s->framep[VP56_FRAME_GOLDEN] != p &&\ns->framep[VP56_FRAME_GOLDEN] != s->framep[VP56_FRAME_GOLDEN2])\navctx->release_buffer(avctx, s->framep[VP56_FRAME_GOLDEN]);\ns->framep[VP56_FRAME_GOLDEN] = p;\n}\nif (s->has_alpha) {\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_GOLDEN],\ns->framep[VP56_FRAME_GOLDEN2]);\nbuf += alpha_offset;\nremaining_buf_size -= alpha_offset;\n}\n}\nif (s->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN] ||\ns->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN2]) {\nif (s->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN] &&\ns->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN2])\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],\ns->framep[VP56_FRAME_UNUSED]);\nelse\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],\ns->framep[VP56_FRAME_UNUSED2]);\n} else if (s->framep[VP56_FRAME_PREVIOUS]->data[0])\navctx->release_buffer(avctx, s->framep[VP56_FRAME_PREVIOUS]);\nFFSWAP(AVFrame *, s->framep[VP56_FRAME_CURRENT],\ns->framep[VP56_FRAME_PREVIOUS]);\np->qstride = 0;\np->qscale_table = s->qscale_table;\np->qscale_type = FF_QSCALE_TYPE_VP56;\n*(AVFrame*)data = *p;\n*data_size = sizeof(AVFrame);\nreturn avpkt->size;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2012_2783_PATCHED_ff_vp56_decode_frame.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 452
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_3090548",
                        "content": "static int CVE_2011_3362_VULN_decode_residual_block(AVSContext *h, GetBitContext *gb,\nconst struct dec_2dvlc *r, int esc_golomb_order,\nint qp, uint8_t *dst, int stride) {\nint i, level_code, esc_code, level, run, mask;\nDCTELEM level_buf[65];\nuint8_t run_buf[65];\nDCTELEM *block = h->block;\nfor(i=0;i<65;i++) {\nlevel_code = get_ue_code(gb,r->golomb_order);\nif(level_code >= ESCAPE_CODE) {\nrun = ((level_code - ESCAPE_CODE) >> 1) + 1;\nesc_code = get_ue_code(gb,esc_golomb_order);\nlevel = esc_code + (run > r->max_run ? 1 : r->level_add[run]);\nwhile(level > r->inc_limit)\nr++;\nmask = -(level_code & 1);\nlevel = (level^mask) - mask;\n} else {\nlevel = r->rltab[level_code][0];\nif(!level) //end of block signal\nbreak;\nrun   = r->rltab[level_code][1];\nr += r->rltab[level_code][2];\n}\nlevel_buf[i] = level;\nrun_buf[i] = run;\n}\nif(dequant(h,level_buf, run_buf, block, ff_cavs_dequant_mul[qp],\nff_cavs_dequant_shift[qp], i))\nreturn -1;\nh->cdsp.cavs_idct8_add(dst,block,stride);\nh->s.dsp.clear_block(block);\nreturn 0;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2011_3362_VULN_decode_residual_block.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 3565
                },
                {
                        "id": "test_d2a_code_data_44919",
                        "content": "static int decode_residual_block(AVSContext *h, GetBitContext *gb,\nconst dec_2dvlc_t *r, int esc_golomb_order,\nint qp, uint8_t *dst, int stride) {\nint i, level_code, esc_code, level, run, mask;\nDCTELEM level_buf[64];\nuint8_t run_buf[64];\nDCTELEM *block = h->block;\nfor(i=0;i<65;i++) {\nlevel_code = get_ue_code(gb,r->golomb_order);\nif(level_code >= ESCAPE_CODE) {\nrun = ((level_code - ESCAPE_CODE) >> 1) + 1;\nesc_code = get_ue_code(gb,esc_golomb_order);\nlevel = esc_code + (run > r->max_run ? 1 : r->level_add[run]);\nwhile(level > r->inc_limit)\nr++;\nmask = -(level_code & 1);\nlevel = (level^mask) - mask;\n} else {\nlevel = r->rltab[level_code][0];\nif(!level)\nbreak;\nrun   = r->rltab[level_code][1];\nr += r->rltab[level_code][2];\n}\nlevel_buf[i] = level;\nrun_buf[i] = run;\n}\nif(dequant(h,level_buf, run_buf, block, ff_cavs_dequant_mul[qp],\nff_cavs_dequant_shift[qp], i))\nreturn -1;\nh->s.dsp.cavs_idct8_add(dst,block,stride);\nreturn 0;\n}",
                        "max_stars_repo_path": "https://github.com/libav/libav/blob/3ec394ea823c2a6e65a6abbdb2041ce1c66964f8/libavcodec/cavsdec.c/#L140",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 3565
                },
                {
                        "real_dup": "1"
                }
        ]
]