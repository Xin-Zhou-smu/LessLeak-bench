[
        {
                "data_len": 115
        },
        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_1",
                        "content": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\nYou can return the answer in any order.\n**Example 1:**\n**Input:** nums = \\[2,7,11,15\\], target = 9\n**Output:** \\[0,1\\]\n**Explanation:** Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\].\n**Example 2:**\n**Input:** nums = \\[3,2,4\\], target = 6\n**Output:** \\[1,2\\]\n**Example 3:**\n**Input:** nums = \\[3,3\\], target = 6\n**Output:** \\[0,1\\]\n**Constraints:**\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?\nInput:\nnums = \\[2,7,11,15\\], target = 9\nOutput:\n\\[0,1\\]\n```python\ndef twoSum(nums, target):\nmap = {}\nfor i, num in enumerate(nums):\ncomplement = target - num\nif complement in map:\nreturn [map[complement], i]\nmap[num] = i\nreturn []\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 203
                },
                {
                        "id": "pretrain_python_data_172935",
                        "content": "\"\"\"\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nOutput: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\nConstraints:\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\nAuthor: <NAME>\n\"\"\"\nclass Solution:\ndef twoSum(self, nums, target):\n\"\"\"\n:type nums: List[int]\n:type target: int\n:rtype: List[int]\n\"\"\"\nlength = len(nums)\nfor i in range(length):\ndiff = target - nums[i]\nif diff in nums[i+1:]:\nindex = nums[i + 1:].index(diff)+i+1\nreturn [i, index]\nif __name__ == '__main__':\nsolution = Solution()\nprint(solution.twoSum([2,7,11,15],9))",
                        "max_stars_repo_name": "gizemkurtoglu/LeetCode",
                        "max_stars_repo_path": "Easy/01 - TwoSum.py",
                        "max_stars_count": 5,
                        "__cluster__": 203
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_1",
                        "content": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\nYou can return the answer in any order.\n**Example 1:**\n**Input:** nums = \\[2,7,11,15\\], target = 9\n**Output:** \\[0,1\\]\n**Explanation:** Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\].\n**Example 2:**\n**Input:** nums = \\[3,2,4\\], target = 6\n**Output:** \\[1,2\\]\n**Example 3:**\n**Input:** nums = \\[3,3\\], target = 6\n**Output:** \\[0,1\\]\n**Constraints:**\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?\nInput:\nnums = \\[2,7,11,15\\], target = 9\nOutput:\n\\[0,1\\]\n```python\ndef twoSum(nums, target):\nmap = {}\nfor i, num in enumerate(nums):\ncomplement = target - num\nif complement in map:\nreturn [map[complement], i]\nmap[num] = i\nreturn []\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 203
                },
                {
                        "id": "pretrain_python_data_172935",
                        "content": "\"\"\"\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nOutput: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\nConstraints:\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\nAuthor: <NAME>\n\"\"\"\nclass Solution:\ndef twoSum(self, nums, target):\n\"\"\"\n:type nums: List[int]\n:type target: int\n:rtype: List[int]\n\"\"\"\nlength = len(nums)\nfor i in range(length):\ndiff = target - nums[i]\nif diff in nums[i+1:]:\nindex = nums[i + 1:].index(diff)+i+1\nreturn [i, index]\nif __name__ == '__main__':\nsolution = Solution()\nprint(solution.twoSum([2,7,11,15],9))",
                        "max_stars_repo_name": "gizemkurtoglu/LeetCode",
                        "max_stars_repo_path": "Easy/01 - TwoSum.py",
                        "max_stars_count": 5,
                        "__cluster__": 203
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```python\ndef rob(nums):\nprev1, prev2 = 0, 0\nfor num in nums:\nprev1, prev2 = max(prev2 + num, prev1), prev1\nreturn prev1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 302
                },
                {
                        "id": "pretrain_python_data_3200278",
                        "content": "<gh_stars>1-10\n'''\nYou are a professional robber planning to rob houses along a street.\nEach house has a certain amount of money stashed, the only constraint\nstopping you from robbing each of them is that adjacent houses\nhave security system connected and it will automatically contact\nthe police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of\nmoney of each house, determine the maximum amount of money you can\nrob tonight without alerting the police.\nExample 1:\nInput: [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n'''\nclass Solution:\ndef rob(self, nums) -> int:\nn = len(nums)\nif n == 0:\nreturn 0\ndp = [0] * (n+1)\ndp[1] = nums[0]\nfor i in range(2, n+1):\ndp[i] = max(nums[i-1]+dp[i-2], dp[i-1])\nreturn dp[-1]\nprint(Solution().rob([2,7,9,3,1]))",
                        "max_stars_repo_name": "ZR-Huang/AlgorithmPractices",
                        "max_stars_repo_path": "Leetcode/Basic/Dynamic_Programming/198_House_Robber.py",
                        "max_stars_count": 1,
                        "__cluster__": 302
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```python\ndef rob(nums):\nprev1, prev2 = 0, 0\nfor num in nums:\nprev1, prev2 = max(prev2 + num, prev1), prev1\nreturn prev1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 302
                },
                {
                        "id": "pretrain_python_data_3200278",
                        "content": "<gh_stars>1-10\n'''\nYou are a professional robber planning to rob houses along a street.\nEach house has a certain amount of money stashed, the only constraint\nstopping you from robbing each of them is that adjacent houses\nhave security system connected and it will automatically contact\nthe police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of\nmoney of each house, determine the maximum amount of money you can\nrob tonight without alerting the police.\nExample 1:\nInput: [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n'''\nclass Solution:\ndef rob(self, nums) -> int:\nn = len(nums)\nif n == 0:\nreturn 0\ndp = [0] * (n+1)\ndp[1] = nums[0]\nfor i in range(2, n+1):\ndp[i] = max(nums[i-1]+dp[i-2], dp[i-1])\nreturn dp[-1]\nprint(Solution().rob([2,7,9,3,1]))",
                        "max_stars_repo_name": "ZR-Huang/AlgorithmPractices",
                        "max_stars_repo_path": "Leetcode/Basic/Dynamic_Programming/198_House_Robber.py",
                        "max_stars_count": 1,
                        "__cluster__": 302
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_88",
                        "content": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.\nThe final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.\n**Example 1:**\n**Input:** nums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\n**Output:** \\[1,2,2,3,5,6\\]\n**Explanation:** The arrays we are merging are \\[1,2,3\\] and \\[2,5,6\\].\nThe result of the merge is \\[1,2,2,3,5,6\\] with the underlined elements coming from nums1.\n**Example 2:**\n**Input:** nums1 = \\[1\\], m = 1, nums2 = \\[\\], n = 0\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[1\\] and \\[\\].\nThe result of the merge is \\[1\\].\n**Example 3:**\n**Input:** nums1 = \\[0\\], m = 0, nums2 = \\[1\\], n = 1\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[\\] and \\[1\\].\nThe result of the merge is \\[1\\].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n**Constraints:**\n*   `nums1.length == m + n`\n*   `nums2.length == n`\n*   `0 <= m, n <= 200`\n*   `1 <= m + n <= 200`\n*   `-109 <= nums1[i], nums2[j] <= 109`\n**Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?\nInput:\nnums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\nOutput:\n\\[1,2,2,3,5,6\\]\n```python\ndef merge(nums1, m, nums2, n):\ni, j, k = m - 1, n - 1, m + n - 1\nwhile i >= 0 and j >= 0:\nif nums1[i] > nums2[j]:\nnums1[k] = nums1[i]\ni -= 1\nelse:\nnums1[k] = nums2[j]\nj -= 1\nk -= 1\nwhile j >= 0:\nnums1[k] = nums2[j]\nk -= 1\nj -= 1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 254
                },
                {
                        "id": "pretrain_python_data_3396369",
                        "content": "# Merge Sorted Array\n# You are given two integer arrays nums1 and nums2, sorted in non-decreasing order,\n# and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n# Merge nums1 and nums2 into a single array sorted in non-decreasing order.\n# The final sorted array should not be returned by the function, but instead be\n# stored inside the array nums1. To accommodate this, nums1 has a length of m + n,\n# where the first m elements denote the elements that should be merged, and the last\n# n elements are set to 0 and should be ignored. nums2 has a length of n.\n# Example 1:\n# Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n# Output: [1,2,2,3,5,6]\n# Explanation: The arrays we are merging are [1,2,3] and [2,5,6].\n# The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n# Example 2:\n# Input: nums1 = [1], m = 1, nums2 = [], n = 0\n# Output: [1]\n# Explanation: The arrays we are merging are [1] and [].\n# The result of the merge is [1].\n# Example 3:\n# Input: nums1 = [0], m = 0, nums2 = [1], n = 1\n# Output: [1]\n# Explanation: The arrays we are merging are [] and [1].\n# The result of the merge is [1].\n# Note that because m = 0, there are no elements in nums1. The 0 is only there to\n# ensure the merge result can fit in nums1.\n# Constraints:\n# nums1.length == m + n\n# nums2.length == n\n# 0 <= m, n <= 200\n# 1 <= m + n <= 200\n# -109 <= nums1[i], nums2[j] <= 109\n# Follow up: Can you come up with an algorithm that runs in O(m + n) time?\ndef mergeSortedArrays(nums1,  nums2):\n# Our Pointers\nm, n = len(nums1) - 1, len(nums2) - 1\nlast = m + n - 1\n# merge them in reverse order\nwhile m > 0 and n > 0:\nif nums1[m] > nums2[n]:\nnums1[last] = nums1[m]\nm -= 1\nelse:\nnums1[last] = nums2[n]\nn -= 1\nlast -= 1\nwhile n > 0:\nnums1[last] = nums2[n]\nn, last = n-1, last-1\nprint(nums1)\n# print(nums1, nums2)\nmergeSortedArrays([1, 2, 3, 0, 0, 0], [2, 5, 6])\n# nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                        "max_stars_repo_name": "shelcia/InterviewQuestionPython",
                        "max_stars_repo_path": "amazon/MergeTwoSortArrays.py",
                        "max_stars_count": 1,
                        "__cluster__": 254
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_88",
                        "content": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.\nThe final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.\n**Example 1:**\n**Input:** nums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\n**Output:** \\[1,2,2,3,5,6\\]\n**Explanation:** The arrays we are merging are \\[1,2,3\\] and \\[2,5,6\\].\nThe result of the merge is \\[1,2,2,3,5,6\\] with the underlined elements coming from nums1.\n**Example 2:**\n**Input:** nums1 = \\[1\\], m = 1, nums2 = \\[\\], n = 0\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[1\\] and \\[\\].\nThe result of the merge is \\[1\\].\n**Example 3:**\n**Input:** nums1 = \\[0\\], m = 0, nums2 = \\[1\\], n = 1\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[\\] and \\[1\\].\nThe result of the merge is \\[1\\].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n**Constraints:**\n*   `nums1.length == m + n`\n*   `nums2.length == n`\n*   `0 <= m, n <= 200`\n*   `1 <= m + n <= 200`\n*   `-109 <= nums1[i], nums2[j] <= 109`\n**Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?\nInput:\nnums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\nOutput:\n\\[1,2,2,3,5,6\\]\n```python\ndef merge(nums1, m, nums2, n):\ni, j, k = m - 1, n - 1, m + n - 1\nwhile i >= 0 and j >= 0:\nif nums1[i] > nums2[j]:\nnums1[k] = nums1[i]\ni -= 1\nelse:\nnums1[k] = nums2[j]\nj -= 1\nk -= 1\nwhile j >= 0:\nnums1[k] = nums2[j]\nk -= 1\nj -= 1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 254
                },
                {
                        "id": "pretrain_python_data_3396369",
                        "content": "# Merge Sorted Array\n# You are given two integer arrays nums1 and nums2, sorted in non-decreasing order,\n# and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n# Merge nums1 and nums2 into a single array sorted in non-decreasing order.\n# The final sorted array should not be returned by the function, but instead be\n# stored inside the array nums1. To accommodate this, nums1 has a length of m + n,\n# where the first m elements denote the elements that should be merged, and the last\n# n elements are set to 0 and should be ignored. nums2 has a length of n.\n# Example 1:\n# Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n# Output: [1,2,2,3,5,6]\n# Explanation: The arrays we are merging are [1,2,3] and [2,5,6].\n# The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n# Example 2:\n# Input: nums1 = [1], m = 1, nums2 = [], n = 0\n# Output: [1]\n# Explanation: The arrays we are merging are [1] and [].\n# The result of the merge is [1].\n# Example 3:\n# Input: nums1 = [0], m = 0, nums2 = [1], n = 1\n# Output: [1]\n# Explanation: The arrays we are merging are [] and [1].\n# The result of the merge is [1].\n# Note that because m = 0, there are no elements in nums1. The 0 is only there to\n# ensure the merge result can fit in nums1.\n# Constraints:\n# nums1.length == m + n\n# nums2.length == n\n# 0 <= m, n <= 200\n# 1 <= m + n <= 200\n# -109 <= nums1[i], nums2[j] <= 109\n# Follow up: Can you come up with an algorithm that runs in O(m + n) time?\ndef mergeSortedArrays(nums1,  nums2):\n# Our Pointers\nm, n = len(nums1) - 1, len(nums2) - 1\nlast = m + n - 1\n# merge them in reverse order\nwhile m > 0 and n > 0:\nif nums1[m] > nums2[n]:\nnums1[last] = nums1[m]\nm -= 1\nelse:\nnums1[last] = nums2[n]\nn -= 1\nlast -= 1\nwhile n > 0:\nnums1[last] = nums2[n]\nn, last = n-1, last-1\nprint(nums1)\n# print(nums1, nums2)\nmergeSortedArrays([1, 2, 3, 0, 0, 0], [2, 5, 6])\n# nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                        "max_stars_repo_name": "shelcia/InterviewQuestionPython",
                        "max_stars_repo_path": "amazon/MergeTwoSortArrays.py",
                        "max_stars_count": 1,
                        "__cluster__": 254
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_88",
                        "content": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.\nThe final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.\n**Example 1:**\n**Input:** nums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\n**Output:** \\[1,2,2,3,5,6\\]\n**Explanation:** The arrays we are merging are \\[1,2,3\\] and \\[2,5,6\\].\nThe result of the merge is \\[1,2,2,3,5,6\\] with the underlined elements coming from nums1.\n**Example 2:**\n**Input:** nums1 = \\[1\\], m = 1, nums2 = \\[\\], n = 0\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[1\\] and \\[\\].\nThe result of the merge is \\[1\\].\n**Example 3:**\n**Input:** nums1 = \\[0\\], m = 0, nums2 = \\[1\\], n = 1\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[\\] and \\[1\\].\nThe result of the merge is \\[1\\].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n**Constraints:**\n*   `nums1.length == m + n`\n*   `nums2.length == n`\n*   `0 <= m, n <= 200`\n*   `1 <= m + n <= 200`\n*   `-109 <= nums1[i], nums2[j] <= 109`\n**Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?\nInput:\nnums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\nOutput:\n\\[1,2,2,3,5,6\\]\n```python\ndef merge(nums1, m, nums2, n):\ni, j, k = m - 1, n - 1, m + n - 1\nwhile i >= 0 and j >= 0:\nif nums1[i] > nums2[j]:\nnums1[k] = nums1[i]\ni -= 1\nelse:\nnums1[k] = nums2[j]\nj -= 1\nk -= 1\nwhile j >= 0:\nnums1[k] = nums2[j]\nk -= 1\nj -= 1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 254
                },
                {
                        "id": "pretrain_python_data_3396369",
                        "content": "# Merge Sorted Array\n# You are given two integer arrays nums1 and nums2, sorted in non-decreasing order,\n# and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n# Merge nums1 and nums2 into a single array sorted in non-decreasing order.\n# The final sorted array should not be returned by the function, but instead be\n# stored inside the array nums1. To accommodate this, nums1 has a length of m + n,\n# where the first m elements denote the elements that should be merged, and the last\n# n elements are set to 0 and should be ignored. nums2 has a length of n.\n# Example 1:\n# Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n# Output: [1,2,2,3,5,6]\n# Explanation: The arrays we are merging are [1,2,3] and [2,5,6].\n# The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n# Example 2:\n# Input: nums1 = [1], m = 1, nums2 = [], n = 0\n# Output: [1]\n# Explanation: The arrays we are merging are [1] and [].\n# The result of the merge is [1].\n# Example 3:\n# Input: nums1 = [0], m = 0, nums2 = [1], n = 1\n# Output: [1]\n# Explanation: The arrays we are merging are [] and [1].\n# The result of the merge is [1].\n# Note that because m = 0, there are no elements in nums1. The 0 is only there to\n# ensure the merge result can fit in nums1.\n# Constraints:\n# nums1.length == m + n\n# nums2.length == n\n# 0 <= m, n <= 200\n# 1 <= m + n <= 200\n# -109 <= nums1[i], nums2[j] <= 109\n# Follow up: Can you come up with an algorithm that runs in O(m + n) time?\ndef mergeSortedArrays(nums1,  nums2):\n# Our Pointers\nm, n = len(nums1) - 1, len(nums2) - 1\nlast = m + n - 1\n# merge them in reverse order\nwhile m > 0 and n > 0:\nif nums1[m] > nums2[n]:\nnums1[last] = nums1[m]\nm -= 1\nelse:\nnums1[last] = nums2[n]\nn -= 1\nlast -= 1\nwhile n > 0:\nnums1[last] = nums2[n]\nn, last = n-1, last-1\nprint(nums1)\n# print(nums1, nums2)\nmergeSortedArrays([1, 2, 3, 0, 0, 0], [2, 5, 6])\n# nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                        "max_stars_repo_name": "shelcia/InterviewQuestionPython",
                        "max_stars_repo_path": "amazon/MergeTwoSortArrays.py",
                        "max_stars_count": 1,
                        "__cluster__": 254
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "pretrain_python_data_6429678",
                        "content": "'''\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExample 1:\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\nExample 2:\nInput: digits = \"\"\nOutput: []\nExample 3:\nInput: digits = \"2\"\nOutput: [\"a\",\"b\",\"c\"]\nConstraints:\n0 <= digits.length <= 4\ndigits[i] is a digit in the range ['2', '9'].\n'''\nclass Solution:\ndef letterCombinations(self, digits: str) -> List[str]:\nif not digits:\nreturn []\nself.output = []\nself.hash_dict = {'2': 'abc', '3': 'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8': 'tuv', '9': 'wxyz'}\nself.backtracking(digits, '')\nreturn self.output\ndef backtracking(self, digits, cur_str):\nif len(digits) == 0:\nself.output.append(cur_str)\nreturn\nfor x in self.hash_dict[digits[0]]:\nself.backtracking(digits[1:], cur_str + x)\nreturn",
                        "max_stars_repo_name": "adwardlee/leetcode_solutions",
                        "max_stars_repo_path": "DFS/0017_Letter_Combinations_of_a_Phone_Number.py",
                        "max_stars_count": 0,
                        "__cluster__": 215
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_17",
                        "content": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n**Example 1:**\n**Input:** digits =  \"23 \"\n**Output:** \\[ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"\\]\n**Example 2:**\n**Input:** digits =  \" \"\n**Output:** \\[\\]\n**Example 3:**\n**Input:** digits =  \"2 \"\n**Output:** \\[ \"a \", \"b \", \"c \"\\]\n**Constraints:**\n*   `0 <= digits.length <= 4`\n*   `digits[i]` is a digit in the range `['2', '9']`.\nInput:\ndigits =  \"23 \"\nOutput:\n\\[ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"\\]\n```python\ndef letter_combinations(digits: str):\nif not digits: return []\nphone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\nresult = [\"\"]\nfor digit in digits:\ntemp = []\nfor s in result:\nfor c in phone[int(digit) - 2]:\ntemp.append(s + c)\nresult = temp\nreturn result\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 215
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_521",
                        "content": "Given two strings `a` and `b`, return _the length of the **longest uncommon subsequence** between_ `a` _and_ `b`. If the longest uncommon subsequence does not exist, return `-1`.\nAn **uncommon subsequence** between two strings is a string that is a **subsequence of one but not the other**.\nA **subsequence** of a string `s` is a string that can be obtained after deleting any number of characters from `s`.\n*   For example, `\"abc \"` is a subsequence of `\"aebdc \"` because you can delete the underlined characters in `\"aebdc \"` to get `\"abc \"`. Other subsequences of `\"aebdc \"` include `\"aebdc \"`, `\"aeb \"`, and `\" \"` (empty string).\n**Example 1:**\n**Input:** a =  \"aba \", b =  \"cdc \"\n**Output:** 3\n**Explanation:** One longest uncommon subsequence is  \"aba \" because  \"aba \" is a subsequence of  \"aba \" but not  \"cdc \".\nNote that  \"cdc \" is also a longest uncommon subsequence.\n**Example 2:**\n**Input:** a =  \"aaa \", b =  \"bbb \"\n**Output:** 3\n**Explanation:** The longest uncommon subsequences are  \"aaa \" and  \"bbb \".\n**Example 3:**\n**Input:** a =  \"aaa \", b =  \"aaa \"\n**Output:** -1\n**Explanation:** Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a.\n**Constraints:**\n*   `1 <= a.length, b.length <= 100`\n*   `a` and `b` consist of lower-case English letters.\nInput:\na =  \"aba \", b =  \"cdc \"\nOutput:\n3\n```python\ndef findLUSlength(a: str, b: str) -> int:\nif a == b:\nreturn -1\nreturn max(len(a), len(b))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 426
                },
                {
                        "id": "pretrain_python_data_6401256",
                        "content": "\"\"\"\nGiven two strings a\u00a0and b, find the length of the\u00a0longest uncommon subsequence\u00a0between them.\nA\u00a0subsequence\u00a0of\u00a0a string\u00a0s\u00a0is a string that can be obtained after deleting any number of characters from s. For example, \"abc\"\u00a0is a subsequence of \"aebdc\"\u00a0because you can delete the underlined characters in\u00a0\"aebdc\"\u00a0to get \"abc\". Other subsequences of\u00a0\"aebdc\"\u00a0include\u00a0\"aebdc\",\u00a0\"aeb\",\u00a0and\u00a0\"\"\u00a0(empty string).\nAn\u00a0uncommon subsequence\u00a0between two strings\u00a0is a string that is a subsequence of one\u00a0but not the other.\nReturn the length of the longest uncommon subsequence\u00a0between a\u00a0and b. If the longest uncommon subsequence doesn't exist, return -1.\nExample 1:\nInput: a = \"aba\", b = \"cdc\"\nOutput: 3\nExplanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\nNote that \"cdc\" is also a longest uncommon subsequence.\nExample 2:\nInput: a = \"aaa\", b = \"bbb\"\nOutput: 3\nExplanation:\u00a0The longest uncommon subsequences are \"aaa\" and \"bbb\".\nExample 3:\nInput: a = \"aaa\", b = \"aaa\"\nOutput: -1\nExplanation:\u00a0Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a.\nConstraints:\n1 <= a.length, b.length <= 100\na and b consist of lower-case English letters.\n\"\"\"\nclass Solution(object):\ndef findLUSlength(self, a, b):\n\"\"\"\n:type a: str\n:type b: str\n:rtype: int\n\"\"\"\nif a == b:\nreturn -1\nreturn max(len(a), len(b))",
                        "max_stars_repo_name": "marcus-aurelianus/leetcode-solutions",
                        "max_stars_repo_path": "questions/longest-uncommon-subsequence-i/Solution.py",
                        "max_stars_count": 141,
                        "__cluster__": 426
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_637",
                        "content": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n**Example 2:**\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n\\[3.00000,14.50000,11.00000\\]\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef averageOfLevels(root: TreeNode):\nresult = []\nqueue = [root]\nwhile queue:\nsum_ = 0\ncount = 0\ntemp = []\nwhile queue:\nnode = queue.pop(0)\nsum_ += node.val\ncount += 1\nif node.left: temp.append(node.left)\nif node.right: temp.append(node.right)\nqueue = temp\nresult.append(sum_ / count)\nreturn result\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 36
                },
                {
                        "id": "pretrain_python_data_9648489",
                        "content": "\"\"\"Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers\nwithin 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\nExample 2:\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef averageOfLevels(self, root: TreeNode) -> List[float]:\nif root is None:\nreturn root\nqueue = []\nvals = []\nqueue.append(root)\nwhile len(queue) > 0:\nn = 0\nlevel_sum = 0\nfor _ in range(len(queue)):\nnode = queue.pop(0)\nif node.right:\nqueue.append(node.right)\nif node.left:\nqueue.append(node.left)\nn += 1\nprint(n, node.val)\nlevel_sum += node.val\naverage = level_sum / n\nvals.append(average)\nreturn vals",
                        "max_stars_repo_name": "H-isaac23/LeetCode-Challenges",
                        "max_stars_repo_path": "March 5.py",
                        "max_stars_count": 1,
                        "__cluster__": 36
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_637",
                        "content": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n**Example 2:**\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n\\[3.00000,14.50000,11.00000\\]\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef averageOfLevels(root: TreeNode):\nresult = []\nqueue = [root]\nwhile queue:\nsum_ = 0\ncount = 0\ntemp = []\nwhile queue:\nnode = queue.pop(0)\nsum_ += node.val\ncount += 1\nif node.left: temp.append(node.left)\nif node.right: temp.append(node.right)\nqueue = temp\nresult.append(sum_ / count)\nreturn result\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 36
                },
                {
                        "id": "pretrain_python_data_9648489",
                        "content": "\"\"\"Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers\nwithin 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\nExample 2:\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef averageOfLevels(self, root: TreeNode) -> List[float]:\nif root is None:\nreturn root\nqueue = []\nvals = []\nqueue.append(root)\nwhile len(queue) > 0:\nn = 0\nlevel_sum = 0\nfor _ in range(len(queue)):\nnode = queue.pop(0)\nif node.right:\nqueue.append(node.right)\nif node.left:\nqueue.append(node.left)\nn += 1\nprint(n, node.val)\nlevel_sum += node.val\naverage = level_sum / n\nvals.append(average)\nreturn vals",
                        "max_stars_repo_name": "H-isaac23/LeetCode-Challenges",
                        "max_stars_repo_path": "March 5.py",
                        "max_stars_count": 1,
                        "__cluster__": 36
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_637",
                        "content": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n**Example 2:**\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n\\[3.00000,14.50000,11.00000\\]\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef averageOfLevels(root: TreeNode):\nresult = []\nqueue = [root]\nwhile queue:\nsum_ = 0\ncount = 0\ntemp = []\nwhile queue:\nnode = queue.pop(0)\nsum_ += node.val\ncount += 1\nif node.left: temp.append(node.left)\nif node.right: temp.append(node.right)\nqueue = temp\nresult.append(sum_ / count)\nreturn result\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 36
                },
                {
                        "id": "pretrain_python_data_9648489",
                        "content": "\"\"\"Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers\nwithin 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\nExample 2:\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef averageOfLevels(self, root: TreeNode) -> List[float]:\nif root is None:\nreturn root\nqueue = []\nvals = []\nqueue.append(root)\nwhile len(queue) > 0:\nn = 0\nlevel_sum = 0\nfor _ in range(len(queue)):\nnode = queue.pop(0)\nif node.right:\nqueue.append(node.right)\nif node.left:\nqueue.append(node.left)\nn += 1\nprint(n, node.val)\nlevel_sum += node.val\naverage = level_sum / n\nvals.append(average)\nreturn vals",
                        "max_stars_repo_name": "H-isaac23/LeetCode-Challenges",
                        "max_stars_repo_path": "March 5.py",
                        "max_stars_count": 1,
                        "__cluster__": 36
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_20",
                        "content": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\nAn input string is valid if:\n1.  Open brackets must be closed by the same type of brackets.\n2.  Open brackets must be closed in the correct order.\n3.  Every close bracket has a corresponding open bracket of the same type.\n**Example 1:**\n**Input:** s =  \"() \"\n**Output:** true\n**Example 2:**\n**Input:** s =  \"()\\[\\]{} \"\n**Output:** true\n**Example 3:**\n**Input:** s =  \"(\\] \"\n**Output:** false\n**Constraints:**\n*   `1 <= s.length <= 104`\n*   `s` consists of parentheses only `'()[]{}'`.\nInput:\ns =  \"() \"\nOutput:\ntrue\n```python\ndef is_valid(s: str) -> bool:\nstack = []\nfor c in s:\nif c in '([{':\nstack.append(c)\nelse:\nif not stack:\nreturn False\nif c == ')' and stack[-1] != '(':\nreturn False\nif c == '}' and stack[-1] != '{':\nreturn False\nif c == ']' and stack[-1] != '[':\nreturn False\nstack.pop()\nreturn not stack\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 217
                },
                {
                        "id": "pretrain_python_data_8143340",
                        "content": "# Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n#\n# An input string is valid if:\n#\n#\n# \tOpen brackets must be closed by the same type of brackets.\n# \tOpen brackets must be closed in the correct order.\n#\n#\n#\n# Example 1:\n#\n#\n# Input: s = \"()\"\n# Output: true\n#\n#\n# Example 2:\n#\n#\n# Input: s = \"()[]{}\"\n# Output: true\n#\n#\n# Example 3:\n#\n#\n# Input: s = \"(]\"\n# Output: false\n#\n#\n# Example 4:\n#\n#\n# Input: s = \"([)]\"\n# Output: false\n#\n#\n# Example 5:\n#\n#\n# Input: s = \"{[]}\"\n# Output: true\n#\n#\n#\n# Constraints:\n#\n#\n# \t1 <= s.length <= 104\n# \ts consists of parentheses only '()[]{}'.\n#\n#\nclass Solution:\ndef isValid(self, s: str) -> bool:\nstack = []\nparen_map = {')': '(', ']': '[', '}': '{'}\nfor c in s:\nif c not in paren_map:\nstack.append(c)\nelif not stack or paren_map[c] != stack.pop():\nreturn False\nreturn not stack",
                        "max_stars_repo_name": "chyidl/leetcode",
                        "max_stars_repo_path": "0020-valid-parentheses/valid-parentheses.py",
                        "max_stars_count": 2,
                        "__cluster__": 217
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_11273574",
                        "content": "# Add Two Numbers\n'''\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n'''\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ns = ListNode(0)\nans = s\ncarry = 0\nwhile l1 or l2:\nif l1 and l2:\nadd = l1.val+l2.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl1 = l1.next\nl2 = l2.next\nelif l1:\nadd = l1.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl1 = l1.next\nelse:\nadd = l2.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl2 = l2.next\ns = s.next\nif carry!=0:\ns.next = ListNode(carry)\nreturn ans.next",
                        "max_stars_repo_name": "vinaykumar7686/Leetcode-August_Challenge",
                        "max_stars_repo_path": "January/Week2/Add Two Numbers.py",
                        "max_stars_count": 1,
                        "__cluster__": 205
                },
                {
                        "real_dup": 2
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_11273574",
                        "content": "# Add Two Numbers\n'''\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n'''\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ns = ListNode(0)\nans = s\ncarry = 0\nwhile l1 or l2:\nif l1 and l2:\nadd = l1.val+l2.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl1 = l1.next\nl2 = l2.next\nelif l1:\nadd = l1.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl1 = l1.next\nelse:\nadd = l2.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl2 = l2.next\ns = s.next\nif carry!=0:\ns.next = ListNode(carry)\nreturn ans.next",
                        "max_stars_repo_name": "vinaykumar7686/Leetcode-August_Challenge",
                        "max_stars_repo_path": "January/Week2/Add Two Numbers.py",
                        "max_stars_count": 1,
                        "__cluster__": 205
                },
                {
                        "real_dup": 2
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_11273574",
                        "content": "# Add Two Numbers\n'''\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n'''\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ns = ListNode(0)\nans = s\ncarry = 0\nwhile l1 or l2:\nif l1 and l2:\nadd = l1.val+l2.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl1 = l1.next\nl2 = l2.next\nelif l1:\nadd = l1.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl1 = l1.next\nelse:\nadd = l2.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl2 = l2.next\ns = s.next\nif carry!=0:\ns.next = ListNode(carry)\nreturn ans.next",
                        "max_stars_repo_name": "vinaykumar7686/Leetcode-August_Challenge",
                        "max_stars_repo_path": "January/Week2/Add Two Numbers.py",
                        "max_stars_count": 1,
                        "__cluster__": 205
                },
                {
                        "real_dup": 2
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_11273574",
                        "content": "# Add Two Numbers\n'''\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n'''\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ns = ListNode(0)\nans = s\ncarry = 0\nwhile l1 or l2:\nif l1 and l2:\nadd = l1.val+l2.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl1 = l1.next\nl2 = l2.next\nelif l1:\nadd = l1.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl1 = l1.next\nelse:\nadd = l2.val+carry\nif add>9:\ns.next = ListNode(add-10)\ncarry = 1\nelse:\ns.next = ListNode(add)\ncarry = 0\nl2 = l2.next\ns = s.next\nif carry!=0:\ns.next = ListNode(carry)\nreturn ans.next",
                        "max_stars_repo_name": "vinaykumar7686/Leetcode-August_Challenge",
                        "max_stars_repo_path": "January/Week2/Add Two Numbers.py",
                        "max_stars_count": 1,
                        "__cluster__": 205
                },
                {
                        "real_dup": 2
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_1885131",
                        "content": "# Validate Binary Search Tree\n'''\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n'''\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef isValidBST(self, root: TreeNode) -> bool:\nif not root:\nreturn True\ndef helper(root, l ,h ):\nif not root:\nreturn True\nif root.val<=l or root.val>=h:\nreturn False\nreturn helper(root.left, l, root.val) and helper(root.right, root.val, h)\nreturn helper(root, float(\"-inf\"), float(\"inf\"))",
                        "max_stars_repo_name": "vinaykumar7686/Leetcode-August_Challenge",
                        "max_stars_repo_path": "December/Week3/Validate Binary Search Tree.py",
                        "max_stars_count": 1,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_1885131",
                        "content": "# Validate Binary Search Tree\n'''\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n'''\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef isValidBST(self, root: TreeNode) -> bool:\nif not root:\nreturn True\ndef helper(root, l ,h ):\nif not root:\nreturn True\nif root.val<=l or root.val>=h:\nreturn False\nreturn helper(root.left, l, root.val) and helper(root.right, root.val, h)\nreturn helper(root, float(\"-inf\"), float(\"inf\"))",
                        "max_stars_repo_name": "vinaykumar7686/Leetcode-August_Challenge",
                        "max_stars_repo_path": "December/Week3/Validate Binary Search Tree.py",
                        "max_stars_count": 1,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_1885131",
                        "content": "# Validate Binary Search Tree\n'''\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n'''\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef isValidBST(self, root: TreeNode) -> bool:\nif not root:\nreturn True\ndef helper(root, l ,h ):\nif not root:\nreturn True\nif root.val<=l or root.val>=h:\nreturn False\nreturn helper(root.left, l, root.val) and helper(root.right, root.val, h)\nreturn helper(root, float(\"-inf\"), float(\"inf\"))",
                        "max_stars_repo_name": "vinaykumar7686/Leetcode-August_Challenge",
                        "max_stars_repo_path": "December/Week3/Validate Binary Search Tree.py",
                        "max_stars_count": 1,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_3438195",
                        "content": "# Source : https://leetcode.com/problems/add-two-numbers/\n# Author : henrytine\n# Date   : 2020-10-10\n#####################################################################################################\n#\n# You are given two non-empty linked lists representing two non-negative integers. The digits are\n# stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and\n# return the sum as a linked list.\n#\n# You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n#\n# Example 1:\n#\n# Input: l1 = [2,4,3], l2 = [5,6,4]\n# Output: [7,0,8]\n# Explanation: 342 + 465 = 807.\n#\n# Example 2:\n#\n# Input: l1 = [0], l2 = [0]\n# Output: [0]\n#\n# Example 3:\n#\n# Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n# Output: [8,9,9,9,0,0,0,1]\n#\n# Constraints:\n#\n# \tThe number of nodes in each linked list is in the range [1, 100].\n# \t0 <= Node.val <= 9\n# \tIt is guaranteed that the list represents a number that does not have leading zeros.\n#####################################################################################################\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# O(n) O(n)\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ndummy = tail = ListNode(0)\ns = 0\nwhile l1 or l2 or s:\ns += (l1.val if l1 else 0) + (l2.val if l2 else 0)\ntail.next = ListNode(s % 10)\ntail = tail.next\ns //= 10\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nreturn dummy.next\n",
                        "max_stars_repo_name": "henrytien/AlgorithmSolutions",
                        "max_stars_repo_path": "leetcode/2.add_two_numbers/2.AddTwoNumbers_henrytine.py",
                        "max_stars_count": 15,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_3438195",
                        "content": "# Source : https://leetcode.com/problems/add-two-numbers/\n# Author : henrytine\n# Date   : 2020-10-10\n#####################################################################################################\n#\n# You are given two non-empty linked lists representing two non-negative integers. The digits are\n# stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and\n# return the sum as a linked list.\n#\n# You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n#\n# Example 1:\n#\n# Input: l1 = [2,4,3], l2 = [5,6,4]\n# Output: [7,0,8]\n# Explanation: 342 + 465 = 807.\n#\n# Example 2:\n#\n# Input: l1 = [0], l2 = [0]\n# Output: [0]\n#\n# Example 3:\n#\n# Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n# Output: [8,9,9,9,0,0,0,1]\n#\n# Constraints:\n#\n# \tThe number of nodes in each linked list is in the range [1, 100].\n# \t0 <= Node.val <= 9\n# \tIt is guaranteed that the list represents a number that does not have leading zeros.\n#####################################################################################################\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# O(n) O(n)\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ndummy = tail = ListNode(0)\ns = 0\nwhile l1 or l2 or s:\ns += (l1.val if l1 else 0) + (l2.val if l2 else 0)\ntail.next = ListNode(s % 10)\ntail = tail.next\ns //= 10\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nreturn dummy.next\n",
                        "max_stars_repo_name": "henrytien/AlgorithmSolutions",
                        "max_stars_repo_path": "leetcode/2.add_two_numbers/2.AddTwoNumbers_henrytine.py",
                        "max_stars_count": 15,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_3438195",
                        "content": "# Source : https://leetcode.com/problems/add-two-numbers/\n# Author : henrytine\n# Date   : 2020-10-10\n#####################################################################################################\n#\n# You are given two non-empty linked lists representing two non-negative integers. The digits are\n# stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and\n# return the sum as a linked list.\n#\n# You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n#\n# Example 1:\n#\n# Input: l1 = [2,4,3], l2 = [5,6,4]\n# Output: [7,0,8]\n# Explanation: 342 + 465 = 807.\n#\n# Example 2:\n#\n# Input: l1 = [0], l2 = [0]\n# Output: [0]\n#\n# Example 3:\n#\n# Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n# Output: [8,9,9,9,0,0,0,1]\n#\n# Constraints:\n#\n# \tThe number of nodes in each linked list is in the range [1, 100].\n# \t0 <= Node.val <= 9\n# \tIt is guaranteed that the list represents a number that does not have leading zeros.\n#####################################################################################################\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# O(n) O(n)\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ndummy = tail = ListNode(0)\ns = 0\nwhile l1 or l2 or s:\ns += (l1.val if l1 else 0) + (l2.val if l2 else 0)\ntail.next = ListNode(s % 10)\ntail = tail.next\ns //= 10\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nreturn dummy.next\n",
                        "max_stars_repo_name": "henrytien/AlgorithmSolutions",
                        "max_stars_repo_path": "leetcode/2.add_two_numbers/2.AddTwoNumbers_henrytine.py",
                        "max_stars_count": 15,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_3438195",
                        "content": "# Source : https://leetcode.com/problems/add-two-numbers/\n# Author : henrytine\n# Date   : 2020-10-10\n#####################################################################################################\n#\n# You are given two non-empty linked lists representing two non-negative integers. The digits are\n# stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and\n# return the sum as a linked list.\n#\n# You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n#\n# Example 1:\n#\n# Input: l1 = [2,4,3], l2 = [5,6,4]\n# Output: [7,0,8]\n# Explanation: 342 + 465 = 807.\n#\n# Example 2:\n#\n# Input: l1 = [0], l2 = [0]\n# Output: [0]\n#\n# Example 3:\n#\n# Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n# Output: [8,9,9,9,0,0,0,1]\n#\n# Constraints:\n#\n# \tThe number of nodes in each linked list is in the range [1, 100].\n# \t0 <= Node.val <= 9\n# \tIt is guaranteed that the list represents a number that does not have leading zeros.\n#####################################################################################################\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# O(n) O(n)\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ndummy = tail = ListNode(0)\ns = 0\nwhile l1 or l2 or s:\ns += (l1.val if l1 else 0) + (l2.val if l2 else 0)\ntail.next = ListNode(s % 10)\ntail = tail.next\ns //= 10\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nreturn dummy.next\n",
                        "max_stars_repo_name": "henrytien/AlgorithmSolutions",
                        "max_stars_repo_path": "leetcode/2.add_two_numbers/2.AddTwoNumbers_henrytine.py",
                        "max_stars_count": 15,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_3497143",
                        "content": "<gh_stars>0\n# Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements\n# of nums except nums[i].\n# The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n# You must write an algorithm that runs in O(n) time and without using the division operation.\n#\n# Example 1:\n# Input: nums = [1, 2, 3, 4]\n# Output: [24, 12, 8, 6]\n#\n# Example 2:\n# Input: nums = [-1, 1, 0, -3, 3]\n# Output: [0, 0, 9, 0, 0]\n#\n# Constraints:\n#\n# 2 <= nums.length <= 105\n# -30 <= nums[i] <= 30\n# The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n#\n# # Follow up: Can you solve the problem in O(1) extra space\n# complexity? (The output array does not count as extra space for space complexity analysis.)\nclass Solution:\ndef productExceptSelf(self, nums: List[int]) -> List[int]:\nprefix = [0] * len(nums)\npostfix = [0] * len(nums)\nanswer = [0] * len(nums)\ncurr_prod = 1\nfor i, num in enumerate(nums):\ncurr_prod *= num\nprefix[i] = curr_prod\ncurr_prod = 1\nfor i in range(len(nums) - 1, -1, -1):\ncurr_prod *= nums[i]\npostfix[i] = curr_prod\nfor i in range(len(nums)):\nnum1 = 1\nnum2 = 1\nif i - 1 >= 0:\nnum1 *= prefix[i - 1]\nif i + 1 < len(nums):\nnum2 *= postfix[i + 1]\nanswer[i] = num1 * num2\nreturn answer\n",
                        "max_stars_repo_name": "H-isaac23/LeetCode-Challenges",
                        "max_stars_repo_path": "Product of Array except self.py",
                        "max_stars_count": 0,
                        "__cluster__": 335
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_238",
                        "content": "Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.\n**Example 1:**\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** \\[24,12,8,6\\]\n**Example 2:**\n**Input:** nums = \\[-1,1,0,-3,3\\]\n**Output:** \\[0,0,9,0,0\\]\n**Constraints:**\n*   `2 <= nums.length <= 105`\n*   `-30 <= nums[i] <= 30`\n*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n**Follow up:** Can you solve the problem in `O(1)` extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)\nInput:\nnums = \\[1,2,3,4\\]\nOutput:\n\\[24,12,8,6\\]\n```python\ndef productExceptSelf(nums):\nn = len(nums)\nanswer = [1] * n\nleft = 1\nfor i in range(n):\nanswer[i] *= left\nleft *= nums[i]\nright = 1\nfor i in range(n - 1, -1, -1):\nanswer[i] *= right\nright *= nums[i]\nreturn answer\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 335
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_8",
                        "content": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\nThe algorithm for `myAtoi(string s)` is as follows:\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n**Note:**\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n**Example 1:**\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"42 \" ( \"42 \" is read in)\n^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n**Example 2:**\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n**Example 3:**\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193.\n**Constraints:**\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.\nInput:\ns =  \"42 \"\nOutput:\n42\n```python\ndef myAtoi(s):\nresult, i, sign = 0, 0, 1\nwhile i < len(s) and s[i] == ' ': i += 1\nif i < len(s) and (s[i] == '-' or s[i] == '+'):\nsign = -1 if s[i] == '-' else 1\ni += 1\nwhile i < len(s) and s[i].isdigit():\nresult = result * 10 + int(s[i])\ni += 1\nif result * sign > 2**31 - 1: return 2**31 - 1\nif result * sign < -2**31: return -2**31\nreturn result * sign\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 212
                },
                {
                        "id": "pretrain_python_data_3467141",
                        "content": "<reponame>neelaadityakumar/leetcode\n# https: // leetcode.com/problems/string-to-integer-atoi/\n# 8. String to Integer(atoi)\n# Medium\n# 1483\n# 4236\n# Add to List\n# Share\n# Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer(similar to C/C++'s atoi function).\n# The algorithm for myAtoi(string s) is as follows:\n# Read in and ignore any leading whitespace.\n# Check if the next character(if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n# Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n# Convert these digits into an integer(i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary(from step 2).\n# If the integer is out of the 32-bit signed integer range[-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than - 231 should be clamped to - 231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n# Return the integer as the final result.\n# Note:\n# Only the space character ' ' is considered a whitespace character.\n# Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n# Example 1:\n# Input: s = \"42\"\n# Output: 42\n# Explanation: The underlined characters are what is read in, the caret is the current reader position.\n# Step 1: \"42\" (no characters read because there is no leading whitespace)\n# ^\n# Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n# ^\n# Step 3: \"42\" (\"42\" is read in)\n# ^\n# The parsed integer is 42.\n# Since 42 is in the range[-231, 231 - 1], the final result is 42.\n# Example 2:\n# Input: s = \"   -42\"\n# Output: -42\n# Explanation:\n# Step 1: \"   -42\" (leading whitespace is read and ignored)\n# ^\n# Step 2: \"   -42\" ('-' is read, so the result should be negative)\n# ^\n# Step 3: \"   -42\" (\"42\" is read in)\n# ^\n# The parsed integer is -42.\n# Since - 42 is in the range[-231, 231 - 1], the final result is -42.\n# Example 3:\n# Input: s = \"4193 with words\"\n# Output: 4193\n# Explanation:\n# Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n# ^\n# Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n# ^\n# Step 3: \"4193 with words\" (\"4193\" is read in\n#                            reading stops because the next character is a non-digit)\n# ^\n# The parsed integer is 4193.\n# Since 4193 is in the range[-231, 231 - 1], the final result is 4193.\n# Constraints:\n# 0 <= s.length <= 200\n# s consists of English letters(lower-case and upper-case), digits(0-9), ' ', '+', '-', and '.'.",
                        "max_stars_repo_name": "neelaadityakumar/leetcode",
                        "max_stars_repo_path": "Most Asked DSA By Companies/Meta/24-8.py",
                        "max_stars_count": 0,
                        "__cluster__": 212
                },
                {
                        "real_dup": 2
                }
        ],


        [
                {
                        "id": "pretrain_python_data_3524038",
                        "content": "# You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n#\n# On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n#\n# Find and return the maximum profit you can achieve.\n#\n#\n# Example 1:\n#\n#\n# Input: prices = [7,1,5,3,6,4]\n# Output: 7\n# Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n# Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n# Total profit is 4 + 3 = 7.\n#\n#\n# Example 2:\n#\n#\n# Input: prices = [1,2,3,4,5]\n# Output: 4\n# Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n# Total profit is 4.\n#\n#\n# Example 3:\n#\n#\n# Input: prices = [7,6,4,3,1]\n# Output: 0\n# Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n#\n#\n#\n# Constraints:\n#\n#\n# \t1 <= prices.length <= 3 * 104\n# \t0 <= prices[i] <= 104\n#\n#\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\n# Solution: DFS: \u6df1\u5ea6\u4f18\u5148\u641c\u7d22 \u4e70\u5356\u4e24\u79cd\u7ed3\u679c O(2^n)\n# Solution: Greedy \u8d2a\u5fc3\u7b97\u6cd5 O(n)\nif not prices or len(prices) == 1:\nreturn 0\nprofit = 0\nfor i in range(1, len(prices)):\nif prices[i] > prices[i-1]:\nprofit += prices[i] - prices[i-1]\nreturn profit\n# Solution: DP",
                        "max_stars_repo_name": "chyidl/leetcode",
                        "max_stars_repo_path": "0122-best-time-to-buy-and-sell-stock-ii/best-time-to-buy-and-sell-stock-ii.py",
                        "max_stars_count": 2,
                        "__cluster__": 276
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_122",
                        "content": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\nFind and return _the **maximum** profit you can achieve_.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n**Example 2:**\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n**Example 3:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n**Constraints:**\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n7\n```python\ndef max_profit(prices):\nmax_profit = 0\nfor i in range(1, len(prices)):\nif prices[i] > prices[i - 1]:\nmax_profit += prices[i] - prices[i - 1]\nreturn max_profit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 276
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_6743869",
                        "content": "<filename>top_400/dp/139_word_break.py\n'''\nGiven a string s and a dictionary of strings wordDict, return\ntrue if s can be segmented into a space-separated sequence of\none or more dictionary words.\nNote that the same word in the dictionary may be reused\nmultiple times in the segmentation.\nExample 1:\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\nExample 2:\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\nExample 3:\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false\nConstraints:\n1 <= s.length <= 300\n1 <= wordDict.length <= 1000\n1 <= wordDict[i].length <= 20\ns and wordDict[i] consist of only lowercase English letters.\nAll the strings of wordDict are unique.\n'''\nclass Solution:\ndef wordBreak(self, s: str, wordDict: List[str]) -> bool:\ndp = [0 for i in range(len(s))]\nfor i in range(len(s)):\nfor j in range(i):\nif (dp[j] == 1 and s[j+1:i+1] in wordDict):\ndp[i] = 1\nbreak\nif s[:i+1] in wordDict:\ndp[i] = 1\nprint(dp)\nreturn dp[-1] == 1\n",
                        "max_stars_repo_name": "Fernadoo/LeetCode",
                        "max_stars_repo_path": "top_400/dp/139_word_break.py",
                        "max_stars_count": 0,
                        "__cluster__": 108
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_139",
                        "content": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n**Example 1:**\n**Input:** s =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\n**Output:** true\n**Explanation:** Return true because  \"leetcode \" can be segmented as  \"leet code \".\n**Example 2:**\n**Input:** s =  \"applepenapple \", wordDict = \\[ \"apple \", \"pen \"\\]\n**Output:** true\n**Explanation:** Return true because  \"applepenapple \" can be segmented as  \"apple pen apple \".\nNote that you are allowed to reuse a dictionary word.\n**Example 3:**\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** false\n**Constraints:**\n*   `1 <= s.length <= 300`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 20`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.\nInput:\ns =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\nOutput:\ntrue\n```python\ndef word_break(s, word_dict):\nword_set = set(word_dict)\ndp = [False] * (len(s) + 1)\ndp[0] = True\nfor i in range(1, len(s) + 1):\nfor j in range(i):\nif dp[j] and s[j:i] in word_set:\ndp[i] = True\nbreak\nreturn dp[len(s)]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 108
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_1123",
                        "content": "Given the `root` of a binary tree, return _the lowest common ancestor of its deepest leaves_.\nRecall that:\n*   The node of a binary tree is a leaf if and only if it has no children\n*   The depth of the root of the tree is `0`. if the depth of a node is `d`, the depth of each of its children is `d + 1`.\n*   The lowest common ancestor of a set `S` of nodes, is the node `A` with the largest depth such that every node in `S` is in the subtree with root `A`.\n**Example 1:**\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\]\n**Output:** \\[2,7,4\\]\n**Explanation:** We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest leaf-nodes of the tree.\nNote that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.\n**Example 2:**\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n**Explanation:** The root is the deepest node in the tree, and it's the lca of itself.\n**Example 3:**\n**Input:** root = \\[0,1,3,null,2\\]\n**Output:** \\[2\\]\n**Explanation:** The deepest leaf node in the tree is 2, the lca of one node is itself.\n**Constraints:**\n*   The number of nodes in the tree will be in the range `[1, 1000]`.\n*   `0 <= Node.val <= 1000`\n*   The values of the nodes in the tree are **unique**.\n**Note:** This question is the same as 865: [https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/)\nInput:\nroot = \\[3,5,1,6,2,0,8,null,null,7,4\\]\nOutput:\n\\[2,7,4\\]\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef find_lca_util(root):\nif root is None:\nreturn None, 0\nleft_lca, left_depth = find_lca_util(root.left)\nright_lca, right_depth = find_lca_util(root.right)\nif left_depth > right_depth:\nreturn left_lca, left_depth + 1\nelif left_depth < right_depth:\nreturn right_lca, right_depth + 1\nelse:\nreturn root, left_depth + 1\ndef lca_deepest_leaves(root):\nreturn find_lca_util(root)[0]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 31
                },
                {
                        "id": "pretrain_python_data_9997571",
                        "content": "<gh_stars>100-1000\n\"\"\"\nGiven the root of a\u00a0binary tree, return the lowest common ancestor of its deepest leaves.\nRecall that:\nThe node of a binary tree is a leaf if and only if it has no children\nThe depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children\u00a0is\u00a0d + 1.\nThe lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.\nNote: This question is the same as 865: https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4]\nOutput: [2,7,4]\nExplanation: We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest leaf-nodes of the tree.\nNote that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.\nExample 2:\nInput: root = [1]\nOutput: [1]\nExplanation: The root is the deepest node in the tree, and it's the lca of itself.\nExample 3:\nInput: root = [0,1,3,null,2]\nOutput: [2]\nExplanation: The deepest leaf node in the tree is 2, the lca of one node is itself.\nConstraints:\nThe number of nodes in the tree will be in the range [1, 1000].\n0 <= Node.val <= 1000\nThe values of the nodes in the tree\u00a0are unique.\n\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\ndef subtree_with_deepest(node):\nif node is None:\nreturn node, 0\nlt, ll = subtree_with_deepest(node.left)\nrt, rl = subtree_with_deepest(node.right)\nif ll == rl:\nreturn node, ll + 1\nelif ll > rl:\nreturn lt, ll + 1\nelse:\nreturn rt, rl + 1\nreturn subtree_with_deepest(root)[0]\n",
                        "max_stars_repo_name": "marcus-aurelianus/leetcode-solutions",
                        "max_stars_repo_path": "questions/lowest-common-ancestor-of-deepest-leaves/Solution.py",
                        "max_stars_count": 141,
                        "__cluster__": 31
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_1123",
                        "content": "Given the `root` of a binary tree, return _the lowest common ancestor of its deepest leaves_.\nRecall that:\n*   The node of a binary tree is a leaf if and only if it has no children\n*   The depth of the root of the tree is `0`. if the depth of a node is `d`, the depth of each of its children is `d + 1`.\n*   The lowest common ancestor of a set `S` of nodes, is the node `A` with the largest depth such that every node in `S` is in the subtree with root `A`.\n**Example 1:**\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\]\n**Output:** \\[2,7,4\\]\n**Explanation:** We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest leaf-nodes of the tree.\nNote that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.\n**Example 2:**\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n**Explanation:** The root is the deepest node in the tree, and it's the lca of itself.\n**Example 3:**\n**Input:** root = \\[0,1,3,null,2\\]\n**Output:** \\[2\\]\n**Explanation:** The deepest leaf node in the tree is 2, the lca of one node is itself.\n**Constraints:**\n*   The number of nodes in the tree will be in the range `[1, 1000]`.\n*   `0 <= Node.val <= 1000`\n*   The values of the nodes in the tree are **unique**.\n**Note:** This question is the same as 865: [https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/)\nInput:\nroot = \\[3,5,1,6,2,0,8,null,null,7,4\\]\nOutput:\n\\[2,7,4\\]\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef find_lca_util(root):\nif root is None:\nreturn None, 0\nleft_lca, left_depth = find_lca_util(root.left)\nright_lca, right_depth = find_lca_util(root.right)\nif left_depth > right_depth:\nreturn left_lca, left_depth + 1\nelif left_depth < right_depth:\nreturn right_lca, right_depth + 1\nelse:\nreturn root, left_depth + 1\ndef lca_deepest_leaves(root):\nreturn find_lca_util(root)[0]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 31
                },
                {
                        "id": "pretrain_python_data_9997571",
                        "content": "<gh_stars>100-1000\n\"\"\"\nGiven the root of a\u00a0binary tree, return the lowest common ancestor of its deepest leaves.\nRecall that:\nThe node of a binary tree is a leaf if and only if it has no children\nThe depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children\u00a0is\u00a0d + 1.\nThe lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.\nNote: This question is the same as 865: https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4]\nOutput: [2,7,4]\nExplanation: We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest leaf-nodes of the tree.\nNote that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.\nExample 2:\nInput: root = [1]\nOutput: [1]\nExplanation: The root is the deepest node in the tree, and it's the lca of itself.\nExample 3:\nInput: root = [0,1,3,null,2]\nOutput: [2]\nExplanation: The deepest leaf node in the tree is 2, the lca of one node is itself.\nConstraints:\nThe number of nodes in the tree will be in the range [1, 1000].\n0 <= Node.val <= 1000\nThe values of the nodes in the tree\u00a0are unique.\n\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\ndef subtree_with_deepest(node):\nif node is None:\nreturn node, 0\nlt, ll = subtree_with_deepest(node.left)\nrt, rl = subtree_with_deepest(node.right)\nif ll == rl:\nreturn node, ll + 1\nelif ll > rl:\nreturn lt, ll + 1\nelse:\nreturn rt, rl + 1\nreturn subtree_with_deepest(root)[0]\n",
                        "max_stars_repo_name": "marcus-aurelianus/leetcode-solutions",
                        "max_stars_repo_path": "questions/lowest-common-ancestor-of-deepest-leaves/Solution.py",
                        "max_stars_count": 141,
                        "__cluster__": 31
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_11441905",
                        "content": "<reponame>chyidl/leetcode<gh_stars>1-10\n# You are given an array prices where prices[i] is the price of a given stock on the ith day.\n#\n# You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n#\n# Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n#\n#\n# Example 1:\n#\n#\n# Input: prices = [7,1,5,3,6,4]\n# Output: 5\n# Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n# Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n#\n#\n# Example 2:\n#\n#\n# Input: prices = [7,6,4,3,1]\n# Output: 0\n# Explanation: In this case, no transactions are done and the max profit = 0.\n#\n#\n#\n# Constraints:\n#\n#\n# \t1 <= prices.length <= 105\n# \t0 <= prices[i] <= 104\n#\n#\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nmax_profit, min_price = 0, float('inf')\nfor price in prices:\nmin_price = min(min_price, price)\nprofit = price - min_price\nmax_profit = max(max_profit, profit)\nreturn max_profit",
                        "max_stars_repo_name": "chyidl/leetcode",
                        "max_stars_repo_path": "0121-best-time-to-buy-and-sell-stock/best-time-to-buy-and-sell-stock.py",
                        "max_stars_count": 2,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_11441905",
                        "content": "<reponame>chyidl/leetcode<gh_stars>1-10\n# You are given an array prices where prices[i] is the price of a given stock on the ith day.\n#\n# You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n#\n# Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n#\n#\n# Example 1:\n#\n#\n# Input: prices = [7,1,5,3,6,4]\n# Output: 5\n# Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n# Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n#\n#\n# Example 2:\n#\n#\n# Input: prices = [7,6,4,3,1]\n# Output: 0\n# Explanation: In this case, no transactions are done and the max profit = 0.\n#\n#\n#\n# Constraints:\n#\n#\n# \t1 <= prices.length <= 105\n# \t0 <= prices[i] <= 104\n#\n#\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nmax_profit, min_price = 0, float('inf')\nfor price in prices:\nmin_price = min(min_price, price)\nprofit = price - min_price\nmax_profit = max(max_profit, profit)\nreturn max_profit",
                        "max_stars_repo_name": "chyidl/leetcode",
                        "max_stars_repo_path": "0121-best-time-to-buy-and-sell-stock/best-time-to-buy-and-sell-stock.py",
                        "max_stars_count": 2,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_11441905",
                        "content": "<reponame>chyidl/leetcode<gh_stars>1-10\n# You are given an array prices where prices[i] is the price of a given stock on the ith day.\n#\n# You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n#\n# Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n#\n#\n# Example 1:\n#\n#\n# Input: prices = [7,1,5,3,6,4]\n# Output: 5\n# Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n# Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n#\n#\n# Example 2:\n#\n#\n# Input: prices = [7,6,4,3,1]\n# Output: 0\n# Explanation: In this case, no transactions are done and the max profit = 0.\n#\n#\n#\n# Constraints:\n#\n#\n# \t1 <= prices.length <= 105\n# \t0 <= prices[i] <= 104\n#\n#\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nmax_profit, min_price = 0, float('inf')\nfor price in prices:\nmin_price = min(min_price, price)\nprofit = price - min_price\nmax_profit = max(max_profit, profit)\nreturn max_profit",
                        "max_stars_repo_name": "chyidl/leetcode",
                        "max_stars_repo_path": "0121-best-time-to-buy-and-sell-stock/best-time-to-buy-and-sell-stock.py",
                        "max_stars_count": 2,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_11441905",
                        "content": "<reponame>chyidl/leetcode<gh_stars>1-10\n# You are given an array prices where prices[i] is the price of a given stock on the ith day.\n#\n# You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n#\n# Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n#\n#\n# Example 1:\n#\n#\n# Input: prices = [7,1,5,3,6,4]\n# Output: 5\n# Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n# Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n#\n#\n# Example 2:\n#\n#\n# Input: prices = [7,6,4,3,1]\n# Output: 0\n# Explanation: In this case, no transactions are done and the max profit = 0.\n#\n#\n#\n# Constraints:\n#\n#\n# \t1 <= prices.length <= 105\n# \t0 <= prices[i] <= 104\n#\n#\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nmax_profit, min_price = 0, float('inf')\nfor price in prices:\nmin_price = min(min_price, price)\nprofit = price - min_price\nmax_profit = max(max_profit, profit)\nreturn max_profit",
                        "max_stars_repo_name": "chyidl/leetcode",
                        "max_stars_repo_path": "0121-best-time-to-buy-and-sell-stock/best-time-to-buy-and-sell-stock.py",
                        "max_stars_count": 2,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_425457",
                        "content": "'''\nThere are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.\nNote:\nAll costs are positive integers.\nExample:\nInput: [[1,5,3],[2,9,4]]\nOutput: 5\nExplanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5;\nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.\nFollow up:\nCould you solve it in O(nk) runtime?\n'''\nclass Solution(object):\ndef minCostII(self, costs):\n\"\"\"\n:type costs: List[List[int]]\n:rtype: int\n\"\"\"\nif not costs:\nreturn 0\ndp = [[float('inf') for j in xrange(len(costs[i]))] for i in xrange(len(costs))]\nfor j in xrange(len(costs[0])):\ndp[0][j] = costs[0][j]\nfor i in xrange(1, len(costs)):\nfor j in xrange(len(costs[i])):\nfor k in xrange(len(costs[i-1])):\nif j == k:\ncontinue\ndp[i][j] = min(dp[i][j], costs[i][j] + dp[i-1][k])\nreturn min(dp[-1])",
                        "max_stars_repo_name": "sugia/leetcode",
                        "max_stars_repo_path": "Paint House II.py",
                        "max_stars_count": 0,
                        "__cluster__": 359
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_265",
                        "content": "There are a row of `n` houses, each house can be painted with one of the `k` colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an `n x k` cost matrix costs.\n*   For example, `costs[0][0]` is the cost of painting house `0` with color `0`; `costs[1][2]` is the cost of painting house `1` with color `2`, and so on...\nReturn _the minimum cost to paint all houses_.\n**Example 1:**\n**Input:** costs = \\[\\[1,5,3\\],\\[2,9,4\\]\\]\n**Output:** 5\n**Explanation:**\nPaint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5;\nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.\n**Example 2:**\n**Input:** costs = \\[\\[1,3\\],\\[2,4\\]\\]\n**Output:** 5\n**Constraints:**\n*   `costs.length == n`\n*   `costs[i].length == k`\n*   `1 <= n <= 100`\n*   `2 <= k <= 20`\n*   `1 <= costs[i][j] <= 20`\n**Follow up:** Could you solve it in `O(nk)` runtime?\nInput:\ncosts = \\[\\[1,5,3\\],\\[2,9,4\\]\\]\nOutput:\n5\n```python\ndef min_cost(costs: List[List[int]]) -> int:\nif not costs:\nreturn 0\nn, k = len(costs), len(costs[0])\nfor i in range(1, n):\nfor j in range(k):\nmin_cost = float(\"inf\")\nfor l in range(k):\nif l == j:\ncontinue\nmin_cost = min(min_cost, costs[i - 1][l])\ncosts[i][j] += min_cost\nreturn min(costs[n - 1])\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 359
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_136",
                        "content": "Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n**Example 1:**\n**Input:** nums = \\[2,2,1\\]\n**Output:** 1\n**Example 2:**\n**Input:** nums = \\[4,1,2,1,2\\]\n**Output:** 4\n**Example 3:**\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Constraints:**\n*   `1 <= nums.length <= 3 * 104`\n*   `-3 * 104 <= nums[i] <= 3 * 104`\n*   Each element in the array appears twice except for one element which appears only once.\nInput:\nnums = \\[2,2,1\\]\nOutput:\n1\n```python\ndef singleNumber(nums):\nresult = 0\nfor num in nums:\nresult ^= num\nreturn result\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 284
                },
                {
                        "id": "pretrain_python_data_505396",
                        "content": "# Given a non-empty array of integers nums, every element appears twice except\n# for one. Find that single one.\n# You must implement a solution with a linear runtime complexity and use only\n# constant extra space.\n# Example 1:\n#   Input: nums = [2,2,1]\n#   Output: 1\n# Example 2:\n#   Input: nums = [4,1,2,1,2]\n#   Output: 4\n# Example 3:\n#   Input: nums = [1]\n#   Output: 1\n# Constraints:\n#   1 <= nums.length <= 3 * 10^4\n#   -3 * 10^4 <= nums[i] <= 3 * 10^4\n#   Each element in the array appears twice except for one element which appears only once.\nfrom typing import List\nclass BitSolution:\ndef singleNumber(self, nums: List[int]) -> int:\nresult = 0\nfor n in nums:\nresult ^= n\nreturn result\n",
                        "max_stars_repo_name": "vilisimo/ads",
                        "max_stars_repo_path": "python/leetcode/easy/ex0136.py",
                        "max_stars_count": 0,
                        "__cluster__": 284
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_256",
                        "content": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\nReturn _the minimum cost to paint all houses_.\n**Example 1:**\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n**Example 2:**\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2\n**Constraints:**\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`\nInput:\ncosts = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\nOutput:\n10\n```python\ndef minCost(costs: List[List[int]]) -> int:\nif not costs:\nreturn 0\nfor i in range(1, len(costs)):\ncosts[i][0] += min(costs[i - 1][1], costs[i - 1][2])\ncosts[i][1] += min(costs[i - 1][0], costs[i - 1][2])\ncosts[i][2] += min(costs[i - 1][0], costs[i - 1][1])\nreturn min(costs[-1][0], costs[-1][1], costs[-1][2])\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 350
                },
                {
                        "id": "pretrain_python_data_432007",
                        "content": "\"\"\"\nPaint House\nhttps://leetcode.com/problems/paint-house/\nThere is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.\nFor example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on...\nReturn the minimum cost to paint all houses.\nExample 1:\nInput: costs = [[17,2,17],[16,16,5],[14,3,19]]\nOutput: 10\nExplanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\nExample 2:\nInput: costs = [[7,6,2]]\nOutput: 2\nConstraints:\ncosts.length == n\ncosts[i].length == 3\n1 <= n <= 100\n1 <= costs[i][j] <= 20\n\"\"\"\nclass Solution:\ndef minCost(self, costs: List[List[int]]) -> int:\nprev = [0] * 3\nfor now in costs:\nprev = [now[i] + min(prev[:i] + prev[i + 1:]) for i in range(3)]\nreturn min(prev)\nclass Solution2:\ndef minCost(self, costs: List[List[int]]) -> int:\nn = len(costs)\nk = len(costs[0])\nprev_row = costs[0]\nfor house in range(1, n):\ncur_row = [0] * k\nfor cur_color in range(k):\nprev_best = math.inf\nfor prev_color in range(k):\nif cur_color == prev_color:\ncontinue\nprev_best = min(prev_best, prev_row[prev_color])\ncur_row[cur_color] += prev_best + costs[house][cur_color]\nprev_row = cur_row\nreturn min(prev_row)",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_repo_path": "leetcode/problems/medium/256-paint-house.py",
                        "max_stars_count": 18,
                        "__cluster__": 350
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_122",
                        "content": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\nFind and return _the **maximum** profit you can achieve_.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n**Example 2:**\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n**Example 3:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n**Constraints:**\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n7\n```python\ndef max_profit(prices):\nmax_profit = 0\nfor i in range(1, len(prices)):\nif prices[i] > prices[i - 1]:\nmax_profit += prices[i] - prices[i - 1]\nreturn max_profit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 276
                },
                {
                        "id": "pretrain_python_data_3708965",
                        "content": "<reponame>s2503901ernie/LeetCode<gh_stars>0\n\"\"\"\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nExample 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\nExample 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\nConstraints:\n1 <= prices.length <= 3 * 10^4\n0 <= prices[i] <= 10^4\n\"\"\"\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nif len(prices) == 1:\nreturn 0\nprevious = prices[0]\nprofit = 0\nfor price in prices[1:]:\nif price > previous:\nprofit += price - previous\nprevious = price\nelse:\nprevious = price\nreturn profit",
                        "max_stars_repo_name": "s2503901ernie/LeetCode",
                        "max_stars_repo_path": "Problems/Array/0122-BestTimeToBuyAndSellStockII.py",
                        "max_stars_count": 0,
                        "__cluster__": 276
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_5388920",
                        "content": "\"\"\"\n190. Reverse Bits\nReverse bits of a given 32 bits unsigned integer.\nNote:\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\nIn Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.\nExample 1:\nInput: n = 00000010100101000001111010011100\nOutput:    964176192 (00111001011110000010100101000000)\nExplanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.\nExample 2:\nInput: n = 11111111111111111111111111111101\nOutput:   3221225471 (10111111111111111111111111111111)\nExplanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.\nConstraints:\nThe input must be a binary string of length 32\nFollow up: If this function is called many times, how would you optimize it?\n\u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09\n\u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/reverse-bits\n\u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002\n\"\"\"\nclass Solution:\ndef reverseBits(self, n: int) -> int:\nans = 0\nfor i in range(32):\nans |= (n & 1) << (31 - i)\nn >>= 1\nreturn ans\nif __name__ == \"__main__\":\nsol = Solution()\nn = \"00000010100101000001111010011100\"\nprint(\"Input: n =\", n)\nprint(\"Output:\", sol.reverseBits(int(n, 2)))\nn = \"11111111111111111111111111111101\"\nprint(\"Input: n =\", n)\nprint(\"Output:\", sol.reverseBits(int(n, 2)))",
                        "max_stars_repo_name": "lim1202/LeetCodeProblems",
                        "max_stars_repo_path": "solutions/190.reverseBits.py",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_190",
                        "content": "Reverse bits of a given 32 bits unsigned integer.\n**Note:**\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.\n**Example 1:**\n**Input:** n = 00000010100101000001111010011100\n**Output:**    964176192 (00111001011110000010100101000000)\n**Explanation:** The input binary string **00000010100101000001111010011100** represents the unsigned integer 43261596, so return 964176192 which its binary representation is **00111001011110000010100101000000**.\n**Example 2:**\n**Input:** n = 11111111111111111111111111111101\n**Output:**   3221225471 (10111111111111111111111111111111)\n**Explanation:** The input binary string **11111111111111111111111111111101** represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is **10111111111111111111111111111111**.\n**Constraints:**\n*   The input must be a **binary string** of length `32`\n**Follow up:** If this function is called many times, how would you optimize it?\nInput:\nn = 00000010100101000001111010011100\nOutput:\n964176192 (00111001011110000010100101000000)\n```python\ndef reverse_bits(n: int) -> int:\nres = 0\nfor _ in range(32):\nres <<= 1\nres |= n & 1\nn >>= 1\nreturn res\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```python\ndef rob(nums):\nif len(nums) == 1:\nreturn nums[0]\nprev, curr = 0, 0\nfor i in range(len(nums) - 1):\ntemp = max(curr, prev + nums[i])\nprev, curr = curr, temp\nres = curr\nprev, curr = 0, 0\nfor i in range(1, len(nums)):\ntemp = max(curr, prev + nums[i])\nprev, curr = curr, temp\nreturn max(res, curr)\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 313
                },
                {
                        "id": "pretrain_python_data_11600874",
                        "content": "'''\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed.\nAll houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile,\nadjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [0]\nOutput: 0\n'''\nclass Solution(object):\ndef rob(self, nums):\nif len(nums) == 1:\nreturn nums[0]\nelif len(nums) == 2:\nreturn max(nums[0], nums[1])\nelse:\nprev, curr = nums[0], max(nums[0], nums[1])\nfor elem in range(2, len(nums) - 1):\nprev, curr = curr, max(nums[elem] + prev, curr)\nmax_num = curr\nprev, curr = 0, nums[1]\nfor elem in range(2, len(nums)):\nprev, curr = curr, max(nums[elem] + prev, curr)\nreturn max(max_num, curr)\n",
                        "max_stars_repo_name": "ojhaanshu87/LeetCode",
                        "max_stars_repo_path": "213_house_robber_circle.py",
                        "max_stars_count": 0,
                        "__cluster__": 313
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```python\ndef rob(nums):\nif len(nums) == 1:\nreturn nums[0]\nprev, curr = 0, 0\nfor i in range(len(nums) - 1):\ntemp = max(curr, prev + nums[i])\nprev, curr = curr, temp\nres = curr\nprev, curr = 0, 0\nfor i in range(1, len(nums)):\ntemp = max(curr, prev + nums[i])\nprev, curr = curr, temp\nreturn max(res, curr)\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 313
                },
                {
                        "id": "pretrain_python_data_11600874",
                        "content": "'''\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed.\nAll houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile,\nadjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [0]\nOutput: 0\n'''\nclass Solution(object):\ndef rob(self, nums):\nif len(nums) == 1:\nreturn nums[0]\nelif len(nums) == 2:\nreturn max(nums[0], nums[1])\nelse:\nprev, curr = nums[0], max(nums[0], nums[1])\nfor elem in range(2, len(nums) - 1):\nprev, curr = curr, max(nums[elem] + prev, curr)\nmax_num = curr\nprev, curr = 0, nums[1]\nfor elem in range(2, len(nums)):\nprev, curr = curr, max(nums[elem] + prev, curr)\nreturn max(max_num, curr)\n",
                        "max_stars_repo_name": "ojhaanshu87/LeetCode",
                        "max_stars_repo_path": "213_house_robber_circle.py",
                        "max_stars_count": 0,
                        "__cluster__": 313
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```python\ndef rob(nums):\nif len(nums) == 1:\nreturn nums[0]\nprev, curr = 0, 0\nfor i in range(len(nums) - 1):\ntemp = max(curr, prev + nums[i])\nprev, curr = curr, temp\nres = curr\nprev, curr = 0, 0\nfor i in range(1, len(nums)):\ntemp = max(curr, prev + nums[i])\nprev, curr = curr, temp\nreturn max(res, curr)\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 313
                },
                {
                        "id": "pretrain_python_data_11600874",
                        "content": "'''\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed.\nAll houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile,\nadjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [0]\nOutput: 0\n'''\nclass Solution(object):\ndef rob(self, nums):\nif len(nums) == 1:\nreturn nums[0]\nelif len(nums) == 2:\nreturn max(nums[0], nums[1])\nelse:\nprev, curr = nums[0], max(nums[0], nums[1])\nfor elem in range(2, len(nums) - 1):\nprev, curr = curr, max(nums[elem] + prev, curr)\nmax_num = curr\nprev, curr = 0, nums[1]\nfor elem in range(2, len(nums)):\nprev, curr = curr, max(nums[elem] + prev, curr)\nreturn max(max_num, curr)\n",
                        "max_stars_repo_name": "ojhaanshu87/LeetCode",
                        "max_stars_repo_path": "213_house_robber_circle.py",
                        "max_stars_count": 0,
                        "__cluster__": 313
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```python\ndef rob(nums):\nif len(nums) == 1:\nreturn nums[0]\nprev, curr = 0, 0\nfor i in range(len(nums) - 1):\ntemp = max(curr, prev + nums[i])\nprev, curr = curr, temp\nres = curr\nprev, curr = 0, 0\nfor i in range(1, len(nums)):\ntemp = max(curr, prev + nums[i])\nprev, curr = curr, temp\nreturn max(res, curr)\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 313
                },
                {
                        "id": "pretrain_python_data_11600874",
                        "content": "'''\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed.\nAll houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile,\nadjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [0]\nOutput: 0\n'''\nclass Solution(object):\ndef rob(self, nums):\nif len(nums) == 1:\nreturn nums[0]\nelif len(nums) == 2:\nreturn max(nums[0], nums[1])\nelse:\nprev, curr = nums[0], max(nums[0], nums[1])\nfor elem in range(2, len(nums) - 1):\nprev, curr = curr, max(nums[elem] + prev, curr)\nmax_num = curr\nprev, curr = 0, nums[1]\nfor elem in range(2, len(nums)):\nprev, curr = curr, max(nums[elem] + prev, curr)\nreturn max(max_num, curr)\n",
                        "max_stars_repo_name": "ojhaanshu87/LeetCode",
                        "max_stars_repo_path": "213_house_robber_circle.py",
                        "max_stars_count": 0,
                        "__cluster__": 313
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_509",
                        "content": "The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\nGiven `n`, calculate `F(n)`.\n**Example 1:**\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.\n**Example 2:**\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.\n**Example 3:**\n**Input:** n = 4\n**Output:** 3\n**Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3.\n**Constraints:**\n*   `0 <= n <= 30`\nInput:\nn = 2\nOutput:\n1\n```python\ndef fib(n: int) -> int:\nif n < 2:\nreturn n\na, b = 0, 1\nfor _ in range(2, n + 1):\na, b = b, a + b\nreturn b\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 424
                },
                {
                        "id": "pretrain_python_data_2269932",
                        "content": "# Fibonacci Number\n'''\nThe Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\nGiven n, calculate F(n).\nExample 1:\nInput: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\nExample 2:\nInput: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\nExample 3:\nInput: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\nConstraints:\n0 <= n <= 30\n'''\nclass Solution:\ndef fib(self, n: int) -> int:\nif n < 2:\nreturn n\nelse:\nreturn self.fib(n-1)+self.fib(n-2)",
                        "max_stars_repo_name": "vinaykumar7686/Leetcode-August_Challenge",
                        "max_stars_repo_path": "April/Week3/Fibonacci Number.py",
                        "max_stars_count": 1,
                        "__cluster__": 424
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_509",
                        "content": "The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\nGiven `n`, calculate `F(n)`.\n**Example 1:**\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.\n**Example 2:**\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.\n**Example 3:**\n**Input:** n = 4\n**Output:** 3\n**Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3.\n**Constraints:**\n*   `0 <= n <= 30`\nInput:\nn = 2\nOutput:\n1\n```python\ndef fib(n: int) -> int:\nif n < 2:\nreturn n\na, b = 0, 1\nfor _ in range(2, n + 1):\na, b = b, a + b\nreturn b\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 424
                },
                {
                        "id": "pretrain_python_data_2269932",
                        "content": "# Fibonacci Number\n'''\nThe Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\nGiven n, calculate F(n).\nExample 1:\nInput: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\nExample 2:\nInput: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\nExample 3:\nInput: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\nConstraints:\n0 <= n <= 30\n'''\nclass Solution:\ndef fib(self, n: int) -> int:\nif n < 2:\nreturn n\nelse:\nreturn self.fib(n-1)+self.fib(n-2)",
                        "max_stars_repo_name": "vinaykumar7686/Leetcode-August_Challenge",
                        "max_stars_repo_path": "April/Week3/Fibonacci Number.py",
                        "max_stars_count": 1,
                        "__cluster__": 424
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_1",
                        "content": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\nYou can return the answer in any order.\n**Example 1:**\n**Input:** nums = \\[2,7,11,15\\], target = 9\n**Output:** \\[0,1\\]\n**Explanation:** Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\].\n**Example 2:**\n**Input:** nums = \\[3,2,4\\], target = 6\n**Output:** \\[1,2\\]\n**Example 3:**\n**Input:** nums = \\[3,3\\], target = 6\n**Output:** \\[0,1\\]\n**Constraints:**\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?\nInput:\nnums = \\[2,7,11,15\\], target = 9\nOutput:\n\\[0,1\\]\n```python\ndef twoSum(nums, target):\nmap = {}\nfor i, num in enumerate(nums):\ncomplement = target - num\nif complement in map:\nreturn [map[complement], i]\nmap[num] = i\nreturn []\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 203
                },
                {
                        "id": "pretrain_python_data_3842462",
                        "content": "<reponame>philip-bbaale/Algorithms\n\"\"\"\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nOutput: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\nConstraints:\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\n\"\"\"\nclass Solution:\ndef twoSum(self, nums, target):\n# for first_number in range(len(nums)):\n#     for second_number in range(first_number+1 ,len(nums)):\n#         if nums[first_number] + nums[second_number] == target:\n#             return([first_number,second_number])\n# return(\"NO numbers match\")\nseen = {}\nfor index, num in enumerate(nums):\npartner = target - num\nif seen.get(partner) is not None:\nreturn [seen.get(partner), index]\nelse:\nseen[num] = index",
                        "max_stars_repo_name": "philip-bbaale/Algorithms",
                        "max_stars_repo_path": "two_sum.py",
                        "max_stars_count": 0,
                        "__cluster__": 203
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_1",
                        "content": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\nYou can return the answer in any order.\n**Example 1:**\n**Input:** nums = \\[2,7,11,15\\], target = 9\n**Output:** \\[0,1\\]\n**Explanation:** Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\].\n**Example 2:**\n**Input:** nums = \\[3,2,4\\], target = 6\n**Output:** \\[1,2\\]\n**Example 3:**\n**Input:** nums = \\[3,3\\], target = 6\n**Output:** \\[0,1\\]\n**Constraints:**\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?\nInput:\nnums = \\[2,7,11,15\\], target = 9\nOutput:\n\\[0,1\\]\n```python\ndef twoSum(nums, target):\nmap = {}\nfor i, num in enumerate(nums):\ncomplement = target - num\nif complement in map:\nreturn [map[complement], i]\nmap[num] = i\nreturn []\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 203
                },
                {
                        "id": "pretrain_python_data_3842462",
                        "content": "<reponame>philip-bbaale/Algorithms\n\"\"\"\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nOutput: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\nConstraints:\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\n\"\"\"\nclass Solution:\ndef twoSum(self, nums, target):\n# for first_number in range(len(nums)):\n#     for second_number in range(first_number+1 ,len(nums)):\n#         if nums[first_number] + nums[second_number] == target:\n#             return([first_number,second_number])\n# return(\"NO numbers match\")\nseen = {}\nfor index, num in enumerate(nums):\npartner = target - num\nif seen.get(partner) is not None:\nreturn [seen.get(partner), index]\nelse:\nseen[num] = index",
                        "max_stars_repo_name": "philip-bbaale/Algorithms",
                        "max_stars_repo_path": "two_sum.py",
                        "max_stars_count": 0,
                        "__cluster__": 203
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_3850947",
                        "content": "<filename>top_400/dp/64_minimum_path_sum.py\n\"\"\"\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample 1:\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\nExample 2:\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\n0 <= grid[i][j] <= 100\n\"\"\"\nclass Solution:\ndef minPathSum(self, grid: List[List[int]]) -> int:\nm, n = len(grid), len(grid[0])\ndp = [[0 for i in range(n)] for j in range(m)]\ndp[0][0] = grid[0][0]\nfor j in range(1, n):\ndp[0][j] = dp[0][j-1] + grid[0][j]\nfor i in range(1, m):\ndp[i][0] = dp[i-1][0] + grid[i][0]\nfor i in range(1, m):\nfor j in range(1, n):\ndp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\nreturn dp[-1][-1]",
                        "max_stars_repo_name": "Fernadoo/LeetCode",
                        "max_stars_repo_path": "top_400/dp/64_minimum_path_sum.py",
                        "max_stars_count": 0,
                        "__cluster__": 238
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```python\ndef minPathSum(grid):\nm, n = len(grid), len(grid[0])\nfor i in range(1, m):\ngrid[i][0] += grid[i - 1][0]\nfor i in range(1, n):\ngrid[0][i] += grid[0][i - 1]\nfor i in range(1, m):\nfor j in range(1, n):\ngrid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\nreturn grid[m - 1][n - 1]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 238
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_7192534",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode(object):\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution(object):\ndef add_two_numbers(self, l1, l2):\n\"\"\"\n:type l1: ListNode\n:type l2: ListNode\n:rtype: ListNode\n\"\"\"\nresult = ListNode()\ncur = result\ncarry = 0\nwhile l1 or l2 or carry:\nv1 = l1.val if l1 else 0\nv2 = l2.val if l2 else 0\n# new digit\nval = v1 + v2 + carry\ncarry = val // 10\nval = val % 10\ncur.next = ListNode(val)\n# update pointers\ncur = cur.next\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nreturn result.next",
                        "max_stars_repo_name": "zmeeust/leetcode",
                        "max_stars_repo_path": "algorithms/0002_add_two_numbers.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_7192534",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode(object):\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution(object):\ndef add_two_numbers(self, l1, l2):\n\"\"\"\n:type l1: ListNode\n:type l2: ListNode\n:rtype: ListNode\n\"\"\"\nresult = ListNode()\ncur = result\ncarry = 0\nwhile l1 or l2 or carry:\nv1 = l1.val if l1 else 0\nv2 = l2.val if l2 else 0\n# new digit\nval = v1 + v2 + carry\ncarry = val // 10\nval = val % 10\ncur.next = ListNode(val)\n# update pointers\ncur = cur.next\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nreturn result.next",
                        "max_stars_repo_name": "zmeeust/leetcode",
                        "max_stars_repo_path": "algorithms/0002_add_two_numbers.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_7192534",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode(object):\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution(object):\ndef add_two_numbers(self, l1, l2):\n\"\"\"\n:type l1: ListNode\n:type l2: ListNode\n:rtype: ListNode\n\"\"\"\nresult = ListNode()\ncur = result\ncarry = 0\nwhile l1 or l2 or carry:\nv1 = l1.val if l1 else 0\nv2 = l2.val if l2 else 0\n# new digit\nval = v1 + v2 + carry\ncarry = val // 10\nval = val % 10\ncur.next = ListNode(val)\n# update pointers\ncur = cur.next\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nreturn result.next",
                        "max_stars_repo_name": "zmeeust/leetcode",
                        "max_stars_repo_path": "algorithms/0002_add_two_numbers.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_7192534",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode(object):\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution(object):\ndef add_two_numbers(self, l1, l2):\n\"\"\"\n:type l1: ListNode\n:type l2: ListNode\n:rtype: ListNode\n\"\"\"\nresult = ListNode()\ncur = result\ncarry = 0\nwhile l1 or l2 or carry:\nv1 = l1.val if l1 else 0\nv2 = l2.val if l2 else 0\n# new digit\nval = v1 + v2 + carry\ncarry = val // 10\nval = val % 10\ncur.next = ListNode(val)\n# update pointers\ncur = cur.next\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nreturn result.next",
                        "max_stars_repo_name": "zmeeust/leetcode",
                        "max_stars_repo_path": "algorithms/0002_add_two_numbers.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_147",
                        "content": "Given the `head` of a singly linked list, sort the list using **insertion sort**, and return _the sorted list's head_.\nThe steps of the **insertion sort** algorithm:\n1.  Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.\n2.  At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.\n3.  It repeats until no input elements remain.\nThe following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\n**Example 1:**\n**Input:** head = \\[4,2,1,3\\]\n**Output:** \\[1,2,3,4\\]\n**Example 2:**\n**Input:** head = \\[-1,5,3,4,0\\]\n**Output:** \\[-1,0,3,4,5\\]\n**Constraints:**\n*   The number of nodes in the list is in the range `[1, 5000]`.\n*   `-5000 <= Node.val <= 5000`\nInput:\nhead = \\[4,2,1,3\\]\nOutput:\n\\[1,2,3,4\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef insertionSortList(head):\ndummy = ListNode(0)\ncur = dummy\nwhile head:\nwhile cur.next and cur.next.val < head.val:\ncur = cur.next\ntemp = head.next\nhead.next = cur.next\ncur.next = head\nhead = temp\ncur = dummy\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 289
                },
                {
                        "id": "pretrain_python_data_7141671",
                        "content": "\"\"\"\nGiven the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.\nThe steps of the insertion sort algorithm:\nInsertion sort iterates, consuming one input element each repetition and growing a sorted output list.\nAt each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.\nIt repeats until no input elements remain.\nThe following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\nExample 1:\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\nExample 2:\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\nConstraints:\nThe number of nodes in the list is in the range [1, 5000].\n-5000 <= Node.val <= 5000\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\ndummy = ListNode(0)\ndummy.next = head\ncurrent = head\ncurrent = current.next\nprev = dummy\ncompared = prev.next\ncompared.next = None\nwhile current:\nif compared is None or current.val <= compared.val:\nprev.next = current\ncurrent = current.next\nprev.next.next = compared\nprev = dummy\ncompared = prev.next\nelse:\nprev = prev.next\ncompared = compared.next\nreturn dummy.next",
                        "max_stars_repo_name": "s2503901ernie/LeetCode",
                        "max_stars_repo_path": "Problems/LinkedList/0147-InsertionSortList.py",
                        "max_stars_count": 0,
                        "__cluster__": 289
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_10201724",
                        "content": "\"\"\"\nImplement the myAtoi(string s) function, which converts a string to\na 32-bit signed integer (similar to C/C++'s atoi function).\nThe algorithm for myAtoi(string s) is as follows:\n- Read in and ignore any leading whitespace.\n- Check if the next character (if not already at the end of the string) is '-' or '+'.\nRead this character in if it is either. This determines if the final result is negative\nor positive respectively. Assume the result is positive if neither is present.\n- Read in next the characters until the next non-digit character or the end of the input\nis reached. The rest of the string is ignored.\n- Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits\nwere read, then the integer is 0. Change the sign as necessary (from step 2).\n- If the integer is out of the 32-bit signed integer range [-2^31, 2^31 - 1], then\nclamp the integer so that it remains in the range. Specifically, integers\nless than -2^31 should be clamped to -2^31, and integers greater than 2^31 - 1 should be clamped to 2^31 - 1.\n- Return the integer as the final result.\nNote:\n- Only the space character ' ' is considered a whitespace character.\n- Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\nExample 1:\nInput: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n^\nStep 3: \"42\" (\"42\" is read in)\n^\nThe parsed integer is 42.\nSince 42 is in the range [-2^31, 2^31 - 1], the final result is 42.\nExample 2:\nInput: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n^\nStep 3: \"   -42\" (\"42\" is read in)\n^\nThe parsed integer is -42.\nSince -42 is in the range [-2^31, 2^31 - 1], the final result is -42.\nExample 3:\nInput: s = \"4193 with words\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n^\nThe parsed integer is 4193.\nSince 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193.\nConstraints:\n- 0 <= s.length <= 200\n- s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.\n\"\"\"\ndef solution(s: str) -> int:\nif s is None or len(s) < 1:\nreturn 0\nint_max = 2 ** 31\nint_min = -(2 ** 31) - 1\ns = s.lstrip()\ni = 0\nis_negative = len(s) > 1 and s[0] == \"-\"\nis_positive = len(s) > 1 and s[0] == \"+\"\nif is_negative:\ni += 1\nelif is_positive:\ni += 1\nnumber = 0\nwhile i < len(s) and \"0\" <= s[i] <= \"9\":\nnumber = number * 10 + (ord(s[i]) - ord(\"0\"))\ni += 1\nif is_negative:\nnumber = -number\nif number < int_min:\nreturn int_min\nif number > int_max:\nreturn int_max\nreturn number",
                        "max_stars_repo_name": "jtprogru/interview-task",
                        "max_stars_repo_path": "tasks/task0025.py",
                        "max_stars_count": 3,
                        "__cluster__": 212
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_8",
                        "content": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\nThe algorithm for `myAtoi(string s)` is as follows:\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n**Note:**\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n**Example 1:**\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"42 \" ( \"42 \" is read in)\n^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n**Example 2:**\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n**Example 3:**\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193.\n**Constraints:**\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.\nInput:\ns =  \"42 \"\nOutput:\n42\n```python\ndef myAtoi(s):\nresult, i, sign = 0, 0, 1\nwhile i < len(s) and s[i] == ' ': i += 1\nif i < len(s) and (s[i] == '-' or s[i] == '+'):\nsign = -1 if s[i] == '-' else 1\ni += 1\nwhile i < len(s) and s[i].isdigit():\nresult = result * 10 + int(s[i])\ni += 1\nif result * sign > 2**31 - 1: return 2**31 - 1\nif result * sign < -2**31: return -2**31\nreturn result * sign\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 212
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_8740806",
                        "content": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\nExample 1:\nInput: s = \"abab\"\nOutput: true\nExplanation: It is the substring \"ab\" twice.\nExample 2:\nInput: s = \"aba\"\nOutput: false\nExample 3:\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.\nConstraints:\n1 <= s.length <= 104\ns consists of lowercase English letters.\nSolution:-\nclass Solution:\ndef repeatedSubstringPattern(self, s: str) -> bool:\nif s in s[1:]+s[:-1]:\nreturn True\nelse:\nreturn False",
                        "max_stars_repo_name": "vijay2020pc/100-days-of-code",
                        "max_stars_repo_path": "leetcode-CP/Problem solving/459. Repeated Substring Pattern.py",
                        "max_stars_count": 0,
                        "__cluster__": 411
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_459",
                        "content": "Given a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\n**Example 1:**\n**Input:** s =  \"abab \"\n**Output:** true\n**Explanation:** It is the substring  \"ab \" twice.\n**Example 2:**\n**Input:** s =  \"aba \"\n**Output:** false\n**Example 3:**\n**Input:** s =  \"abcabcabcabc \"\n**Output:** true\n**Explanation:** It is the substring  \"abc \" four times or the substring  \"abcabc \" twice.\n**Constraints:**\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.\nInput:\ns =  \"abab \"\nOutput:\ntrue\n```python\ndef can_construct(s):\nn = len(s)\nfor i in range(n // 2, 0, -1):\nif n % i == 0:\nsubstr = s[:i]\nflag = True\nfor j in range(i, n, i):\nif s[j:j+i] != substr:\nflag = False\nbreak\nif flag:\nreturn True\nreturn False\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 411
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_11985341",
                        "content": "'''\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n'''\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nmin_price = float('inf')\nmax_profit = 0\nfor i in range(len(prices)):\nif prices[i] < min_price:\nmin_price = prices[i]\nelif max_profit < (prices[i] - min_price):\nmax_profit = prices[i] - min_price\nreturn max_profit",
                        "max_stars_repo_name": "vanigupta20024/Programming-Challenges",
                        "max_stars_repo_path": "BestTimeToBuy&SellStock.py",
                        "max_stars_count": 14,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_11985341",
                        "content": "'''\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n'''\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nmin_price = float('inf')\nmax_profit = 0\nfor i in range(len(prices)):\nif prices[i] < min_price:\nmin_price = prices[i]\nelif max_profit < (prices[i] - min_price):\nmax_profit = prices[i] - min_price\nreturn max_profit",
                        "max_stars_repo_name": "vanigupta20024/Programming-Challenges",
                        "max_stars_repo_path": "BestTimeToBuy&SellStock.py",
                        "max_stars_count": 14,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_11985341",
                        "content": "'''\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n'''\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nmin_price = float('inf')\nmax_profit = 0\nfor i in range(len(prices)):\nif prices[i] < min_price:\nmin_price = prices[i]\nelif max_profit < (prices[i] - min_price):\nmax_profit = prices[i] - min_price\nreturn max_profit",
                        "max_stars_repo_name": "vanigupta20024/Programming-Challenges",
                        "max_stars_repo_path": "BestTimeToBuy&SellStock.py",
                        "max_stars_count": 14,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_11985341",
                        "content": "'''\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n'''\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nmin_price = float('inf')\nmax_profit = 0\nfor i in range(len(prices)):\nif prices[i] < min_price:\nmin_price = prices[i]\nelif max_profit < (prices[i] - min_price):\nmax_profit = prices[i] - min_price\nreturn max_profit",
                        "max_stars_repo_name": "vanigupta20024/Programming-Challenges",
                        "max_stars_repo_path": "BestTimeToBuy&SellStock.py",
                        "max_stars_count": 14,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_11991599",
                        "content": "# There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n#\n# The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.\n#\n# Note:\n# All costs are positive integers.\n#\n# Example:\n#\n# Input: [[17,2,17],[16,16,5],[14,3,19]]\n# Output: 10\n# Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\n#              Minimum cost: 2 + 5 + 3 = 10.\nclass Solution(object):\ndef minCost(self, costs):\n\"\"\"\n:type costs: List[List[int]]\n:rtype: int\n\"\"\"\nif not costs or not costs[0]:\nreturn 0\nfor i in range(1, len(costs)):\ncosts[i][0] += min(costs[i - 1][1], costs[i - 1][2])\ncosts[i][1] += min(costs[i - 1][0], costs[i - 1][2])\ncosts[i][2] += min(costs[i - 1][0], costs[i - 1][1])\nreturn min(costs[-1])",
                        "max_stars_repo_name": "yshshadow/Leetcode",
                        "max_stars_repo_path": "251-300/256.py",
                        "max_stars_count": 0,
                        "__cluster__": 350
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_256",
                        "content": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\nReturn _the minimum cost to paint all houses_.\n**Example 1:**\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n**Example 2:**\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2\n**Constraints:**\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`\nInput:\ncosts = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\nOutput:\n10\n```python\ndef minCost(costs: List[List[int]]) -> int:\nif not costs:\nreturn 0\nfor i in range(1, len(costs)):\ncosts[i][0] += min(costs[i - 1][1], costs[i - 1][2])\ncosts[i][1] += min(costs[i - 1][0], costs[i - 1][2])\ncosts[i][2] += min(costs[i - 1][0], costs[i - 1][1])\nreturn min(costs[-1][0], costs[-1][1], costs[-1][2])\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 350
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_202",
                        "content": "Write an algorithm to determine if a number `n` is happy.\nA **happy number** is a number defined by the following process:\n*   Starting with any positive integer, replace the number by the sum of the squares of its digits.\n*   Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.\n*   Those numbers for which this process **ends in 1** are happy.\nReturn `true` _if_ `n` _is a happy number, and_ `false` _if not_.\n**Example 1:**\n**Input:** n = 19\n**Output:** true\n**Explanation:**\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n**Example 2:**\n**Input:** n = 2\n**Output:** false\n**Constraints:**\n*   `1 <= n <= 231 - 1`\nInput:\nn = 19\nOutput:\ntrue\n```python\ndef get_next(n):\nsum = 0\nwhile n > 0:\ndigit = n % 10\nsum += digit * digit\nn //= 10\nreturn sum\ndef is_happy(n):\nslow, fast = n, get_next(n)\nwhile fast != 1 and slow != fast:\nslow = get_next(slow)\nfast = get_next(get_next(fast))\nreturn fast == 1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 306
                },
                {
                        "id": "pretrain_python_data_11900317",
                        "content": "<reponame>vijay2020pc/100-days-of-code\nWrite an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\nRepeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\nThose numbers for which this process ends in 1 are happy.\nReturn true if n is a happy number, and false if not.\nExample 1:\nInput: n = 19\nOutput: true\nExplanation:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\nExample 2:\nInput: n = 2\nOutput: false\nConstraints:\n1 <= n <= 231 - 1\nSolution:-\nclass Solution:\ndef isHappy(self, n: int) -> bool:\ndef get_next(number):\ntotal_sum = 0\nwhile number > 0:\nnumber, digit = divmod(number, 10)\ntotal_sum += digit ** 2\nreturn total_sum\nwhile n != 1 and n != 4:\nn = get_next(n)\nreturn n == 1",
                        "max_stars_repo_name": "vijay2020pc/100-days-of-code",
                        "max_stars_repo_path": "leetcode-CP/Problem solving/202. Happy Number.py",
                        "max_stars_count": 0,
                        "__cluster__": 306
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_11880341",
                        "content": "<filename>123_buy_sell_stock_atmost_two.py\n\"\"\"\nSay you have an array for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete at most two transactions.\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\nExample 4:\nInput: prices = [1]\nOutput: 0\nConstraints:\n1 <= prices.length <= 105\n0 <= prices[i] <= 105\n\"\"\"\nclass Solution(object):\ndef maxProfit(self, prices):\nmin_so_far, min_so_far_p2 = float('inf'), float('inf')\nmax_so_far, max_so_far_p2 = 0, 0\nfor price in prices:\nmin_so_far = min(min_so_far, price)\nmax_so_far = max(max_so_far, price - min_so_far)\nmin_so_far_p2 = min(min_so_far_p2, price - max_so_far)\nmax_so_far_p2 = max(max_so_far_p2, price - min_so_far_p2)\nreturn max_so_far_p2",
                        "max_stars_repo_name": "ojhaanshu87/LeetCode",
                        "max_stars_repo_path": "123_buy_sell_stock_atmost_two.py",
                        "max_stars_count": 0,
                        "__cluster__": 277
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_123",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n**Example 1:**\n**Input:** prices = \\[3,3,5,0,0,3,1,4\\]\n**Output:** 6\n**Explanation:** Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n**Example 2:**\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n**Example 3:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transaction is done, i.e. max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 105`\nInput:\nprices = \\[3,3,5,0,0,3,1,4\\]\nOutput:\n6\n```python\ndef maxProfit(prices):\nbuy1, buy2 = float(\"inf\"), float(\"inf\")\nprofit1, profit2 = 0, 0\nfor price in prices:\nbuy1 = min(buy1, price)\nprofit1 = max(profit1, price - buy1)\nbuy2 = min(buy2, price - profit1)\nprofit2 = max(profit2, price - buy2)\nreturn profit2\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 277
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_2467556",
                        "content": "<gh_stars>0\n\"\"\"\nAdd Two Numbers - Linked List\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1, l2):\ncarry = 0\nhead = ans = ListNode(None)\nwhile l1 or l2 or carry:\nfirstNum = l1.val if l1 else 0\nsecondNum = l2.val if l2 else 0\ncarry, add = divmod(firstNum + secondNum + carry, 10)\nans.next = ListNode(add)\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nans = ans.next\nreturn head.next",
                        "max_stars_repo_name": "bhimeshchauhan/competitive_programming",
                        "max_stars_repo_path": "scripts/practice/FB-reRun/addTwoLinkedList.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_2467556",
                        "content": "<gh_stars>0\n\"\"\"\nAdd Two Numbers - Linked List\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1, l2):\ncarry = 0\nhead = ans = ListNode(None)\nwhile l1 or l2 or carry:\nfirstNum = l1.val if l1 else 0\nsecondNum = l2.val if l2 else 0\ncarry, add = divmod(firstNum + secondNum + carry, 10)\nans.next = ListNode(add)\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nans = ans.next\nreturn head.next",
                        "max_stars_repo_name": "bhimeshchauhan/competitive_programming",
                        "max_stars_repo_path": "scripts/practice/FB-reRun/addTwoLinkedList.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_2467556",
                        "content": "<gh_stars>0\n\"\"\"\nAdd Two Numbers - Linked List\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1, l2):\ncarry = 0\nhead = ans = ListNode(None)\nwhile l1 or l2 or carry:\nfirstNum = l1.val if l1 else 0\nsecondNum = l2.val if l2 else 0\ncarry, add = divmod(firstNum + secondNum + carry, 10)\nans.next = ListNode(add)\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nans = ans.next\nreturn head.next",
                        "max_stars_repo_name": "bhimeshchauhan/competitive_programming",
                        "max_stars_repo_path": "scripts/practice/FB-reRun/addTwoLinkedList.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_2467556",
                        "content": "<gh_stars>0\n\"\"\"\nAdd Two Numbers - Linked List\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1, l2):\ncarry = 0\nhead = ans = ListNode(None)\nwhile l1 or l2 or carry:\nfirstNum = l1.val if l1 else 0\nsecondNum = l2.val if l2 else 0\ncarry, add = divmod(firstNum + secondNum + carry, 10)\nans.next = ListNode(add)\nl1 = l1.next if l1 else None\nl2 = l2.next if l2 else None\nans = ans.next\nreturn head.next",
                        "max_stars_repo_name": "bhimeshchauhan/competitive_programming",
                        "max_stars_repo_path": "scripts/practice/FB-reRun/addTwoLinkedList.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```python\ndef minPathSum(grid):\nm, n = len(grid), len(grid[0])\nfor i in range(1, m):\ngrid[i][0] += grid[i - 1][0]\nfor i in range(1, n):\ngrid[0][i] += grid[0][i - 1]\nfor i in range(1, m):\nfor j in range(1, n):\ngrid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\nreturn grid[m - 1][n - 1]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 238
                },
                {
                        "id": "pretrain_python_data_915120",
                        "content": "<reponame>dianjiaogit/LeetCode_Python_solution\n# Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n# Note: You can only move either down or right at any point in time.\n# Example 1:\n# Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n# Output: 7\n# Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n# Example 2:\n# Input: grid = [[1,2,3],[4,5,6]]\n# Output: 12\n# Constraints:\n# m == grid.length\n# n == grid[i].length\n# 1 <= m, n <= 200\n# 0 <= grid[i][j] <= 100\nclass Solution:\ndef minPathSum(self, grid) -> int:\nfor i in range(len(grid)):\nfor j in range(len(grid[i])):\nif i == 0 and j == 0:\npass\nelif i == 0:\ngrid[i][j] = grid[i][j - 1] + grid[i][j]\nelif j == 0:\ngrid[i][j] = grid[i - 1][j] + grid[i][j]\nelse:\ngrid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]\nreturn grid[-1][-1]",
                        "max_stars_repo_name": "dianjiaogit/LeetCode_Python_solution",
                        "max_stars_repo_path": "Medium/Minimum_Path_Sum.py",
                        "max_stars_count": 0,
                        "__cluster__": 238
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_897899",
                        "content": "'''\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock.\nYou can only hold at most one share of the stock at any time.\nHowever, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nExample 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\nExample 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\nConstraints:\n1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104\n'''\n# Failed Attempt:\n# arr = [7,1,5,3,6,4]\n# profit_max = {}\n# for i in range(len(arr)):\n#     profit = 0\n#     buy = arr[i]\n#     remain = arr[i+1:]\n#     pos = 0\n#     for idx,val in enumerate(remain):\n#         if (val - buy) > profit:\n#             profit = (val - buy)\n#             pos = idx+i+1\n#     key = str(i)+','+str(pos)\n#     profit_max[key] = profit\n# print(profit_max)\n# Solution:\nclass Solution:\ndef maxProfit(self, prices: List[int]) -> int:\nmax_profit = 0\nfor i in range(1,len(prices)):\nif prices[i] > prices[i-1]:\nmax_profit += prices[i] - prices[i-1]\nreturn max_profit",
                        "max_stars_repo_name": "Anshul-GH/interview_prep",
                        "max_stars_repo_path": "interviewee/05_leetcode/arr_stock_trading.py",
                        "max_stars_count": 1,
                        "__cluster__": 276
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_122",
                        "content": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\nFind and return _the **maximum** profit you can achieve_.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n**Example 2:**\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n**Example 3:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n**Constraints:**\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n7\n```python\ndef max_profit(prices):\nmax_profit = 0\nfor i in range(1, len(prices)):\nif prices[i] > prices[i - 1]:\nmax_profit += prices[i] - prices[i - 1]\nreturn max_profit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 276
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_8",
                        "content": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\nThe algorithm for `myAtoi(string s)` is as follows:\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n**Note:**\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n**Example 1:**\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"42 \" ( \"42 \" is read in)\n^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n**Example 2:**\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n**Example 3:**\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193.\n**Constraints:**\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.\nInput:\ns =  \"42 \"\nOutput:\n42\n```python\ndef myAtoi(s):\nresult, i, sign = 0, 0, 1\nwhile i < len(s) and s[i] == ' ': i += 1\nif i < len(s) and (s[i] == '-' or s[i] == '+'):\nsign = -1 if s[i] == '-' else 1\ni += 1\nwhile i < len(s) and s[i].isdigit():\nresult = result * 10 + int(s[i])\ni += 1\nif result * sign > 2**31 - 1: return 2**31 - 1\nif result * sign < -2**31: return -2**31\nreturn result * sign\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 212
                },
                {
                        "id": "pretrain_python_data_985206",
                        "content": "# 8. String to Integer (atoi)\n# ---------------------------\n#\n# Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s\n# `atoi` function).\n#\n# The algorithm for `myAtoi(string s)` is as follows:\n#\n#   1. Read in and ignore any leading whitespace.\n#   2. Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character\n#      in if it is either. This determines if the final result is negative or positive respectively. Assume the result\n#      is positive if neither is present.\n#   3. Read in next the characters until the next non-digit charcter or the end of the input is reached. The rest of\n#      the string is ignored.\n#   4. Convert these digits into an integer (i.e. `\"123\" -> 123`, `\"0032\" -> 32`). If no digits were read, then the\n#      integer is `0`. Change the sign as necessary (from step 2).\n#   5. If the integer is out of the 32-bit signed integer range `[-2^31, 2^31 - 1]`, then clamp the integer so that it\n#      remains in the range. Specifically, integers less than `-2^31` should be clamped to `-2^31`, and integers greater\n#      than `2^31 - 1` should be clamped to `2^31 - 1`.\n#   6. Return the integer as the final result.\n#\n# ### Note:\n#\n#  * Only the space character `' '` is considered a whitespace character.\n#  * **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n#\n# ### Constraints:\n#\n#  * `0 <= s.length <= 200`\n#  * `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.\n#\n# Source: https://leetcode.com/problems/string-to-integer-atoi/\nINT_MAX = 0x7FFFFFFF\nclass Solution:\nlimit = divmod(INT_MAX, 10)\ndef myAtoi(self, input_string: str, pos: int = 0) -> int:\ndef accept(acceptable):\nnonlocal pos\nfor c in input_string[pos:]:\ni = acceptable.find(c)\nif i == -1:\nbreak\npos += 1\nyield i\ndef accept_one(acceptable, nothing=0):\nfor c in accept(acceptable):\nreturn c\nreturn nothing\nn = 0\nfor _ in accept(' '): pass\npositive = accept_one('+-') == 0\nfor c in accept('0123456789'):\nif (n, c) > Solution.limit:\nreturn INT_MAX if positive else (-INT_MAX) - 1\nn = 10 * n + c\nreturn n if positive else -n\nif __name__ == '__main__':\ns = Solution()\n# Example 1:\n#\n# Input: s = \"42\"\n# Output: 42\n# Explanation: The underlined characters are what is read in, the caret is the current reader position.\n# Step 1: \"42\" (no characters read because there is no leading whitespace)\n#          ^\n# Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n#          ^\n# Step 3: \"42\" (\"42\" is read in)\n#            ^\n# The parsed integer is 42.\n# Since 42 is in the range [-2^31, 2^31 - 1], the final result is 42.\nprint(f\"{s.myAtoi('42')} == 42\")\n# Example 2:\n#\n# Input: s = \"   -42\"\n# Output: -42\n# Explanation:\n# Step 1: \"   -42\" (leading whitespace is read and ignored)\n#             ^\n# Step 2: \"   -42\" ('-' is read, so the result should be negative)\n#              ^\n# Step 3: \"   -42\" (\"42\" is read in)\n#                ^\n# The parsed integer is -42.\n# Since -42 is in the range [-2^31, 2^31 - 1], the final result is -42.\nprint(f\"{s.myAtoi('   -42')} == -42\")\n# Example 3:\n#\n# Input: s = \"4193 with words\"\n# Output: 4193\n# Explanation:\n# Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n#          ^\n# Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n#          ^\n# Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n#              ^\n# The parsed integer is 4193.\n# Since 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193.\nprint(f\"{s.myAtoi('4193 with words')} == 4193\")\n# Example 4:\n#\n# Input: s = \"words and 987\"\n# Output: 0\n# Explanation:\n# Step 1: \"words and 987\" (no characters read because there is no leading whitespace)\n#          ^\n# Step 2: \"words and 987\" (no characters read because there is neither a '-' nor '+')\n#          ^\n# Step 3: \"words and 987\" (reading stops immediately because there is a non-digit 'w')\n#          ^\n# The parsed integer is 0 because no digits were read.\n# Since 0 is in the range [-2^31, 2^31 - 1], the final result is 0.\nprint(f\"{s.myAtoi('words and 987')} == 0\")\n# Example 5:\n#\n# Input: s = \"-91283472332\"\n# Output: -2147483648\n# Explanation:\n# Step 1: \"-91283472332\" (no characters read because there is no leading whitespace)\n#          ^\n# Step 2: \"-91283472332\" ('-' is read, so the result should be negative)\n#           ^\n# Step 3: \"-91283472332\" (\"91283472332\" is read in)\n#                      ^\n# The parsed integer is -91283472332.\n# Since -91283472332 is less than the lower bound of the range [-2^31, 2^31 - 1], the final result is clamped\n# to -2^31 = -2147483648.\nprint(f\"{s.myAtoi('-91283472332')} == -2147483648\")",
                        "max_stars_repo_name": "Const-Grigoryev/LeetCode",
                        "max_stars_repo_path": "Python/src/problem0008.py",
                        "max_stars_count": 0,
                        "__cluster__": 212
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_8834245",
                        "content": "<reponame>H-isaac23/LeetCode-Challenges<filename>Single Number.py\n# Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n# You must implement a solution with a linear runtime complexity and use only constant extra space.\n#\n# Example 1:\n# Input: nums = [2, 2, 1]\n# Output: 1\n#\n# Example 2:\n# Input: nums = [4, 1, 2, 1, 2]\n# Output: 4\n#\n# Example 3:\n# Input: nums = [1]\n# Output: 1\n#\n# Constraints:\n# 1 <= nums.length <= 3 * 104\n# -3 * 104 <= nums[i] <= 3 * 104\n# Each element in the array appears twice except for one element which appears only once.\nclass Solution:\ndef singleNumber(self, nums: List[int]) -> int:\nnum = 0\nfor x in nums:\nnum ^= x\nreturn num\n",
                        "max_stars_repo_name": "H-isaac23/LeetCode-Challenges",
                        "max_stars_repo_path": "Single Number.py",
                        "max_stars_count": 0,
                        "__cluster__": 284
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_136",
                        "content": "Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n**Example 1:**\n**Input:** nums = \\[2,2,1\\]\n**Output:** 1\n**Example 2:**\n**Input:** nums = \\[4,1,2,1,2\\]\n**Output:** 4\n**Example 3:**\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Constraints:**\n*   `1 <= nums.length <= 3 * 104`\n*   `-3 * 104 <= nums[i] <= 3 * 104`\n*   Each element in the array appears twice except for one element which appears only once.\nInput:\nnums = \\[2,2,1\\]\nOutput:\n1\n```python\ndef singleNumber(nums):\nresult = 0\nfor num in nums:\nresult ^= num\nreturn result\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 284
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_217",
                        "content": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** true\n**Example 2:**\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n**Example 3:**\n**Input:** nums = \\[1,1,1,3,3,4,3,2,4,2\\]\n**Output:** true\n**Constraints:**\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\ntrue\n```python\ndef containsDuplicate(nums):\nreturn len(nums) != len(set(nums))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 321
                },
                {
                        "id": "pretrain_python_data_2649781",
                        "content": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\nConstraints:\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\nSolution:\npython:\nclass Solution:\ndef containsDuplicate(self, nums: List[int]) -> bool:\nreturn len(set(nums))!=len(nums)",
                        "max_stars_repo_name": "vijay2020pc/100-days-of-code",
                        "max_stars_repo_path": "leetcode-CP/Data-structures-Problems/217- Contains Duplicate.py",
                        "max_stars_count": 0,
                        "__cluster__": 321
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_217",
                        "content": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** true\n**Example 2:**\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n**Example 3:**\n**Input:** nums = \\[1,1,1,3,3,4,3,2,4,2\\]\n**Output:** true\n**Constraints:**\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\ntrue\n```python\ndef containsDuplicate(nums):\nreturn len(nums) != len(set(nums))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 321
                },
                {
                        "id": "pretrain_python_data_2649781",
                        "content": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\nConstraints:\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\nSolution:\npython:\nclass Solution:\ndef containsDuplicate(self, nums: List[int]) -> bool:\nreturn len(set(nums))!=len(nums)",
                        "max_stars_repo_name": "vijay2020pc/100-days-of-code",
                        "max_stars_repo_path": "leetcode-CP/Data-structures-Problems/217- Contains Duplicate.py",
                        "max_stars_count": 0,
                        "__cluster__": 321
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```python\ndef rob(nums):\nprev1, prev2 = 0, 0\nfor num in nums:\nprev1, prev2 = max(prev2 + num, prev1), prev1\nreturn prev1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 302
                },
                {
                        "id": "pretrain_python_data_7466943",
                        "content": "<filename>198.py<gh_stars>0\n\"\"\"House Robber\nYou are a professional robber planning to rob houses along a street.\nEach house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them is\nthat adjacent houses have security system connected and\nit will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n0 <= nums.length <= 100\n0 <= nums[i] <= 400\n\"\"\"\nclass Solution(object):\ndef rob(self, nums):\n\"\"\"\n:type nums: List[int]\n:rtype: int\n\"\"\"\n## Practice:\nnow = 0\nprev = 0\nfor num in nums:\nprev, now = now, max(prev+num, now)\nreturn now\n# R1:\nnow, last = 0, 0\nfor i in nums:\nlast, now = now, max(last + i, now)\nreturn now",
                        "max_stars_repo_name": "wilbertgeng/LeetCode_exercise",
                        "max_stars_repo_path": "198.py",
                        "max_stars_count": 0,
                        "__cluster__": 302
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```python\ndef rob(nums):\nprev1, prev2 = 0, 0\nfor num in nums:\nprev1, prev2 = max(prev2 + num, prev1), prev1\nreturn prev1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 302
                },
                {
                        "id": "pretrain_python_data_7466943",
                        "content": "<filename>198.py<gh_stars>0\n\"\"\"House Robber\nYou are a professional robber planning to rob houses along a street.\nEach house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them is\nthat adjacent houses have security system connected and\nit will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n0 <= nums.length <= 100\n0 <= nums[i] <= 400\n\"\"\"\nclass Solution(object):\ndef rob(self, nums):\n\"\"\"\n:type nums: List[int]\n:rtype: int\n\"\"\"\n## Practice:\nnow = 0\nprev = 0\nfor num in nums:\nprev, now = now, max(prev+num, now)\nreturn now\n# R1:\nnow, last = 0, 0\nfor i in nums:\nlast, now = now, max(last + i, now)\nreturn now",
                        "max_stars_repo_name": "wilbertgeng/LeetCode_exercise",
                        "max_stars_repo_path": "198.py",
                        "max_stars_count": 0,
                        "__cluster__": 302
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "pretrain_python_data_5929448",
                        "content": "\"\"\"\nWord Break\nGiven a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nExample 1:\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\nExample 2:\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\nExample 3:\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false\nConstraints:\n1 <= s.length <= 300\n1 <= wordDict.length <= 1000\n1 <= wordDict[i].length <= 20\ns and wordDict[i] consist of only lowercase English letters.\nAll the strings of wordDict are unique.\n\"\"\"\nclass Solution:\ndef wordBreak(self, s: str, wordDict: List[str]) -> bool:\nwordSet = set(wordDict)\nstart = 0\nvisited = set()\nq = deque()\nq.append(0)\nwhile q:\nstartIdx = q.popleft()\nif startIdx in visited:\ncontinue\nfor endIdx in range(startIdx+1, len(s)+1):\nword = s[startIdx:endIdx]\nif word in wordDict:\nq.append(endIdx)\nif endIdx == len(s):\nreturn True\nvisited.add(startIdx)\nreturn False\n",
                        "max_stars_repo_name": "bhimeshchauhan/competitive_programming",
                        "max_stars_repo_path": "scripts/practice/FB-reRun/WordBreak.py",
                        "max_stars_count": 0,
                        "__cluster__": 108
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_139",
                        "content": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n**Example 1:**\n**Input:** s =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\n**Output:** true\n**Explanation:** Return true because  \"leetcode \" can be segmented as  \"leet code \".\n**Example 2:**\n**Input:** s =  \"applepenapple \", wordDict = \\[ \"apple \", \"pen \"\\]\n**Output:** true\n**Explanation:** Return true because  \"applepenapple \" can be segmented as  \"apple pen apple \".\nNote that you are allowed to reuse a dictionary word.\n**Example 3:**\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** false\n**Constraints:**\n*   `1 <= s.length <= 300`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 20`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.\nInput:\ns =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\nOutput:\ntrue\n```python\ndef word_break(s, word_dict):\nword_set = set(word_dict)\ndp = [False] * (len(s) + 1)\ndp[0] = True\nfor i in range(1, len(s) + 1):\nfor j in range(i):\nif dp[j] and s[j:i] in word_set:\ndp[i] = True\nbreak\nreturn dp[len(s)]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 108
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_12282610",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers. The digits\nare stored in reverse order, and each of their nodes contains a single digit. Add the two\nnumbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nhttps://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\n1. The number of nodes in each linked list is in the range [1, 100].\n2. 0 <= Node.val <= 9\n3. It is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\nclass ListNode:\n\"\"\"\nDefinition for singly-linked list.\n\"\"\"\ndef __init__(self, x):\nself.val = x\nself.next = None\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ndummy = cur = ListNode(0)\ncarrier = 0\nwhile l1 or l2 or (carrier == 1):\nif l1:\ncarrier += l1.val\nl1 = l1.next\nif l2:\ncarrier += l2.val\nl2 = l2.next\ncarrier, val = divmod(carrier, 10)\ncur = cur.next = ListNode(val)\nreturn dummy.next",
                        "max_stars_repo_name": "chaosWsF/Python-Practice",
                        "max_stars_repo_path": "leetcode/0002_add_two_numbers.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_12282610",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers. The digits\nare stored in reverse order, and each of their nodes contains a single digit. Add the two\nnumbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nhttps://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\n1. The number of nodes in each linked list is in the range [1, 100].\n2. 0 <= Node.val <= 9\n3. It is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\nclass ListNode:\n\"\"\"\nDefinition for singly-linked list.\n\"\"\"\ndef __init__(self, x):\nself.val = x\nself.next = None\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ndummy = cur = ListNode(0)\ncarrier = 0\nwhile l1 or l2 or (carrier == 1):\nif l1:\ncarrier += l1.val\nl1 = l1.next\nif l2:\ncarrier += l2.val\nl2 = l2.next\ncarrier, val = divmod(carrier, 10)\ncur = cur.next = ListNode(val)\nreturn dummy.next",
                        "max_stars_repo_name": "chaosWsF/Python-Practice",
                        "max_stars_repo_path": "leetcode/0002_add_two_numbers.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_12282610",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers. The digits\nare stored in reverse order, and each of their nodes contains a single digit. Add the two\nnumbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nhttps://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\n1. The number of nodes in each linked list is in the range [1, 100].\n2. 0 <= Node.val <= 9\n3. It is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\nclass ListNode:\n\"\"\"\nDefinition for singly-linked list.\n\"\"\"\ndef __init__(self, x):\nself.val = x\nself.next = None\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ndummy = cur = ListNode(0)\ncarrier = 0\nwhile l1 or l2 or (carrier == 1):\nif l1:\ncarrier += l1.val\nl1 = l1.next\nif l2:\ncarrier += l2.val\nl2 = l2.next\ncarrier, val = divmod(carrier, 10)\ncur = cur.next = ListNode(val)\nreturn dummy.next",
                        "max_stars_repo_name": "chaosWsF/Python-Practice",
                        "max_stars_repo_path": "leetcode/0002_add_two_numbers.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_12282610",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers. The digits\nare stored in reverse order, and each of their nodes contains a single digit. Add the two\nnumbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nhttps://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\n1. The number of nodes in each linked list is in the range [1, 100].\n2. 0 <= Node.val <= 9\n3. It is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\nclass ListNode:\n\"\"\"\nDefinition for singly-linked list.\n\"\"\"\ndef __init__(self, x):\nself.val = x\nself.next = None\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\ndummy = cur = ListNode(0)\ncarrier = 0\nwhile l1 or l2 or (carrier == 1):\nif l1:\ncarrier += l1.val\nl1 = l1.next\nif l2:\ncarrier += l2.val\nl2 = l2.next\ncarrier, val = divmod(carrier, 10)\ncur = cur.next = ListNode(val)\nreturn dummy.next",
                        "max_stars_repo_name": "chaosWsF/Python-Practice",
                        "max_stars_repo_path": "leetcode/0002_add_two_numbers.py",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_10752029",
                        "content": "<filename>array/0153_find_minimum_in_rotated_sorted_array.py\n\"\"\"\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\nExample 2:\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\nExample 3:\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times.\nConstraints:\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nAll the integers of nums are unique.\nnums is sorted and rotated between 1 and n times.\n\"\"\"\nfrom typing import List\ndef findMin(nums: List[int]) -> int:\n\"\"\"\nTime: O(log n)\nSpace: O(1)\n\"\"\"\nres = nums[0]\nleft, right = 0, len(nums) - 1\nwhile left <= right:\nif nums[left] < nums[right]:\nres = min(res, nums[left])\nbreak\nmid = (left + right) // 2\nres = min(res, nums[mid])\nif nums[mid] >= nums[left]:\nleft = mid + 1\nelse:\nright = mid - 1\nreturn res\nif __name__ == '__main__':\n# Test 1\nnums = [3,4,5,1,2]\nprint(findMin(nums))\n# Test 2\nnums = [4,5,6,7,0,1,2]\nprint(findMin(nums))\n# Test 3\nnums = [11,13,15,17]\nprint(findMin(nums))",
                        "max_stars_repo_name": "gosiqueira/blind-75",
                        "max_stars_repo_path": "array/0153_find_minimum_in_rotated_sorted_array.py",
                        "max_stars_count": 0,
                        "__cluster__": 294
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_153",
                        "content": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n*   `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n*   `[0,1,2,4,5,6,7]` if it was rotated `7` times.\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\nGiven the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.\nYou must write an algorithm that runs in `O(log n) time.`\n**Example 1:**\n**Input:** nums = \\[3,4,5,1,2\\]\n**Output:** 1\n**Explanation:** The original array was \\[1,2,3,4,5\\] rotated 3 times.\n**Example 2:**\n**Input:** nums = \\[4,5,6,7,0,1,2\\]\n**Output:** 0\n**Explanation:** The original array was \\[0,1,2,4,5,6,7\\] and it was rotated 4 times.\n**Example 3:**\n**Input:** nums = \\[11,13,15,17\\]\n**Output:** 11\n**Explanation:** The original array was \\[11,13,15,17\\] and it was rotated 4 times.\n**Constraints:**\n*   `n == nums.length`\n*   `1 <= n <= 5000`\n*   `-5000 <= nums[i] <= 5000`\n*   All the integers of `nums` are **unique**.\n*   `nums` is sorted and rotated between `1` and `n` times.\nInput:\nnums = \\[3,4,5,1,2\\]\nOutput:\n1\n```python\ndef find_min(nums):\nleft, right = 0, len(nums) - 1\nwhile left < right:\nmid = left + (right - left) // 2\nif nums[mid] > nums[right]:\nleft = mid + 1\nelse:\nright = mid\nreturn nums[left]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 294
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_1303425",
                        "content": "<gh_stars>0\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExample 1:\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\nExample 2:\nInput: digits = \"\"\nOutput: []\nclass Solution:\ndef letterCombinations(self, digits: str):\ncombinations = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\nif digits == \"\":\nreturn []\nnumbers = list(combinations[digits[0]])\nfor digit in digits[1:]:\nnumbers = [old + new for old in numbers for new in list(combinations[digit[0]])]\nreturn numbers\n",
                        "max_stars_repo_name": "alijon30/Leetcode",
                        "max_stars_repo_path": "17. Letter Combinations of a Phone Number.py",
                        "max_stars_count": 0,
                        "__cluster__": 215
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_17",
                        "content": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n**Example 1:**\n**Input:** digits =  \"23 \"\n**Output:** \\[ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"\\]\n**Example 2:**\n**Input:** digits =  \" \"\n**Output:** \\[\\]\n**Example 3:**\n**Input:** digits =  \"2 \"\n**Output:** \\[ \"a \", \"b \", \"c \"\\]\n**Constraints:**\n*   `0 <= digits.length <= 4`\n*   `digits[i]` is a digit in the range `['2', '9']`.\nInput:\ndigits =  \"23 \"\nOutput:\n\\[ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"\\]\n```python\ndef letter_combinations(digits: str):\nif not digits: return []\nphone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\nresult = [\"\"]\nfor digit in digits:\ntemp = []\nfor s in result:\nfor c in phone[int(digit) - 2]:\ntemp.append(s + c)\nresult = temp\nreturn result\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 215
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_2803899",
                        "content": "\"\"\"\nLINK: https://leetcode.com/problems/missing-number/\nGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nFollow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?\nExample 1:\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\nExample 2:\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\nExample 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\nExample 4:\nInput: nums = [0]\nOutput: 1\nExplanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.\nConstraints:\nn == nums.length\n1 <= n <= 104\n0 <= nums[i] <= n\nAll the numbers of nums are unique.\n\"\"\"\ndef missingNumber_math(nums):\nn = len(nums)\ntotal_sum = n*(n+1)//2\nreturn total_sum - sum(nums)\ndef missingNumber_oneLine(nums):\nreturn sum(range(len(nums)+1))-sum(nums)",
                        "max_stars_repo_name": "lorenzophys/coding-problems-playground",
                        "max_stars_repo_path": "LeetCode/Easy/268-MissingNumber.py",
                        "max_stars_count": 0,
                        "__cluster__": 362
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_268",
                        "content": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._\n**Example 1:**\n**Input:** nums = \\[3,0,1\\]\n**Output:** 2\n**Explanation:** n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums.\n**Example 2:**\n**Input:** nums = \\[0,1\\]\n**Output:** 2\n**Explanation:** n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums.\n**Example 3:**\n**Input:** nums = \\[9,6,4,2,3,5,7,0,1\\]\n**Output:** 8\n**Explanation:** n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums.\n**Constraints:**\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `0 <= nums[i] <= n`\n*   All the numbers of `nums` are **unique**.\n**Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?\nInput:\nnums = \\[3,0,1\\]\nOutput:\n2\n```python\ndef missingNumber(nums):\nn = len(nums)\nexpected_sum = (n * (n + 1)) // 2\nactual_sum = sum(nums)\nreturn expected_sum - actual_sum\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 362
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_169",
                        "content": "Given an array `nums` of size `n`, return _the majority element_.\nThe majority element is the element that appears more than `\u230an / 2\u230b` times. You may assume that the majority element always exists in the array.\n**Example 1:**\n**Input:** nums = \\[3,2,3\\]\n**Output:** 3\n**Example 2:**\n**Input:** nums = \\[2,2,1,1,1,2,2\\]\n**Output:** 2\n**Constraints:**\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?\nInput:\nnums = \\[3,2,3\\]\nOutput:\n3\n```python\ndef majority_element(nums):\ncount = 0\ncandidate = None\nfor num in nums:\nif count == 0:\ncandidate = num\ncount += (num == candidate) - (num != candidate)\nreturn candidate\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 113
                },
                {
                        "id": "pretrain_python_data_4585668",
                        "content": "<reponame>ojhaanshu87/LeetCode\n'''\nGiven an array nums of size n, return the majority element.\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3]\nOutput: 3\nExample 2:\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\nConstraints:\nn == nums.length\n1 <= n <= 5 * 104\n-231 <= nums[i] <= 231 - 1\nFollow-up: Could you solve the problem in linear time and in O(1) space?\n'''\nclass Solution(object):\ndef majorityElement(self, nums):\n# O(N) TC and O(1) Space\ncount = 0\ncandidate = None\nfor num in nums:\nif count == 0:\ncandidate = num\ncount += (1 if num == candidate else -1)\nreturn candidate",
                        "max_stars_repo_name": "ojhaanshu87/LeetCode",
                        "max_stars_repo_path": "169_majority_elem.py",
                        "max_stars_count": 0,
                        "__cluster__": 113
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_169",
                        "content": "Given an array `nums` of size `n`, return _the majority element_.\nThe majority element is the element that appears more than `\u230an / 2\u230b` times. You may assume that the majority element always exists in the array.\n**Example 1:**\n**Input:** nums = \\[3,2,3\\]\n**Output:** 3\n**Example 2:**\n**Input:** nums = \\[2,2,1,1,1,2,2\\]\n**Output:** 2\n**Constraints:**\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?\nInput:\nnums = \\[3,2,3\\]\nOutput:\n3\n```python\ndef majority_element(nums):\ncount = 0\ncandidate = None\nfor num in nums:\nif count == 0:\ncandidate = num\ncount += (num == candidate) - (num != candidate)\nreturn candidate\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 113
                },
                {
                        "id": "pretrain_python_data_4585668",
                        "content": "<reponame>ojhaanshu87/LeetCode\n'''\nGiven an array nums of size n, return the majority element.\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3]\nOutput: 3\nExample 2:\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\nConstraints:\nn == nums.length\n1 <= n <= 5 * 104\n-231 <= nums[i] <= 231 - 1\nFollow-up: Could you solve the problem in linear time and in O(1) space?\n'''\nclass Solution(object):\ndef majorityElement(self, nums):\n# O(N) TC and O(1) Space\ncount = 0\ncandidate = None\nfor num in nums:\nif count == 0:\ncandidate = num\ncount += (1 if num == candidate else -1)\nreturn candidate",
                        "max_stars_repo_name": "ojhaanshu87/LeetCode",
                        "max_stars_repo_path": "169_majority_elem.py",
                        "max_stars_count": 0,
                        "__cluster__": 113
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_72",
                        "content": "Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.\nYou have the following three operations permitted on a word:\n*   Insert a character\n*   Delete a character\n*   Replace a character\n**Example 1:**\n**Input:** word1 =  \"horse \", word2 =  \"ros \"\n**Output:** 3\n**Explanation:**\nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n**Example 2:**\n**Input:** word1 =  \"intention \", word2 =  \"execution \"\n**Output:** 5\n**Explanation:**\nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n**Constraints:**\n*   `0 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of lowercase English letters.\nInput:\nword1 =  \"horse \", word2 =  \"ros \"\nOutput:\n3\n```python\ndef minDistance(word1: str, word2: str) -> int:\nm, n = len(word1), len(word2)\ndp = [[0] * (n + 1) for _ in range(m + 1)]\nfor i in range(m + 1):\nfor j in range(n + 1):\nif i == 0:\ndp[i][j] = j\nelif j == 0:\ndp[i][j] = i\nelif word1[i - 1] == word2[j - 1]:\ndp[i][j] = dp[i - 1][j - 1]\nelse:\ndp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\nreturn dp[m][n]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 244
                },
                {
                        "id": "pretrain_python_data_4585667",
                        "content": "'''\nGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\nYou have the following 3 operations permitted on a word:\nInsert a character\nDelete a character\nReplace a character\nExample 1:\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation:\nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\nExample 2:\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation:\nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n'''\nclass Solution(object):\ndef minDistance(self, word1, word2):\n\"\"\"\n:type word1: str\n:type word2: str\n:rtype: int\n\"\"\"\nm , n = len(word1), len(word2)\ndp = [[0 for _ in range(n+1)] for _ in range(m+1)]\nfor index_i in range(m+1):\nfor index_j in range(n+1):\nif index_i == 0:\ndp[index_i][index_j] = index_j\nelif index_j == 0:\ndp[index_i][index_j] = index_i\nelif word1[index_i-1] == word2[index_j-1]:\ndp[index_i][index_j] = dp[index_i-1][index_j-1]\nelse:\ndp[index_i][index_j] = 1 + min(dp[index_i-1][index_j], dp[index_i-1][index_j-1], dp[index_i][index_j-1])\nreturn dp[m][n]",
                        "max_stars_repo_name": "rampup01/Leetcode",
                        "max_stars_repo_path": "1-100q/72.py",
                        "max_stars_count": 990,
                        "__cluster__": 244
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_72",
                        "content": "Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.\nYou have the following three operations permitted on a word:\n*   Insert a character\n*   Delete a character\n*   Replace a character\n**Example 1:**\n**Input:** word1 =  \"horse \", word2 =  \"ros \"\n**Output:** 3\n**Explanation:**\nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n**Example 2:**\n**Input:** word1 =  \"intention \", word2 =  \"execution \"\n**Output:** 5\n**Explanation:**\nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n**Constraints:**\n*   `0 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of lowercase English letters.\nInput:\nword1 =  \"horse \", word2 =  \"ros \"\nOutput:\n3\n```python\ndef minDistance(word1: str, word2: str) -> int:\nm, n = len(word1), len(word2)\ndp = [[0] * (n + 1) for _ in range(m + 1)]\nfor i in range(m + 1):\nfor j in range(n + 1):\nif i == 0:\ndp[i][j] = j\nelif j == 0:\ndp[i][j] = i\nelif word1[i - 1] == word2[j - 1]:\ndp[i][j] = dp[i - 1][j - 1]\nelse:\ndp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\nreturn dp[m][n]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 244
                },
                {
                        "id": "pretrain_python_data_4585667",
                        "content": "'''\nGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\nYou have the following 3 operations permitted on a word:\nInsert a character\nDelete a character\nReplace a character\nExample 1:\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation:\nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\nExample 2:\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation:\nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n'''\nclass Solution(object):\ndef minDistance(self, word1, word2):\n\"\"\"\n:type word1: str\n:type word2: str\n:rtype: int\n\"\"\"\nm , n = len(word1), len(word2)\ndp = [[0 for _ in range(n+1)] for _ in range(m+1)]\nfor index_i in range(m+1):\nfor index_j in range(n+1):\nif index_i == 0:\ndp[index_i][index_j] = index_j\nelif index_j == 0:\ndp[index_i][index_j] = index_i\nelif word1[index_i-1] == word2[index_j-1]:\ndp[index_i][index_j] = dp[index_i-1][index_j-1]\nelse:\ndp[index_i][index_j] = 1 + min(dp[index_i-1][index_j], dp[index_i-1][index_j-1], dp[index_i][index_j-1])\nreturn dp[m][n]",
                        "max_stars_repo_name": "rampup01/Leetcode",
                        "max_stars_repo_path": "1-100q/72.py",
                        "max_stars_count": 990,
                        "__cluster__": 244
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_4588448",
                        "content": "<reponame>gosiqueira/blind-75<filename>array/0121_best_time_to_buy_and_sell_stocks.py\n\"\"\"\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\nConstraints:\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n\"\"\"\nfrom typing import List\ndef maxProfit(prices: List[int]) -> int:\n\"\"\"\nTime: O(n)\nSpace: O(1)\n\"\"\"\nbuy = float('inf')\nprofit = 0\nfor price in prices:\nbuy = min(price, buy)\nprofit = max(price - buy, profit)\nreturn profit\nif __name__ == '__main__':\n# Test 1\nprices = [7,1,5,3,6,4]\nprint(maxProfit(prices))\n# Test 2\nprices = [7,6,4,3,1]\nprint(maxProfit(prices))",
                        "max_stars_repo_name": "gosiqueira/blind-75",
                        "max_stars_repo_path": "array/0121_best_time_to_buy_and_sell_stocks.py",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_4588448",
                        "content": "<reponame>gosiqueira/blind-75<filename>array/0121_best_time_to_buy_and_sell_stocks.py\n\"\"\"\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\nConstraints:\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n\"\"\"\nfrom typing import List\ndef maxProfit(prices: List[int]) -> int:\n\"\"\"\nTime: O(n)\nSpace: O(1)\n\"\"\"\nbuy = float('inf')\nprofit = 0\nfor price in prices:\nbuy = min(price, buy)\nprofit = max(price - buy, profit)\nreturn profit\nif __name__ == '__main__':\n# Test 1\nprices = [7,1,5,3,6,4]\nprint(maxProfit(prices))\n# Test 2\nprices = [7,6,4,3,1]\nprint(maxProfit(prices))",
                        "max_stars_repo_name": "gosiqueira/blind-75",
                        "max_stars_repo_path": "array/0121_best_time_to_buy_and_sell_stocks.py",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_4588448",
                        "content": "<reponame>gosiqueira/blind-75<filename>array/0121_best_time_to_buy_and_sell_stocks.py\n\"\"\"\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\nConstraints:\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n\"\"\"\nfrom typing import List\ndef maxProfit(prices: List[int]) -> int:\n\"\"\"\nTime: O(n)\nSpace: O(1)\n\"\"\"\nbuy = float('inf')\nprofit = 0\nfor price in prices:\nbuy = min(price, buy)\nprofit = max(price - buy, profit)\nreturn profit\nif __name__ == '__main__':\n# Test 1\nprices = [7,1,5,3,6,4]\nprint(maxProfit(prices))\n# Test 2\nprices = [7,6,4,3,1]\nprint(maxProfit(prices))",
                        "max_stars_repo_name": "gosiqueira/blind-75",
                        "max_stars_repo_path": "array/0121_best_time_to_buy_and_sell_stocks.py",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```python\ndef maxProfit(prices):\nminPrice = float('inf')\nmaxProfit = 0\nfor price in prices:\nminPrice = min(minPrice, price)\nmaxProfit = max(maxProfit, price - minPrice)\nreturn maxProfit\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "id": "pretrain_python_data_4588448",
                        "content": "<reponame>gosiqueira/blind-75<filename>array/0121_best_time_to_buy_and_sell_stocks.py\n\"\"\"\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\nConstraints:\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n\"\"\"\nfrom typing import List\ndef maxProfit(prices: List[int]) -> int:\n\"\"\"\nTime: O(n)\nSpace: O(1)\n\"\"\"\nbuy = float('inf')\nprofit = 0\nfor price in prices:\nbuy = min(price, buy)\nprofit = max(price - buy, profit)\nreturn profit\nif __name__ == '__main__':\n# Test 1\nprices = [7,1,5,3,6,4]\nprint(maxProfit(prices))\n# Test 2\nprices = [7,6,4,3,1]\nprint(maxProfit(prices))",
                        "max_stars_repo_name": "gosiqueira/blind-75",
                        "max_stars_repo_path": "array/0121_best_time_to_buy_and_sell_stocks.py",
                        "max_stars_count": 0,
                        "__cluster__": 272
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_7727987",
                        "content": "<gh_stars>0\n\"\"\"Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport math\nclass Solution:\ndef isValidBST(self, root: TreeNode) -> bool:\ndef isValid(node, low=-math.inf, high=math.inf):\nif not node:\nreturn True\nif node.val >= high or node.val <= low:\nreturn False\nreturn isValid(node.right, node.val, high) and isValid(node.left, low, node.val)\nreturn isValid(root)",
                        "max_stars_repo_name": "H-isaac23/Data-Structures",
                        "max_stars_repo_path": "Validate Binary Search Tree.py",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_7727987",
                        "content": "<gh_stars>0\n\"\"\"Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport math\nclass Solution:\ndef isValidBST(self, root: TreeNode) -> bool:\ndef isValid(node, low=-math.inf, high=math.inf):\nif not node:\nreturn True\nif node.val >= high or node.val <= low:\nreturn False\nreturn isValid(node.right, node.val, high) and isValid(node.left, low, node.val)\nreturn isValid(root)",
                        "max_stars_repo_name": "H-isaac23/Data-Structures",
                        "max_stars_repo_path": "Validate Binary Search Tree.py",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_7727987",
                        "content": "<gh_stars>0\n\"\"\"Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\"\"\"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport math\nclass Solution:\ndef isValidBST(self, root: TreeNode) -> bool:\ndef isValid(node, low=-math.inf, high=math.inf):\nif not node:\nreturn True\nif node.val >= high or node.val <= low:\nreturn False\nreturn isValid(node.right, node.val, high) and isValid(node.left, low, node.val)\nreturn isValid(root)",
                        "max_stars_repo_name": "H-isaac23/Data-Structures",
                        "max_stars_repo_path": "Validate Binary Search Tree.py",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_9306440",
                        "content": "# Implement the myAtoi(string s) function, which converts a string to a 32-bit\n# signed integer (similar to C/C++'s atoi function).\n#\n#  The algorithm for myAtoi(string s) is as follows:\n#\n#\n#  Read in and ignore any leading whitespace.\n#  Check if the next character (if not already at the end of the string) is '-'\n# or '+'. Read this character in if it is either. This determines if the final\n# result is negative or positive respectively. Assume the result is positive if\n# neither is present.\n#  Read in next the characters until the next non-digit character or the end of\n# the input is reached. The rest of the string is ignored.\n#  Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If\n# no digits were read, then the integer is 0. Change the sign as necessary (from\n# step 2).\n#  If the integer is out of the 32-bit signed integer range [-2\u00b3\u00b9, 2\u00b3\u00b9 - 1],\n# then clamp the integer so that it remains in the range. Specifically, integers\n# less than -2\u00b3\u00b9 should be clamped to -2\u00b3\u00b9, and integers greater than 2\u00b3\u00b9 - 1 should\n# be clamped to 2\u00b3\u00b9 - 1.\n#  Return the integer as the final result.\n#\n#\n#  Note:\n#\n#\n#  Only the space character ' ' is considered a whitespace character.\n#  Do not ignore any characters other than the leading whitespace or the rest\n# of the string after the digits.\n#\n#\n#\n#  Example 1:\n#\n#\n# Input: s = \"42\"\n# Output: 42\n# Explanation: The underlined characters are what is read in, the caret is the\n# current reader position.\n# Step 1: \"42\" (no characters read because there is no leading whitespace)\n#          ^\n# Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n#          ^\n# Step 3: \"42\" (\"42\" is read in)\n#            ^\n# The parsed integer is 42.\n# Since 42 is in the range [-2\u00b3\u00b9, 2\u00b3\u00b9 - 1], the final result is 42.\n#\n#\n#  Example 2:\n#\n#\n# Input: s = \"   -42\"\n# Output: -42\n# Explanation:\n# Step 1: \"   -42\" (leading whitespace is read and ignored)\n#             ^\n# Step 2: \"   -42\" ('-' is read, so the result should be negative)\n#              ^\n# Step 3: \"   -42\" (\"42\" is read in)\n#                ^\n# The parsed integer is -42.\n# Since -42 is in the range [-2\u00b3\u00b9, 2\u00b3\u00b9 - 1], the final result is -42.\n#\n#\n#  Example 3:\n#\n#\n# Input: s = \"4193 with words\"\n# Output: 4193\n# Explanation:\n# Step 1: \"4193 with words\" (no characters read because there is no leading\n# whitespace)\n#          ^\n# Step 2: \"4193 with words\" (no characters read because there is neither a '-'\n# nor '+')\n#          ^\n# Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next\n# character is a non-digit)\n#              ^\n# The parsed integer is 4193.\n# Since 4193 is in the range [-2\u00b3\u00b9, 2\u00b3\u00b9 - 1], the final result is 4193.\n#\n#\n#\n#  Constraints:\n#\n#\n#  0 <= s.length <= 200\n#  s consists of English letters (lower-case and upper-case), digits (0-9), ' ',\n#  '+', '-', and '.'.\n#\n#  Related Topics String \ud83d\udc4d 1370 \ud83d\udc4e 3901\n# leetcode submit region begin(Prohibit modification and deletion)\nclass Solution:\ndef myAtoi(self, s: str) -> int:\n# leetcode submit region end(Prohibit modification and deletion)",
                        "max_stars_repo_name": "JieShenAI/leetcode",
                        "max_stars_repo_path": "[8]String to Integer (atoi).py",
                        "max_stars_count": 1,
                        "__cluster__": 212
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_8",
                        "content": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\nThe algorithm for `myAtoi(string s)` is as follows:\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n**Note:**\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n**Example 1:**\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"42 \" ( \"42 \" is read in)\n^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n**Example 2:**\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n**Example 3:**\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193.\n**Constraints:**\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.\nInput:\ns =  \"42 \"\nOutput:\n42\n```python\ndef myAtoi(s):\nresult, i, sign = 0, 0, 1\nwhile i < len(s) and s[i] == ' ': i += 1\nif i < len(s) and (s[i] == '-' or s[i] == '+'):\nsign = -1 if s[i] == '-' else 1\ni += 1\nwhile i < len(s) and s[i].isdigit():\nresult = result * 10 + int(s[i])\ni += 1\nif result * sign > 2**31 - 1: return 2**31 - 1\nif result * sign < -2**31: return -2**31\nreturn result * sign\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 212
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```python\ndef rob(nums):\nprev1, prev2 = 0, 0\nfor num in nums:\nprev1, prev2 = max(prev2 + num, prev1), prev1\nreturn prev1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 302
                },
                {
                        "id": "pretrain_python_data_12431377",
                        "content": "'''\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n'''\nclass Solution:\ndef rob(self, nums: List[int]) -> int:\n#handle base condition\nif(len(nums) == 0):\nreturn 0\nif(len(nums) == 1):\nreturn(nums[0])\nif(len(nums) == 2):\nreturn(max(nums[0],nums[1]))\ndp = [0 for _ in range(len(nums))]\ndp[0] = nums[0]\ndp[1] = max(nums[0],nums[1])\nfor i in range(2,len(nums)):\ndp[i] = max(nums[i]+dp[i-2],dp[i-1])\nreturn(dp[-1])\n",
                        "max_stars_repo_name": "harsh52/Assignments-competitive_coding",
                        "max_stars_repo_path": "Algo_practice/LeetCode/House_robber.py",
                        "max_stars_count": 8,
                        "__cluster__": 302
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```python\ndef rob(nums):\nprev1, prev2 = 0, 0\nfor num in nums:\nprev1, prev2 = max(prev2 + num, prev1), prev1\nreturn prev1\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 302
                },
                {
                        "id": "pretrain_python_data_12431377",
                        "content": "'''\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n'''\nclass Solution:\ndef rob(self, nums: List[int]) -> int:\n#handle base condition\nif(len(nums) == 0):\nreturn 0\nif(len(nums) == 1):\nreturn(nums[0])\nif(len(nums) == 2):\nreturn(max(nums[0],nums[1]))\ndp = [0 for _ in range(len(nums))]\ndp[0] = nums[0]\ndp[1] = max(nums[0],nums[1])\nfor i in range(2,len(nums)):\ndp[i] = max(nums[i]+dp[i-2],dp[i-1])\nreturn(dp[-1])\n",
                        "max_stars_repo_name": "harsh52/Assignments-competitive_coding",
                        "max_stars_repo_path": "Algo_practice/LeetCode/House_robber.py",
                        "max_stars_count": 8,
                        "__cluster__": 302
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_190",
                        "content": "Reverse bits of a given 32 bits unsigned integer.\n**Note:**\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.\n**Example 1:**\n**Input:** n = 00000010100101000001111010011100\n**Output:**    964176192 (00111001011110000010100101000000)\n**Explanation:** The input binary string **00000010100101000001111010011100** represents the unsigned integer 43261596, so return 964176192 which its binary representation is **00111001011110000010100101000000**.\n**Example 2:**\n**Input:** n = 11111111111111111111111111111101\n**Output:**   3221225471 (10111111111111111111111111111111)\n**Explanation:** The input binary string **11111111111111111111111111111101** represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is **10111111111111111111111111111111**.\n**Constraints:**\n*   The input must be a **binary string** of length `32`\n**Follow up:** If this function is called many times, how would you optimize it?\nInput:\nn = 00000010100101000001111010011100\nOutput:\n964176192 (00111001011110000010100101000000)\n```python\ndef reverse_bits(n: int) -> int:\nres = 0\nfor _ in range(32):\nres <<= 1\nres |= n & 1\nn >>= 1\nreturn res\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "id": "pretrain_python_data_10992016",
                        "content": "<reponame>vilisimo/ads\n# Reverse bits of a given 32 bits unsigned integer.\n# Note:\n# Note that in some languages, such as Java, there is no unsigned integer\n# type. In this case, both input and output will be given as a signed\n# integer type. They should not affect your implementation, as the integer's\n# internal binary representation is the same, whether it is signed or\n# unsigned.\n# In Java, the compiler represents the signed integers using 2's complement\n# notation. Therefore, in Example 2 above, the input represents the signed\n# integer -3 and the output represents the signed integer -1073741825.\n# Example 1:\n#   Input: n = 00000010100101000001111010011100\n#   Output:    964176192 (00111001011110000010100101000000)\n# Explanation: The input binary string 00000010100101000001111010011100\n# represents the unsigned integer 43261596, so return 964176192 which its\n# binary representation is 00111001011110000010100101000000.\n# Example 2:\n#   Input: n = 11111111111111111111111111111101\n#   Output:    3221225471 (10111111111111111111111111111111)\n# Explanation: The input binary string 11111111111111111111111111111101\n# represents the unsigned integer 4294967293, so return 3221225471 which\n# its binary representation is 10111111111111111111111111111111.\n# Constraints:\n#   The input must be a binary string of length 32\n# Follow up: If this function is called many times, how would you optimize it?\nclass InitialSolution:\ndef reverseBits(self, n: int) -> int:\nreturn int((f\"{n:#034b}\")[2:][::-1], 2)\nclass ExpandedSolution:\ndef reverseBits(self, n: int) -> int:\nbinary = f\"{n:#034b}\"\nresult = [binary[~i] for i in range(len(binary) - 2)]\nreverse = \"\".join(result)\nreturn int(reverse, 2)\nclass BitwiseOperationsSolution:\ndef reverseBits(self, n: int) -> int:\nresult = 0\nfor i in range(32):\nresult = (result << 1) + (n & 1)\nn >>= 1\nreturn result\nclass BitwiseOrSolution:\ndef reverseBits(self, n: int) -> int:\nresult = 0\nfor i in range(32):\nresult <<= 1\nresult |= n & 1\nn >>= 1\nreturn result",
                        "max_stars_repo_name": "vilisimo/ads",
                        "max_stars_repo_path": "python/leetcode/easy/ex0190.py",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_1456235",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\nres = head = ListNode()\ncarry = 0\nwhile l1 or l2:\na, b = 0, 0\nif l1:\na = l1.val\nif l2:\nb = l2.val\nsum = a + b + carry\nif sum < 10:\ncarry = 0\nelse:\nsum -= 10\ncarry = 1\nif l1:\nl1 = l1.next\nif l2:\nl2 = l2.next\nres.next = ListNode(sum)\nres = res.next\nif carry == 1:\nres.next = ListNode(1)\nreturn head.next",
                        "max_stars_repo_name": "jen-sjen/data-structures-basics-leetcode",
                        "max_stars_repo_path": "Leetcode/medium/add-two-numbers.py",
                        "max_stars_count": 6,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_1456235",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\nres = head = ListNode()\ncarry = 0\nwhile l1 or l2:\na, b = 0, 0\nif l1:\na = l1.val\nif l2:\nb = l2.val\nsum = a + b + carry\nif sum < 10:\ncarry = 0\nelse:\nsum -= 10\ncarry = 1\nif l1:\nl1 = l1.next\nif l2:\nl2 = l2.next\nres.next = ListNode(sum)\nres = res.next\nif carry == 1:\nres.next = ListNode(1)\nreturn head.next",
                        "max_stars_repo_name": "jen-sjen/data-structures-basics-leetcode",
                        "max_stars_repo_path": "Leetcode/medium/add-two-numbers.py",
                        "max_stars_count": 6,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_1456235",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\nres = head = ListNode()\ncarry = 0\nwhile l1 or l2:\na, b = 0, 0\nif l1:\na = l1.val\nif l2:\nb = l2.val\nsum = a + b + carry\nif sum < 10:\ncarry = 0\nelse:\nsum -= 10\ncarry = 1\nif l1:\nl1 = l1.next\nif l2:\nl2 = l2.next\nres.next = ListNode(sum)\nres = res.next\nif carry == 1:\nres.next = ListNode(1)\nreturn head.next",
                        "max_stars_repo_name": "jen-sjen/data-structures-basics-leetcode",
                        "max_stars_repo_path": "Leetcode/medium/add-two-numbers.py",
                        "max_stars_count": 6,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```python\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\ndef addTwoNumbers(l1, l2):\ndummy = ListNode(0)\ncurrent = dummy\ncarry = 0\nwhile l1 or l2 or carry:\nsum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\ncarry = sum_val // 10\ncurrent.next = ListNode(sum_val % 10)\ncurrent = current.next\nif l1: l1 = l1.next\nif l2: l2 = l2.next\nreturn dummy.next\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 205
                },
                {
                        "id": "pretrain_python_data_1456235",
                        "content": "\"\"\"\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\ndef __init__(self, val=0, next=None):\nself.val = val\nself.next = next\nclass Solution:\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\nres = head = ListNode()\ncarry = 0\nwhile l1 or l2:\na, b = 0, 0\nif l1:\na = l1.val\nif l2:\nb = l2.val\nsum = a + b + carry\nif sum < 10:\ncarry = 0\nelse:\nsum -= 10\ncarry = 1\nif l1:\nl1 = l1.next\nif l2:\nl2 = l2.next\nres.next = ListNode(sum)\nres = res.next\nif carry == 1:\nres.next = ListNode(1)\nreturn head.next",
                        "max_stars_repo_name": "jen-sjen/data-structures-basics-leetcode",
                        "max_stars_repo_path": "Leetcode/medium/add-two-numbers.py",
                        "max_stars_count": 6,
                        "__cluster__": 205
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_394",
                        "content": "Given an encoded string, return its decoded string.\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.\nThe test cases are generated so that the length of the output will never exceed `105`.\n**Example 1:**\n**Input:** s =  \"3\\[a\\]2\\[bc\\] \"\n**Output:**  \"aaabcbc \"\n**Example 2:**\n**Input:** s =  \"3\\[a2\\[c\\]\\] \"\n**Output:**  \"accaccacc \"\n**Example 3:**\n**Input:** s =  \"2\\[abc\\]3\\[cd\\]ef \"\n**Output:**  \"abcabccdcdcdef \"\n**Constraints:**\n*   `1 <= s.length <= 30`\n*   `s` consists of lowercase English letters, digits, and square brackets `'[]'`.\n*   `s` is guaranteed to be **a valid** input.\n*   All the integers in `s` are in the range `[1, 300]`.\nInput:\ns =  \"3\\[a\\]2\\[bc\\] \"\nOutput:\n\"aaabcbc \"\n```python\ndef decodeString(s):\ncounts = []\nresults = []\ncurrent = \"\"\nptr = 0\nwhile ptr < len(s):\nif s[ptr].isdigit():\ncount = 0\nwhile s[ptr].isdigit():\ncount = count * 10 + int(s[ptr])\nptr += 1\ncounts.append(count)\nelif s[ptr] == '[':\nresults.append(current)\ncurrent = \"\"\nptr += 1\nelif s[ptr] == ']':\nprev = results.pop()\ncount = counts.pop()\ncurrent = prev + current * count\nptr += 1\nelse:\ncurrent += s[ptr]\nptr += 1\nreturn current\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 397
                },
                {
                        "id": "pretrain_python_data_3123643",
                        "content": "<reponame>jiekun/reset\n# Given an encoded string, return its decoded string.\n# The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n# You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.\n# Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].\n# Example 1:\n# Input: s = \"3[a]2[bc]\"\n# Output: \"aaabcbc\"\n# Example 2:\n# Input: s = \"3[a2[c]]\"\n# Output: \"accaccacc\"\n# Example 3:\n# Input: s = \"2[abc]3[cd]ef\"\n# Output: \"abcabccdcdcdef\"\n# Constraints:\n# 1 <= s.length <= 30\n# s consists of lowercase English letters, digits, and square brackets '[]'.\n# s is guaranteed to be a valid input.\n# All the integers in s are in the range [1, 300].\nclass Solution(object):\ndef decodeString(self, s):\n\"\"\"\n:type s: str\n:rtype: str\n\"\"\"\nstack = []\ncur_num = 0\ncur_str = \"\"\nfor c in s:\nif c == \"[\":\nstack.append(cur_str)\nstack.append(cur_num)\ncur_str = \"\"\ncur_num = 0\nelif c == \"]\":\nnum = stack.pop()\npre_str = stack.pop()\ncur_str = pre_str + num * cur_str\nelif c.isdigit():\ncur_num = cur_num * 10 + int(c)\nelse:\ncur_str += c\nreturn cur_str",
                        "max_stars_repo_name": "jiekun/reset",
                        "max_stars_repo_path": "0394-decode-string.py",
                        "max_stars_count": 0,
                        "__cluster__": 397
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_394",
                        "content": "Given an encoded string, return its decoded string.\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.\nThe test cases are generated so that the length of the output will never exceed `105`.\n**Example 1:**\n**Input:** s =  \"3\\[a\\]2\\[bc\\] \"\n**Output:**  \"aaabcbc \"\n**Example 2:**\n**Input:** s =  \"3\\[a2\\[c\\]\\] \"\n**Output:**  \"accaccacc \"\n**Example 3:**\n**Input:** s =  \"2\\[abc\\]3\\[cd\\]ef \"\n**Output:**  \"abcabccdcdcdef \"\n**Constraints:**\n*   `1 <= s.length <= 30`\n*   `s` consists of lowercase English letters, digits, and square brackets `'[]'`.\n*   `s` is guaranteed to be **a valid** input.\n*   All the integers in `s` are in the range `[1, 300]`.\nInput:\ns =  \"3\\[a\\]2\\[bc\\] \"\nOutput:\n\"aaabcbc \"\n```python\ndef decodeString(s):\ncounts = []\nresults = []\ncurrent = \"\"\nptr = 0\nwhile ptr < len(s):\nif s[ptr].isdigit():\ncount = 0\nwhile s[ptr].isdigit():\ncount = count * 10 + int(s[ptr])\nptr += 1\ncounts.append(count)\nelif s[ptr] == '[':\nresults.append(current)\ncurrent = \"\"\nptr += 1\nelif s[ptr] == ']':\nprev = results.pop()\ncount = counts.pop()\ncurrent = prev + current * count\nptr += 1\nelse:\ncurrent += s[ptr]\nptr += 1\nreturn current\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 397
                },
                {
                        "id": "pretrain_python_data_3123643",
                        "content": "<reponame>jiekun/reset\n# Given an encoded string, return its decoded string.\n# The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n# You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.\n# Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].\n# Example 1:\n# Input: s = \"3[a]2[bc]\"\n# Output: \"aaabcbc\"\n# Example 2:\n# Input: s = \"3[a2[c]]\"\n# Output: \"accaccacc\"\n# Example 3:\n# Input: s = \"2[abc]3[cd]ef\"\n# Output: \"abcabccdcdcdef\"\n# Constraints:\n# 1 <= s.length <= 30\n# s consists of lowercase English letters, digits, and square brackets '[]'.\n# s is guaranteed to be a valid input.\n# All the integers in s are in the range [1, 300].\nclass Solution(object):\ndef decodeString(self, s):\n\"\"\"\n:type s: str\n:rtype: str\n\"\"\"\nstack = []\ncur_num = 0\ncur_str = \"\"\nfor c in s:\nif c == \"[\":\nstack.append(cur_str)\nstack.append(cur_num)\ncur_str = \"\"\ncur_num = 0\nelif c == \"]\":\nnum = stack.pop()\npre_str = stack.pop()\ncur_str = pre_str + num * cur_str\nelif c.isdigit():\ncur_num = cur_num * 10 + int(c)\nelse:\ncur_str += c\nreturn cur_str",
                        "max_stars_repo_name": "jiekun/reset",
                        "max_stars_repo_path": "0394-decode-string.py",
                        "max_stars_count": 0,
                        "__cluster__": 397
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_3143844",
                        "content": "<reponame>ha-khan/PythonPractice\n# A message containing letters from A-Z can be encoded into numbers using the following mapping:\n#\n# 'A' -> \"1\"\n# 'B' -> \"2\"\n# ...\n# 'Z' -> \"26\"\n#\n# To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n#     \"AAJF\" with the grouping (1 1 10 6)\n#     \"KJF\" with the grouping (11 10 6)\n# Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\n# Given a string s containing only digits, return the number of ways to decode it.\n# The test cases are generated so that the answer fits in a 32-bit integer.\n# Example 1:\n# Input: s = \"12\"\n# Output: 2\n# Explanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n# Example 2:\n# Input: s = \"226\"\n# Output: 3\n# Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n# Example 3:\n# Input: s = \"06\"\n# Output: 0\n# Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\").\n# Constraints:\n#     1 <= s.length <= 100\n#     s contains only digits and may contain leading zero(s).",
                        "max_stars_repo_name": "ha-khan/PythonPractice",
                        "max_stars_repo_path": "Sequence/DecodeWays/main.py",
                        "max_stars_count": 0,
                        "__cluster__": 258
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_91",
                        "content": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n**Example 1:**\n**Input:** s =  \"12 \"\n**Output:** 2\n**Explanation:**  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12).\n**Example 2:**\n**Input:** s =  \"226 \"\n**Output:** 3\n**Explanation:**  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6).\n**Example 3:**\n**Input:** s =  \"06 \"\n**Output:** 0\n**Explanation:**  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \").\n**Constraints:**\n*   `1 <= s.length <= 100`\n*   `s` contains only digits and may contain leading zero(s).\nInput:\ns =  \"12 \"\nOutput:\n2\n```python\ndef numDecodings(s: str) -> int:\nn = len(s)\ndp = [0] * (n + 1)\ndp[0] = 1\ndp[1] = 1 if s[0] != '0' else 0\nfor i in range(2, n + 1):\none_digit = int(s[i - 1:i])\ntwo_digits = int(s[i - 2:i])\nif one_digit >= 1:\ndp[i] += dp[i - 1]\nif two_digits >= 10 and two_digits <= 26:\ndp[i] += dp[i - 2]\nreturn dp[n]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 258
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_4791020",
                        "content": "<reponame>s2503901ernie/LeetCode\n\"\"\"\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-2^31 <= Node.val <= 2^31 - 1\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\nclass Solution:\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\nreturn self.judge(root, -float(\"inf\"), float(\"inf\"))\ndef judge(self, node, min_value, max_value):\nif not node:\nreturn True\nif min_value < node.val < max_value:\ncurrent = True\nelse:\ncurrent = False\nleft = self.judge(node.left, min_value, node.val)\nright = self.judge(node.right, node.val, max_value)\nreturn current and left and right",
                        "max_stars_repo_name": "s2503901ernie/LeetCode",
                        "max_stars_repo_path": "Problems/BinarySearchTree/0098-ValidateBinarySearchTree.py",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_4791020",
                        "content": "<reponame>s2503901ernie/LeetCode\n\"\"\"\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-2^31 <= Node.val <= 2^31 - 1\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\nclass Solution:\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\nreturn self.judge(root, -float(\"inf\"), float(\"inf\"))\ndef judge(self, node, min_value, max_value):\nif not node:\nreturn True\nif min_value < node.val < max_value:\ncurrent = True\nelse:\ncurrent = False\nleft = self.judge(node.left, min_value, node.val)\nright = self.judge(node.right, node.val, max_value)\nreturn current and left and right",
                        "max_stars_repo_name": "s2503901ernie/LeetCode",
                        "max_stars_repo_path": "Problems/BinarySearchTree/0098-ValidateBinarySearchTree.py",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_4791020",
                        "content": "<reponame>s2503901ernie/LeetCode\n\"\"\"\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-2^31 <= Node.val <= 2^31 - 1\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\nclass Solution:\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\nreturn self.judge(root, -float(\"inf\"), float(\"inf\"))\ndef judge(self, node, min_value, max_value):\nif not node:\nreturn True\nif min_value < node.val < max_value:\ncurrent = True\nelse:\ncurrent = False\nleft = self.judge(node.left, min_value, node.val)\nright = self.judge(node.right, node.val, max_value)\nreturn current and left and right",
                        "max_stars_repo_name": "s2503901ernie/LeetCode",
                        "max_stars_repo_path": "Problems/BinarySearchTree/0098-ValidateBinarySearchTree.py",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_7979160",
                        "content": "<gh_stars>1-10\n'''\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 10^4].\n-2^31 <= Node.val <= 2^31 - 1\n'''\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef isValidBSTUtil(self, node, maxm=(2**32-1), minm=(-2**32)):\nif node is None:\nreturn True\nif node.val < minm or node.val > maxm:\nreturn False\nreturn (self.isValidBSTUtil(node.left, maxm=(node.val-1), minm=minm) \\\nand self.isValidBSTUtil(node.right, maxm=maxm, minm=(node.val+1)))\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\nreturn self.isValidBSTUtil(root)\n#         if root:\n#             is_valid = True\n#             if root.left:\n#                 if root.left.val < root.val:\n#                     is_valid = self.isValidBST(root.left)\n#                 else:\n#                     is_valid = False\n#             if root.right:\n#                 if root.right.val > root.val:\n#                     is_valid = self.isValidBST(root.right)\n#                 else:\n#                     is_valid = False\n#             return is_valid\n#         else:\n#             return True",
                        "max_stars_repo_name": "Anshul-GH/interview_prep",
                        "max_stars_repo_path": "interviewee/05_leetcode/tree_validate_bst.py",
                        "max_stars_count": 1,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_7979160",
                        "content": "<gh_stars>1-10\n'''\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 10^4].\n-2^31 <= Node.val <= 2^31 - 1\n'''\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef isValidBSTUtil(self, node, maxm=(2**32-1), minm=(-2**32)):\nif node is None:\nreturn True\nif node.val < minm or node.val > maxm:\nreturn False\nreturn (self.isValidBSTUtil(node.left, maxm=(node.val-1), minm=minm) \\\nand self.isValidBSTUtil(node.right, maxm=maxm, minm=(node.val+1)))\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\nreturn self.isValidBSTUtil(root)\n#         if root:\n#             is_valid = True\n#             if root.left:\n#                 if root.left.val < root.val:\n#                     is_valid = self.isValidBST(root.left)\n#                 else:\n#                     is_valid = False\n#             if root.right:\n#                 if root.right.val > root.val:\n#                     is_valid = self.isValidBST(root.right)\n#                 else:\n#                     is_valid = False\n#             return is_valid\n#         else:\n#             return True",
                        "max_stars_repo_name": "Anshul-GH/interview_prep",
                        "max_stars_repo_path": "interviewee/05_leetcode/tree_validate_bst.py",
                        "max_stars_count": 1,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```python\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef isValidBSTHelper(node, min_val, max_val):\nif node is None:\nreturn True\nif not min_val < node.val < max_val:\nreturn False\nreturn (isValidBSTHelper(node.left, min_val, node.val) and\nisValidBSTHelper(node.right, node.val, max_val))\ndef isValidBST(root):\nreturn isValidBSTHelper(root, float('-inf'), float('inf'))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_python_data_7979160",
                        "content": "<gh_stars>1-10\n'''\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 10^4].\n-2^31 <= Node.val <= 2^31 - 1\n'''\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef isValidBSTUtil(self, node, maxm=(2**32-1), minm=(-2**32)):\nif node is None:\nreturn True\nif node.val < minm or node.val > maxm:\nreturn False\nreturn (self.isValidBSTUtil(node.left, maxm=(node.val-1), minm=minm) \\\nand self.isValidBSTUtil(node.right, maxm=maxm, minm=(node.val+1)))\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\nreturn self.isValidBSTUtil(root)\n#         if root:\n#             is_valid = True\n#             if root.left:\n#                 if root.left.val < root.val:\n#                     is_valid = self.isValidBST(root.left)\n#                 else:\n#                     is_valid = False\n#             if root.right:\n#                 if root.right.val > root.val:\n#                     is_valid = self.isValidBST(root.right)\n#                 else:\n#                     is_valid = False\n#             return is_valid\n#         else:\n#             return True",
                        "max_stars_repo_name": "Anshul-GH/interview_prep",
                        "max_stars_repo_path": "interviewee/05_leetcode/tree_validate_bst.py",
                        "max_stars_count": 1,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_9536039",
                        "content": "<gh_stars>1-10\n\"\"\"\nGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\nExample 1:\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\nExample 3:\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\nExample 4:\nInput: s = \"adceb\", p = \"*a*b\"\nOutput: true\nExplanation: The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\".\nExample 5:\nInput: s = \"acdcb\", p = \"a*c?b\"\nOutput: false\nConstraints:\n0 <= s.length, p.length <= 2000\ns contains only lowercase English letters.\np contains only lowercase English letters, '?' or '*'.\n\"\"\"\nclass Solution1:\ndef isMatch(self, s: str, p: str) -> bool:\nm, n = len(s), len(p)\ndp = [[False] * (n + 1) for _ in range(m + 1)]\ndp[0][0] = True\nfor j in range(1, n + 1):\nif p[j - 1] == '*':\ndp[0][j] = True\nelse:\nbreak\nfor i in range(1, m + 1):\nfor j in range(1, n + 1):\nif p[j - 1] == '?' or p[j - 1] == s[i - 1]:\ndp[i][j] = dp[i - 1][j - 1]\nelif p[j - 1] == '*':\ndp[i][j] = dp[i][j - 1] or dp[i - 1][j]\nreturn dp[m][n]\nclass Solution2:\ndef isMatch(self, s: str, p: str) -> bool:\nm, n = len(s), len(p)\ni, j = 0, 0\nstar, last_str = -1, -1\nwhile i < m:\nch = p[j] if j < n else None\nif ch == '?' or ch == s[i]:\ni += 1\nj += 1\nelif ch == '*':\nlast_str = i\nstar = j\nj += 1\nelif star != -1:\nlast_str += 1\ni = last_str\nj = star + 1\nelse:\nreturn False\nwhile j < n and p[j] == '*':\nj += 1\nreturn j == n",
                        "max_stars_repo_name": "qianbinbin/leetcode",
                        "max_stars_repo_path": "python3/leetcodepy/wildcard_matching.py",
                        "max_stars_count": 4,
                        "__cluster__": 227
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_44",
                        "content": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\nThe matching should cover the **entire** input string (not partial).\n**Example 1:**\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n**Example 2:**\n**Input:** s =  \"aa \", p =  \"\\* \"\n**Output:** true\n**Explanation:** '\\*' matches any sequence.\n**Example 3:**\n**Input:** s =  \"cb \", p =  \"?a \"\n**Output:** false\n**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n**Constraints:**\n*   `0 <= s.length, p.length <= 2000`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'?'` or `'*'`.\nInput:\ns =  \"aa \", p =  \"a \"\nOutput:\nfalse\n```python\ndef is_match(s: str, p: str) -> bool:\nm, n = len(s), len(p)\ni = j = 0\nmatch = asterisk = -1\nwhile i < m:\nif j < n and (s[i] == p[j] or p[j] == '?'):\ni, j = i + 1, j + 1\nelif j < n and p[j] == '*':\nmatch, asterisk = i, j\nj += 1\nelif asterisk >= 0:\ni, j = match + 1, asterisk + 1\nmatch += 1\nelse:\nreturn False\nwhile j < n and p[j] == '*':\nj += 1\nreturn j == n\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 227
                },
                {
                        "real_dup": 1
                }
        ],


        [
                {
                        "id": "pretrain_python_data_9496654",
                        "content": "<filename>questions/wiggle-sort-ii/Solution.py\n\"\"\"\nGiven an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\nYou may assume the input array always has a valid answer.\nExample 1:\nInput: nums = [1,5,1,1,6,4]\nOutput: [1,6,1,5,1,4]\nExplanation: [1,4,1,5,1,6] is also accepted.\nExample 2:\nInput: nums = [1,3,2,2,3,1]\nOutput: [2,3,1,3,1,2]\nConstraints:\n1 <= nums.length <= 5 * 104\n0 <= nums[i] <= 5000\nIt is guaranteed that there will be an answer for the given input nums.\nFollow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?\n\"\"\"\nclass Solution:\ndef wiggleSort(self, nums: List[int]) -> None:\n\"\"\"\nDo not return anything, modify nums in-place instead.\n\"\"\"\nnums.sort()\nhalf = len(nums[::2])\nnums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]",
                        "max_stars_repo_name": "achow113/LeetCode",
                        "max_stars_repo_path": "questions/wiggle-sort-ii/Solution.py",
                        "max_stars_count": 141,
                        "__cluster__": 123
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_324",
                        "content": "Given an integer array `nums`, reorder it such that `nums[0] < nums[1] > nums[2] < nums[3]...`.\nYou may assume the input array always has a valid answer.\n**Example 1:**\n**Input:** nums = \\[1,5,1,1,6,4\\]\n**Output:** \\[1,6,1,5,1,4\\]\n**Explanation:** \\[1,4,1,5,1,6\\] is also accepted.\n**Example 2:**\n**Input:** nums = \\[1,3,2,2,3,1\\]\n**Output:** \\[2,3,1,3,1,2\\]\n**Constraints:**\n*   `1 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 5000`\n*   It is guaranteed that there will be an answer for the given input `nums`.\n**Follow Up:** Can you do it in `O(n)` time and/or **in-place** with `O(1)` extra space?\nInput:\nnums = \\[1,5,1,1,6,4\\]\nOutput:\n\\[1,6,1,5,1,4\\]\n```python\ndef wiggleSort(nums):\nnums.sort()\nfor i in range(1, len(nums) - 1, 2):\nnums[i], nums[i + 1] = nums[i + 1], nums[i]\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 123
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_python_data_9439792",
                        "content": "<filename>python/0141_linked_list_cycle.py\n# Source : https://leetcode.com/problems/linked-list-cycle/\n# Author : <NAME>\n# Date   : 2021-02-03\n###############################################################################\n#\n# Given `head`, the head of a linked list, determine if the linked list has a\n# cycle in it.\n#\n# There is a cycle in a linked list if there is some node in the list that can\n# be reached again by continuously following the `next` pointer. Internally,\n# `pos` is used to denote the index of the node that tail's `next` pointer is\n# connected to. Note that `pos` is not passed as a parameter.\n#\n# Return `true` if there is a cycle in the linked list. Otherwise, return\n# `false`.\n#\n# Example 1:\n#\n# Input: head = [3,2,0,-4], pos = 1\n# Output: true\n# Explanation: There is a cycle in the linked list, where the tail connects to\n# the 1st node (0-indexed).\n#\n# Example 2:\n#\n# Input: head = [1,2], pos = 0\n# Output: true\n# Explanation: There is a cycle in the linked list, where the tail connects to\n# the 0th node.\n#\n# Example 3:\n#\n# Input: head = [1], pos = -1\n# Output: false\n# Explanation: There is no cycle in the linked list.\n#\n# Constraints:\n#\n# The number of the nodes in the list is in the range `[0, 104]`.\n# `-105 <= Node.val <= 105`\n# `pos` is `-1` or a valid index in the linked-list.\n#\n# Follow up: Can you solve it using `O(1)` (i.e. constant) memory?\n#\n###############################################################################\nclass Solution:\ndef hasCycle(self, head: ListNode) -> bool:\ntry:\nslow = head\nfast = head.next\nwhile slow is not fast:\nslow = slow.next\nfast = fast.next.next\nreturn True\nexcept:\nreturn False",
                        "max_stars_repo_name": "willheryanto/leetcode",
                        "max_stars_repo_path": "python/0141_linked_list_cycle.py",
                        "max_stars_count": 0,
                        "__cluster__": 287
                },
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_141",
                        "content": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\nReturn `true` _if there is a cycle in the linked list_. Otherwise, return `false`.\n**Example 1:**\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n**Example 2:**\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.\n**Example 3:**\n**Input:** head = \\[1\\], pos = -1\n**Output:** false\n**Explanation:** There is no cycle in the linked list.\n**Constraints:**\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?\nInput:\nhead = \\[3,2,0,-4\\], pos = 1\nOutput:\ntrue\n```python\ndef hasCycle(head):\nslow = fast = head\nwhile fast is not None and fast.next is not None:\nslow = slow.next\nfast = fast.next.next\nif slow == fast:\nreturn True\nreturn False\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 287
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_104",
                        "content": "Given the `root` of a binary tree, return _its maximum depth_.\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 3\n**Example 2:**\n**Input:** root = \\[1,null,2\\]\n**Output:** 2\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-100 <= Node.val <= 100`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n3\n```python\ndef maxDepth(root):\nif root is None:\nreturn 0\nreturn 1 + max(maxDepth(root.left), maxDepth(root.right))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 29
                },
                {
                        "id": "pretrain_python_data_11138730",
                        "content": "\"\"\"\n# MAXIMUM DEPTH OF BINARY TREE\nGiven the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\nExample 3:\nInput: root = []\nOutput: 0\nExample 4:\nInput: root = [0]\nOutput: 1\nConstraints:\nThe number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\nclass Solution:\ndef __init__(self):\nself.depth = 0\ndef maxDepth(self, root: TreeNode) -> int:\nself.find(root, 0)\nreturn self.depth\ndef find(self, root, count):\nif not root:\nself.depth = max(self.depth, count)\nreturn\nself.find(root.left, count + 1)\nself.find(root.right, count + 1)",
                        "max_stars_repo_name": "jen-sjen/data-structures-basics-leetcode",
                        "max_stars_repo_path": "Leetcode/easy/maximum-depth-of-binary-tree.py",
                        "max_stars_count": 6,
                        "__cluster__": 29
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_python_data_104",
                        "content": "Given the `root` of a binary tree, return _its maximum depth_.\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 3\n**Example 2:**\n**Input:** root = \\[1,null,2\\]\n**Output:** 2\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-100 <= Node.val <= 100`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n3\n```python\ndef maxDepth(root):\nif root is None:\nreturn 0\nreturn 1 + max(maxDepth(root.left), maxDepth(root.right))\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 29
                },
                {
                        "id": "pretrain_python_data_11138730",
                        "content": "\"\"\"\n# MAXIMUM DEPTH OF BINARY TREE\nGiven the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\nExample 3:\nInput: root = []\nOutput: 0\nExample 4:\nInput: root = [0]\nOutput: 1\nConstraints:\nThe number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\ndef __init__(self, val=0, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\nclass Solution:\ndef __init__(self):\nself.depth = 0\ndef maxDepth(self, root: TreeNode) -> int:\nself.find(root, 0)\nreturn self.depth\ndef find(self, root, count):\nif not root:\nself.depth = max(self.depth, count)\nreturn\nself.find(root.left, count + 1)\nself.find(root.right, count + 1)",
                        "max_stars_repo_name": "jen-sjen/data-structures-basics-leetcode",
                        "max_stars_repo_path": "Leetcode/easy/maximum-depth-of-binary-tree.py",
                        "max_stars_count": 6,
                        "__cluster__": 29
                },
                {
                        "real_dup": "2"
                }
        ]
]