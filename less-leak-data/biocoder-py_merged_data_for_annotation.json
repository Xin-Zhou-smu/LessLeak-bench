[
        {
                "data_len": 1
        },
        [
                {
                        "id": "pretrain_python_data_3862802",
                        "content": "\"\"\"Robust estimators of central tendency and scale.\nSee:\nhttps://en.wikipedia.org/wiki/Robust_measures_of_scale\nhttps://astropy.readthedocs.io/en/latest/_modules/astropy/stats/funcs.html\n\"\"\"\nimport sys\nfrom functools import wraps\nimport numpy as np\nfrom scipy import stats\n# Decorators to coerce input and short-circuit trivial cases\ndef on_array(default=None):\n\"\"\"Ensure `a` is a numpy array with no missing/NaN values.\"\"\"\ndef outer(f):\n@wraps(f)\ndef wrapper(a, **kwargs):\na = np.asfarray(a)\na = a[~np.isnan(a)]\nif not len(a):\nreturn np.nan\nif len(a) == 1:\nif default is None:\nreturn a[0]\nreturn default\nreturn f(a, **kwargs)\nreturn wrapper\nreturn outer\ndef on_weighted_array(default=None):\n\"\"\"Ensure `a` and `w` are equal-length numpy arrays with no NaN values.\nFor weighted descriptives -- `a` is the array of values, `w` is weights.\n1. Drop any cells in `a` that are NaN from both `a` and `w`\n2. Replace any remaining NaN cells in `w` with 0.\n\"\"\"\ndef outer(f):\n@wraps(f)\ndef wrapper(a, w, **kwargs):\nif len(a) != len(w):\nraise ValueError(\"Unequal array lengths: a=%d, w=%d\"\n% (len(a), len(w)))\nif not len(a):\nreturn np.nan\na = np.asfarray(a)\nw = np.asfarray(w)\n# Drop a's NaN indices from both arrays\na_nan = np.isnan(a)\nif a_nan.any():\na = a[~a_nan]\nif not len(a):\nreturn np.nan\nw = w[~a_nan]\nif len(a) == 1:\nif default is None:\nreturn a[0]\nreturn default\n# Fill w's NaN indices\nw_nan = np.isnan(w)\nif w_nan.any():\nw[w_nan] = 0.0\nreturn f(a, w, **kwargs)\nreturn wrapper\nreturn outer\n# M-estimators of central location\n@on_array()\ndef biweight_location(a, initial=None, c=6.0, epsilon=1e-3, max_iter=5):\n\"\"\"Compute the biweight location for an array.\nThe biweight is a robust statistic for estimating the central location of a\ndistribution.\n\"\"\"\ndef biloc_iter(a, initial):\n# Weight the observations by distance from initial estimate\nd = a - initial\nmad = np.median(np.abs(d))\nw = d / max(c * mad, epsilon)\nw = (1 - w**2)**2\n# Omit the outlier points\nmask = (w < 1)\nweightsum = w[mask].sum()\nif weightsum == 0:\n# Insufficient variation to improve the initial estimate\nreturn initial\nreturn initial + (d[mask] * w[mask]).sum() / weightsum\nif initial is None:\ninitial = np.median(a)\nfor _i in range(max_iter):\nresult = biloc_iter(a, initial)\nif abs(result - initial) <= epsilon:\nbreak\ninitial = result\nreturn result\n@on_array()\ndef modal_location(a):\n\"\"\"Return the modal value of an array's values.\nThe \"mode\" is the location of peak density among the values, estimated using\na Gaussian kernel density estimator.\nParameters\n----------\na : np.array\nA 1-D array of floating-point values, e.g. bin log2 ratio values.\n\"\"\"\nsarr = np.sort(a)\nkde = stats.gaussian_kde(sarr)\ny = kde.evaluate(sarr)\npeak = sarr[y.argmax()]\nreturn peak\n@on_weighted_array()\ndef weighted_median(a, weights):\n\"\"\"Weighted median of a 1-D numeric array.\"\"\"\norder = a.argsort()\na = a[order]\nweights = weights[order]\nmidpoint = 0.5 * weights.sum()\nif (weights > midpoint).any():\n# Any point with the majority of total weight must be the median\nreturn a[weights.argmax()]\ncumulative_weight = weights.cumsum()\nmidpoint_idx = cumulative_weight.searchsorted(midpoint)\nif (midpoint_idx > 0 and\ncumulative_weight[midpoint_idx-1] - midpoint < sys.float_info.epsilon):\n# Midpoint of 2 array values\nreturn a[midpoint_idx-1 : midpoint_idx+1].mean()\nreturn a[midpoint_idx]\n# Estimators of scale\n@on_array(0)\ndef biweight_midvariance(a, initial=None, c=9.0, epsilon=1e-3):\n\"\"\"Compute the biweight midvariance for an array.\nThe biweight midvariance is a robust statistic for determining the\nmidvariance (i.e. the standard deviation) of a distribution.\nSee:\n- https://en.wikipedia.org/wiki/Robust_measures_of_scale#The_biweight_midvariance\n- https://astropy.readthedocs.io/en/latest/_modules/astropy/stats/funcs.html\n\"\"\"\nif initial is None:\ninitial = biweight_location(a)\n# Difference of observations from initial location estimate\nd = a - initial\n# Weighting (avoid dividing by zero)\nmad = np.median(np.abs(d))\nw = d / max(c * mad, epsilon)\n# Omit the outlier points\nmask = np.abs(w) < 1\nif w[mask].sum() == 0:\n# Insufficient variation to improve on MAD\nreturn mad * 1.4826\nn = mask.sum()\nd_ = d[mask]\nw_ = (w**2)[mask]\nreturn np.sqrt((n * (d_**2 * (1 - w_)**4).sum())\n/ (((1 - w_) * (1 - 5 * w_)).sum()**2))\n@on_array(0)\ndef gapper_scale(a):\n\"\"\"Scale estimator based on gaps between order statistics.\nSee:\n- <NAME> (1976)\n- Beers, Flynn, and Gebhardt (1990)\n\"\"\"\ngaps = np.diff(np.sort(a))\nn = len(a)\nidx = np.arange(1, n)\nweights = idx * (n - idx)\nreturn (gaps * weights).sum() * np.sqrt(np.pi) / (n * (n - 1))\n@on_array(0)\ndef interquartile_range(a):\n\"\"\"Compute the difference between the array's first and third quartiles.\"\"\"\nreturn np.percentile(a, 75) - np.percentile(a, 25)\n@on_array(0)\ndef median_absolute_deviation(a, scale_to_sd=True):\n\"\"\"Compute the median absolute deviation (MAD) of array elements.\nThe MAD is defined as: ``median(abs(a - median(a)))``.\nSee: https://en.wikipedia.org/wiki/Median_absolute_deviation\n\"\"\"\na_median = np.median(a)\nmad = np.median(np.abs(a - a_median))\nif scale_to_sd:\nmad *= 1.4826\nreturn mad\n@on_weighted_array()\ndef weighted_mad(a, weights, scale_to_sd=True):\n\"\"\"Median absolute deviation (MAD) with weights.\"\"\"\na_median = weighted_median(a, weights)\nmad = weighted_median(np.abs(a - a_median), weights)\nif scale_to_sd:\nmad *= 1.4826\nreturn mad\n@on_weighted_array()\ndef weighted_std(a, weights):\n\"\"\"Standard deviation with weights.\"\"\"\nmean = np.average(a, weights=weights)\nvar = np.average((a - mean) ** 2, weights=weights)\nreturn np.sqrt(var)\n@on_array(0)\ndef mean_squared_error(a, initial=None):\n\"\"\"Mean squared error (MSE).\nBy default, assume the input array `a` is the residuals/deviations/error,\nso MSE is calculated from zero. Another reference point for calculating the\nerror can be specified with `initial`.\n\"\"\"\nif initial is None:\ninitial = a.mean()\nif initial:\na = a - initial\nreturn (a ** 2).mean()\n@on_array(0)\ndef q_n(a):\n\"\"\"Rousseeuw & Croux's (1993) Q_n, an alternative to MAD.\n``Qn := Cn first quartile of (|x_i - x_j|: i < j)``\nwhere Cn is a constant depending on n.\nFinite-sample correction factors must be used to calibrate the\nscale of Qn for small-to-medium-sized samples.\nn   E[Qn]\n--  -----\n10  1.392\n20  1.193\n40  1.093\n60  1.064\n80  1.048\n100 1.038\n200 1.019\n\"\"\"\n# First quartile of: (|x_i - x_j|: i < j)\nvals = []\nfor i, x_i in enumerate(a):\nfor x_j in a[i+1:]:\nvals.append(abs(x_i - x_j))\nquartile = np.percentile(vals, 25)\n# Cn: a scaling factor determined by sample size\nn = len(a)\nif n <= 10:\n# ENH: warn when extrapolating beyond the data\n# ENH: simulate for values up to 10\n#   (unless the equation below is reliable)\nscale = 1.392\nelif 10 < n < 400:\n# I fitted the simulated values (above) to a power function in Excel:\n#   f(x) = 1.0 + 3.9559 * x ^ -1.0086\n# This should be OK for interpolation. (Does it apply generally?)\nscale = 1.0 + (4 / n)\nelse:\nscale = 1.0\nreturn quartile / scale",
                        "max_stars_repo_path": "cnvlib/descriptives.py",
                        "max_stars_repo_name": "sridhar0605/cnvkit",
                        "max_stars_count": 342,
                        "__cluster__": 99
                },
                {
                        "id": "test_biocoder_data_112",
                        "content": "This is in python\nWrite a function called \"summarize_info\" that takes two arguments: \"all_logr\", a numpy array containing log2ratios, and \"all_depths\", another numpy array containing depths. The function calculates the average and spread of log2ratios and depths for a group of samples and returns the result in a dictionary format. The function utilizes the \"biweight_location\" and \"biweight_midvariance\" functions from the \"descriptives\" module of the \"CNVlib\" library. The function also logs the progress in two places where it is stated \"Calculating average bin coverages\" and \"Calculating bin spreads\".\nAverage & spread of log2ratios and depths for a group of samples.\nCan apply to all samples, or a given cluster of samples.\nimport random\nimport hashlib\nimport numpy as np\nimport skimage\nimport skimage.measure\nimport scipy.ndimage\nimport os\nimport logging\nfrom functools import wraps\nfrom scipy import stats\nimport sys\nimport math\nimport subprocess\nfrom pathlib import PurePath\nfrom itertools import islice\nimport pysam\n\"\"\"Robust estimators of central tendency and scale.\nSee:\nhttps://en.wikipedia.org/wiki/Robust_measures_of_scale\nhttps://astropy.readthedocs.io/en/latest/_modules/astropy/stats/funcs.html\n\"\"\"\nimport sys\nfrom functools import wraps\nimport numpy as np\nfrom scipy import stats\n# Decorators to coerce input and short-circuit trivial cases\ndef on_array(default=None):\n\"\"\"Ensure `a` is a numpy array with no missing/NaN values.\"\"\"\ndef outer(f):\n@wraps(f)\ndef wrapper(a, **kwargs):\na = np.asfarray(a)\na = a[~np.isnan(a)]\nif not len(a):\nreturn np.nan\nif len(a) == 1:\nif default is None:\nreturn a[0]\nreturn default\nreturn f(a, **kwargs)\nreturn wrapper\nreturn outer\ndef on_weighted_array(default=None):\n\"\"\"Ensure `a` and `w` are equal-length numpy arrays with no NaN values.\nFor weighted descriptives -- `a` is the array of values, `w` is weights.\n1. Drop any cells in `a` that are NaN from both `a` and `w`\n2. Replace any remaining NaN cells in `w` with 0.\n\"\"\"\ndef outer(f):\n@wraps(f)\ndef wrapper(a, w, **kwargs):\nif len(a) != len(w):\nraise ValueError(f\"Unequal array lengths: a={len(a)}, w={len(w)}\")\nif not len(a):\nreturn np.nan\na = np.asfarray(a)\nw = np.asfarray(w)\n# Drop a's NaN indices from both arrays\na_nan = np.isnan(a)\nif a_nan.any():\na = a[~a_nan]\nif not len(a):\nreturn np.nan\nw = w[~a_nan]\nif len(a) == 1:\nif default is None:\nreturn a[0]\nreturn default\n# Fill w's NaN indices\nw_nan = np.isnan(w)\nif w_nan.any():\nw[w_nan] = 0.0\nreturn f(a, w, **kwargs)\nreturn wrapper\nreturn outer\n# M-estimators of central location\n@on_array()\ndef biweight_location(a, initial=None, c=6.0, epsilon=1e-3, max_iter=5):\n\"\"\"Compute the biweight location for an array.\nThe biweight is a robust statistic for estimating the central location of a\ndistribution.\n\"\"\"\ndef biloc_iter(a, initial):\n# Weight the observations by distance from initial estimate\nd = a - initial\nmad = np.median(np.abs(d))\nw = d / max(c * mad, epsilon)\nw = (1 - w**2) ** 2\n# Omit the outlier points\nmask = w < 1\nweightsum = w[mask].sum()\nif weightsum == 0:\n# Insufficient variation to improve the initial estimate\nreturn initial\nreturn initial + (d[mask] * w[mask]).sum() / weightsum\nif initial is None:\ninitial = np.median(a)\nfor _i in range(max_iter):\nresult = biloc_iter(a, initial)\nif abs(result - initial) <= epsilon:\nbreak\ninitial = result\nreturn result\n@on_array()\ndef modal_location(a):\n\"\"\"Return the modal value of an array's values.\nThe \"mode\" is the location of peak density among the values, estimated using\na Gaussian kernel density estimator.\nParameters\n----------\na : np.array\nA 1-D array of floating-point values, e.g. bin log2 ratio values.\n\"\"\"\nsarr = np.sort(a)\nkde = stats.gaussian_kde(sarr)\ny = kde.evaluate(sarr)\npeak = sarr[y.argmax()]\nreturn peak\n@on_weighted_array()\ndef weighted_median(a, weights):\n\"\"\"Weighted median of a 1-D numeric array.\"\"\"\norder = a.argsort()\na = a[order]\nweights = weights[order]\nmidpoint = 0.5 * weights.sum()\nif (weights > midpoint).any():\n# Any point with the majority of total weight must be the median\nreturn a[weights.argmax()]\ncumulative_weight = weights.cumsum()\nmidpoint_idx = cumulative_weight.searchsorted(midpoint)\nif (\nmidpoint_idx > 0\nand cumulative_weight[midpoint_idx - 1] - midpoint < sys.float_info.epsilon\n):\n# Midpoint of 2 array values\nreturn a[midpoint_idx - 1 : midpoint_idx + 1].mean()\nreturn a[midpoint_idx]\n# Estimators of scale\n@on_array(0)\ndef biweight_midvariance(a, initial=None, c=9.0, epsilon=1e-3):\n\"\"\"Compute the biweight midvariance for an array.\nThe biweight midvariance is a robust statistic for determining the\nmidvariance (i.e. the standard deviation) of a distribution.\nSee:\n- https://en.wikipedia.org/wiki/Robust_measures_of_scale#The_biweight_midvariance\n- https://astropy.readthedocs.io/en/latest/_modules/astropy/stats/funcs.html\n\"\"\"\nif initial is None:\ninitial = biweight_location(a)\n# Difference of observations from initial location estimate\nd = a - initial\n# Weighting (avoid dividing by zero)\nmad = np.median(np.abs(d))\nw = d / max(c * mad, epsilon)\n# Omit the outlier points\nmask = np.abs(w) < 1\nif w[mask].sum() == 0:\n# Insufficient variation to improve on MAD\nreturn mad * 1.4826\nn = mask.sum()\nd_ = d[mask]\nw_ = (w**2)[mask]\nreturn np.sqrt(\n(n * (d_**2 * (1 - w_) ** 4).sum()) / (((1 - w_) * (1 - 5 * w_)).sum() ** 2)\n)\n@on_array(0)\ndef gapper_scale(a):\n\"\"\"Scale estimator based on gaps between order statistics.\nSee:\n- Wainer & Thissen (1976)\n- Beers, Flynn, and Gebhardt (1990)\n\"\"\"\ngaps = np.diff(np.sort(a))\nn = len(a)\nidx = np.arange(1, n)\nweights = idx * (n - idx)\nreturn (gaps * weights).sum() * np.sqrt(np.pi) / (n * (n - 1))\n@on_array(0)\ndef interquartile_range(a):\n\"\"\"Compute the difference between the array's first and third quartiles.\"\"\"\nreturn np.percentile(a, 75) - np.percentile(a, 25)\n@on_array(0)\ndef median_absolute_deviation(a, scale_to_sd=True):\n\"\"\"Compute the median absolute deviation (MAD) of array elements.\nThe MAD is defined as: ``median(abs(a - median(a)))``.\nSee: https://en.wikipedia.org/wiki/Median_absolute_deviation\n\"\"\"\na_median = np.median(a)\nmad = np.median(np.abs(a - a_median))\nif scale_to_sd:\nmad *= 1.4826\nreturn mad\n@on_weighted_array()\ndef weighted_mad(a, weights, scale_to_sd=True):\n\"\"\"Median absolute deviation (MAD) with weights.\"\"\"\na_median = weighted_median(a, weights)\nmad = weighted_median(np.abs(a - a_median), weights)\nif scale_to_sd:\nmad *= 1.4826\nreturn mad\n@on_weighted_array()\ndef weighted_std(a, weights):\n\"\"\"Standard deviation with weights.\"\"\"\nmean = np.average(a, weights=weights)\nvar = np.average((a - mean) ** 2, weights=weights)\nreturn np.sqrt(var)\n@on_array(0)\ndef mean_squared_error(a, initial=None):\n\"\"\"Mean squared error (MSE).\nBy default, assume the input array `a` is the residuals/deviations/error,\nso MSE is calculated from zero. Another reference point for calculating the\nerror can be specified with `initial`.\n\"\"\"\nif initial is None:\ninitial = a.mean()\nif initial:\na = a - initial\nreturn (a**2).mean()\n@on_array(0)\ndef q_n(a):\n\"\"\"Rousseeuw & Croux's (1993) Q_n, an alternative to MAD.\n``Qn := Cn first quartile of (|x_i - x_j|: i < j)``\nwhere Cn is a constant depending on n.\nFinite-sample correction factors must be used to calibrate the\nscale of Qn for small-to-medium-sized samples.\nn   E[Qn]\n--  -----\n10  1.392\n20  1.193\n40  1.093\n60  1.064\n80  1.048\n100 1.038\n200 1.019\n\"\"\"\n# First quartile of: (|x_i - x_j|: i < j)\nvals = []\nfor i, x_i in enumerate(a):\nfor x_j in a[i + 1 :]:\nvals.append(abs(x_i - x_j))\nquartile = np.percentile(vals, 25)\n# Cn: a scaling factor determined by sample size\nn = len(a)\nif n <= 10:\n# ENH: warn when extrapolating beyond the data\n# ENH: simulate for values up to 10\n#   (unless the equation below is reliable)\nscale = 1.392\nelif 10 < n < 400:\n# I fitted the simulated values (above) to a power function in Excel:\n#   f(x) = 1.0 + 3.9559 * x ^ -1.0086\n# This should be OK for interpolation. (Does it apply generally?)\nscale = 1.0 + (4 / n)\nelse:\nscale = 1.0\nreturn quartile / scale\n<<insert solution here>>\ndef main():\nnp.random.seed(<|int;range=0,10000|>)\nall_logr = np.random.randint(20, size=(10, 10))\nnp.random.seed(<|int;range=0,10000|>)\nall_depths = np.random.randint(20, size=(10, 10))\nprint(summarize_info(all_logr, all_depths))\nif __name__ == \"__main__\":\nmain()\ndef summarize_info(all_logr, all_depths):\n\"\"\"Average & spread of log2ratios and depths for a group of samples.\nCan apply to all samples, or a given cluster of samples.\n\"\"\"\nlogging.info('Calculating average bin coverages')\ncvg_centers = np.apply_along_axis(biweight_location, 0,\nall_logr)\ndepth_centers = np.apply_along_axis(biweight_location, 0,\nall_depths)\nlogging.info('Calculating bin spreads')\nspreads = np.array([biweight_midvariance(a, initial=i) for\na, i in zip(all_logr.T, cvg_centers)])\nresult = {'log2': cvg_centers, 'depth': depth_centers, 'spread': spreads}\nreturn result",
                        "max_stars_repo_path": "cnvlib/reference.py",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 99
                },
                {
                        "real_dup": "1"
                }
        ]
]