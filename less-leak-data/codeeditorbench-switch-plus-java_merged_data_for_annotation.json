[
        {
                "data_len": 117
        },
        [
                {
                        "id": "pretrain_java_data_16038886",
                        "content": "/**\nThere is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.\nThe move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.\nNote: The way that the robot is \"facing\" is irrelevant. \"R\" will always make the robot move to the right once, \"L\" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\nExample 1:\nInput: moves = \"UD\"\nOutput: true\nExplanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\nExample 2:\nInput: moves = \"LL\"\nOutput: false\nExplanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves.\nExample 3:\nInput: moves = \"RRDD\"\nOutput: false\nExample 4:\nInput: moves = \"LDRRLRUULR\"\nOutput: false\nConstraints:\n1 <= moves.length <= 2 * 104\nmoves only contains the characters 'U', 'D', 'L' and 'R'\n*/\nclass Solution {\npublic boolean judgeCircle(String moves) {\nif (moves == null || moves.length() == 0) {\nreturn false;\n}\nint ud = 0;\nint rl = 0;\nfor (char c: moves.toCharArray()) {\nif (c == 'R') {\nrl++;\n} else if (c == 'L') {\nrl--;\n} else if (c == 'U') {\nud++;\n} else if (c == 'D') {\nud--;\n}\n}\nreturn ud == 0 && rl == 0;\n}\n}",
                        "max_stars_repo_path": "leetcode/easy/robot-return-to-origin/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 404
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_657",
                        "content": "There is a robot starting at the position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot **ends up at** `(0, 0)` after it completes its moves.\nYou are given a string `moves` that represents the move sequence of the robot where `moves[i]` represents its `ith` move. Valid moves are `'R'` (right), `'L'` (left), `'U'` (up), and `'D'` (down).\nReturn `true` _if the robot returns to the origin after it finishes all of its moves, or_ `false` _otherwise_.\n**Note**: The way that the robot is \"facing \" is irrelevant. `'R'` will always make the robot move to the right once, `'L'` will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n**Example 1:**\n**Input:** moves =  \"UD \"\n**Output:** true\n**Explanation**: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n**Example 2:**\n**Input:** moves =  \"LL \"\n**Output:** false\n**Explanation**: The robot moves left twice. It ends up two  \"moves \" to the left of the origin. We return false because it is not at the origin at the end of its moves.\n**Constraints:**\n*   `1 <= moves.length <= 2 * 104`\n*   `moves` only contains the characters `'U'`, `'D'`, `'L'` and `'R'`.\nInput:\nmoves =  \"UD \"\nOutput:\ntrue\n```java\npublic boolean judgeCircle(String moves) {\nint x = 0, y = 0;\nfor(char move : moves.toCharArray()) {\nif(move == 'U') y++;\nelse if(move == 'D') y--;\nelse if(move == 'R') x++;\nelse if(move == 'L') x--;\n}\nreturn x == 0 && y == 0;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 404
                },
                {
                        "shared string": ", the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ",
                        "real_dup": 1
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_16017336",
                        "content": "<reponame>Andreii/algo<gh_stars>0\n/*\n* @author <NAME>, <EMAIL>\n*/\npackage com.omtia.un;\n/**\n* You are given an integer array coins representing coins of different denominations and an integer amount\n* representing a total amount of money.\n*\n* Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up\n* by any combination of the coins, return -1.\n*\n* You may assume that you have an infinite number of each kind of coin.\n*\n*\n*\n* Example 1:\n*\n* Input: coins = [1,2,5], amount = 11\n* Output: 3\n* Explanation: 11 = 5 + 5 + 1\n* Example 2:\n*\n* Input: coins = [2], amount = 3\n* Output: -1\n* Example 3:\n*\n* Input: coins = [1], amount = 0\n* Output: 0\n*\n*\n* Constraints:\n*\n* 1 <= coins.length <= 12\n* 1 <= coins[i] <= 231 - 1\n* 0 <= amount <= 104\n*/\npublic class _322_coin_change {\npublic int coinChange(int[] coins, int amount) {\nint[] dp = new int[amount+1];\ndp[0] = 0;\nfor(int i = 1; i <= amount; i++) {\ndp[i] = amount+1;\nfor(int coin : coins) {\ndp[i] = Math.min(dp[i], i >= coin ? dp[i - coin] + 1: amount+1);\n}\n}\nreturn dp[amount] == amount+1 ? -1 : dp[amount];\n}\n}",
                        "max_stars_repo_path": "src/main/java/com/omtia/un/_322_coin_change.java",
                        "max_stars_repo_name": "Andreii/algo",
                        "max_stars_count": 0,
                        "__cluster__": 342
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_322",
                        "content": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\nYou may assume that you have an infinite number of each kind of coin.\n**Example 1:**\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n**Example 2:**\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n**Example 3:**\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0\n**Constraints:**\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`\nInput:\ncoins = \\[1,2,5\\], amount = 11\nOutput:\n3\n```java\npublic int coinChange(int[] coins, int amount) {\nint[] dp = new int[amount + 1];\nArrays.fill(dp, amount + 1);\ndp[0] = 0;\nfor (int coin : coins) {\nfor (int i = coin; i <= amount; i++) {\ndp[i] = Math.min(dp[i], dp[i - coin] + 1);\n}\n}\nreturn dp[amount] <= amount ? dp[amount] : -1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 342
                },
                {
                        "shared string": " You may assume that you have an infinite number of each kind of coin. *"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_16120590",
                        "content": "/*\nLC198. House Robber\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n*/\nclass Solution {\npublic int rob(int[] nums) {\nif (nums.length == 0) {\nreturn 0;\n}\nif (nums.length == 1) {\nreturn nums[0];\n}\nint one = 0;\nint two = nums[0];\nint maxAmount = 0;;\nfor (int i = 1; i < nums.length; i++)\n{\nmaxAmount = Math.max(one+nums[i], two);\none = two;\ntwo = maxAmount;\n}\nreturn maxAmount;\n}\n}",
                        "max_stars_repo_path": "src/LC198-HouseRobber.java",
                        "max_stars_repo_name": "RainbowDragon/LeetCode_Java",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_16120590",
                        "content": "/*\nLC198. House Robber\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n*/\nclass Solution {\npublic int rob(int[] nums) {\nif (nums.length == 0) {\nreturn 0;\n}\nif (nums.length == 1) {\nreturn nums[0];\n}\nint one = 0;\nint two = nums[0];\nint maxAmount = 0;;\nfor (int i = 1; i < nums.length; i++)\n{\nmaxAmount = Math.max(one+nums[i], two);\none = two;\ntwo = maxAmount;\n}\nreturn maxAmount;\n}\n}",
                        "max_stars_repo_path": "src/LC198-HouseRobber.java",
                        "max_stars_repo_name": "RainbowDragon/LeetCode_Java",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_16120590",
                        "content": "/*\nLC198. House Robber\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n*/\nclass Solution {\npublic int rob(int[] nums) {\nif (nums.length == 0) {\nreturn 0;\n}\nif (nums.length == 1) {\nreturn nums[0];\n}\nint one = 0;\nint two = nums[0];\nint maxAmount = 0;;\nfor (int i = 1; i < nums.length; i++)\n{\nmaxAmount = Math.max(one+nums[i], two);\none = two;\ntwo = maxAmount;\n}\nreturn maxAmount;\n}\n}",
                        "max_stars_repo_path": "src/LC198-HouseRobber.java",
                        "max_stars_repo_name": "RainbowDragon/LeetCode_Java",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_19201372",
                        "content": "<gh_stars>0\n/**\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\nConstraints:\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n*/\nclass Solution {\npublic int maxProfit(int[] prices) {\nint maxProfit = 0;\nint minPrice = Integer.MAX_VALUE;\nfor (int i = 0; i < prices.length; i++) {\nif (prices[i] < minPrice) {\nminPrice = prices[i];\n} else {\nmaxProfit = Math.max(maxProfit, prices[i] - minPrice);\n}\n}\nreturn maxProfit;\n}\n}",
                        "max_stars_repo_path": "leetcode/easy/best-time-to-buy-and-sell-stock/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 267
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_121",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n**Example 1:**\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n**Example 2:**\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n**Constraints:**\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`\nInput:\nprices = \\[7,1,5,3,6,4\\]\nOutput:\n5\n```java\npublic int maxProfit(int[] prices) {\nint minPrice = Integer.MAX_VALUE;\nint maxProfit = 0;\nfor (int price : prices) {\nminPrice = Math.min(minPrice, price);\nmaxProfit = Math.max(maxProfit, price - minPrice);\n}\nreturn maxProfit;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 267
                },
                {
                        "shared string": " Buy on day 2 (price = 1) and sell on day 5 (price = 6), profi"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_17726924",
                        "content": "package dp;\n/**\n* There is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n*\n* The cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.\n*\n*     For example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on...\n*\n* Return the minimum cost to paint all houses.\n*\n* Example 1:\n*\n* Input: costs = [[17,2,17],[16,16,5],[14,3,19]]\n* Output: 10\n* Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\n* Minimum cost: 2 + 5 + 3 = 10.\n*/\npublic class PaintHouse {\n//dp[i][j] is the min cost for first i houses ended with house i and color j\n//dp[i][j] = Math.min(dp[i - 1][!j] + costs[i][j])\n//\u6ce8\u610f\uff1a\u53ea\u9700\u8981\u7528\u5230\u4e4b\u524d\u623f\u5b50\u7684\u989c\u8272\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u4e24\u884c3\u5217\u5373\u53ef\u3002\npublic int minCost(int[][] costs) {\nif(costs == null || costs.length == 0 || costs[0].length == 0) return 0;\nint m = costs.length;\nint[][] dp = new int[2][3];\nfor(int i = 1; i <= m; i++) {\ndp[i % 2][0] = Math.min(dp[(i - 1) % 2][1], dp[(i - 1) % 2][2]) + costs[i - 1][0];\ndp[i % 2][1] = Math.min(dp[(i - 1) % 2][0], dp[(i - 1) % 2][2]) + costs[i - 1][1];\ndp[i % 2][2] = Math.min(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1]) + costs[i - 1][2];\n}\nreturn Math.min(Math.min(dp[m % 2][0], dp[m % 2][1]), dp[m % 2][2]);\n}\n}",
                        "max_stars_repo_path": "src/dp/PaintHouse.java",
                        "max_stars_repo_name": "gitmichaelz/LeetCodeByTags",
                        "max_stars_count": 0,
                        "__cluster__": 318
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_256",
                        "content": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\nReturn _the minimum cost to paint all houses_.\n**Example 1:**\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n**Example 2:**\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2\n**Constraints:**\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`\nInput:\ncosts = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\nOutput:\n10\n```java\npublic int minCost(int[][] costs) {\nif (costs.length == 0) return 0;\nfor (int i = 1; i < costs.length; i++) {\ncosts[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\ncosts[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\ncosts[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n}\nreturn Math.min(costs[costs.length - 1][0], Math.min(costs[costs.length - 1][1], costs[costs.length - 1][2]));\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 318
                },
                {
                        "shared string": " houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_42",
                        "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n**Example 1:**\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n**Example 2:**\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n**Constraints:**\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\nInput:\nheight = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\nOutput:\n6\n```java\npublic int trap(int[] height) {\nint n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (left < right) {\nif (height[left] <= height[right]) {\nmaxLeft = Math.max(maxLeft, height[left]);\nwater += maxLeft - height[left];\nleft++;\n} else {\nmaxRight = Math.max(maxRight, height[right]);\nwater += maxRight - height[right];\nright--;\n}\n}\nreturn water;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "id": "pretrain_java_data_8056014",
                        "content": "// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n// Example 1:\n// Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n// Output: 6\n// Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n// Example 2:\n// Input: height = [4,2,0,3,2,5]\n// Output: 9\n// Constraints:\n// n == height.length\n// 0 <= n <= 3 * 104\n// 0 <= height[i] <= 105\nclass Solution {\npublic int trap(int[] height) {\nint n = height.length, ans = 0;\nint[] left = new int[n];\nleft[0] = height[0];\nfor(int i = 1; i < n; i++)\nleft[i] = Math.max(left[i-1], height[i]);\nint[] right = new int[n];\nright[n-1] = height[n-1];\nfor(int i = n-2; i >= 0; i--)\nright[i] = Math.max(right[i+1], height[i]);\nfor(int i = 0; i < n; i++)\nans += Math.max(0, Math.min(left[i], right[i]) - height[i]);\nreturn ans;\n}\n}",
                        "max_stars_repo_path": "Two Pointers/Trapping-Rain-Water-42.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 237
                },
                {
                        "shared string": " non-negative integers representing an elevation map where the width of each bar is ",
                        "real_dup": 1
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_42",
                        "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n**Example 1:**\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n**Example 2:**\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n**Constraints:**\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\nInput:\nheight = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\nOutput:\n6\n```java\npublic int trap(int[] height) {\nint n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (left < right) {\nif (height[left] <= height[right]) {\nmaxLeft = Math.max(maxLeft, height[left]);\nwater += maxLeft - height[left];\nleft++;\n} else {\nmaxRight = Math.max(maxRight, height[right]);\nwater += maxRight - height[right];\nright--;\n}\n}\nreturn water;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "id": "pretrain_java_data_8056014",
                        "content": "// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n// Example 1:\n// Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n// Output: 6\n// Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n// Example 2:\n// Input: height = [4,2,0,3,2,5]\n// Output: 9\n// Constraints:\n// n == height.length\n// 0 <= n <= 3 * 104\n// 0 <= height[i] <= 105\nclass Solution {\npublic int trap(int[] height) {\nint n = height.length, ans = 0;\nint[] left = new int[n];\nleft[0] = height[0];\nfor(int i = 1; i < n; i++)\nleft[i] = Math.max(left[i-1], height[i]);\nint[] right = new int[n];\nright[n-1] = height[n-1];\nfor(int i = n-2; i >= 0; i--)\nright[i] = Math.max(right[i+1], height[i]);\nfor(int i = 0; i < n; i++)\nans += Math.max(0, Math.min(left[i], right[i]) - height[i]);\nreturn ans;\n}\n}",
                        "max_stars_repo_path": "Two Pointers/Trapping-Rain-Water-42.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 237
                },
                {
                        "shared string": " non-negative integers representing an elevation map where the width of each bar is ",
                        "real_dup": 1
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_9677277",
                        "content": "/*\n* We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\n* Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\n* A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without\n* changing the order of the remaining elements.\n* Example 1:\n* Input: nums = [1,3,2,2,5,2,3,7]\n* Output: 5\n* Explanation: The longest harmonious subsequence is [3,2,2,2,3].\n*\n* Constraints:\n* 1 <= nums.length <= 2 * 104\n* -109 <= nums[i] <= 109\n*/\npackage org.phoenix.leetcode.challenges;\nimport java.util.HashMap;\npublic class Problem04_LongestHarmoniousSubsequence {\npublic int findLHS(int[] nums) {\nHashMap<Integer, Integer> map = new HashMap<>();\nint res = 0;\nfor (int num : nums) {\nmap.put(num, map.getOrDefault(num, 0) + 1);\n}\nfor (int key : map.keySet()) {\nif (map.containsKey(key + 1))\nres = Math.max(res, map.get(key) + map.get(key + 1));\n}\nreturn res;\n}\n}",
                        "max_stars_repo_path": "february-2021-leetcode-challenge/src/main/java/org/phoenix/leetcode/challenges/Problem04_LongestHarmoniousSubsequence.java",
                        "max_stars_repo_name": "vibhorsingh11/LeetCode",
                        "max_stars_count": 0,
                        "__cluster__": 189
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_594",
                        "content": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is **exactly** `1`.\nGiven an integer array `nums`, return _the length of its longest harmonious subsequence among all its possible subsequences_.\nA **subsequence** of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\n**Example 1:**\n**Input:** nums = \\[1,3,2,2,5,2,3,7\\]\n**Output:** 5\n**Explanation:** The longest harmonious subsequence is \\[3,2,2,2,3\\].\n**Example 2:**\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 2\n**Example 3:**\n**Input:** nums = \\[1,1,1,1\\]\n**Output:** 0\n**Constraints:**\n*   `1 <= nums.length <= 2 * 104`\n*   `-109 <= nums[i] <= 109`\nInput:\nnums = \\[1,3,2,2,5,2,3,7\\]\nOutput:\n5\n```java\nimport java.util.HashMap;\npublic int findLHS(int[] nums) {\nHashMap<Integer, Integer> count = new HashMap<>();\nfor (int num : nums)\ncount.put(num, count.getOrDefault(num, 0) + 1);\nint longest_sequence = 0;\nfor (int key : count.keySet()) {\nif (count.containsKey(key + 1))\nlongest_sequence = Math.max(longest_sequence, count.get(key) + count.get(key + 1));\n}\nreturn longest_sequence;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 189
                },
                {
                        "shared string": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_112",
                        "content": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.\nA **leaf** is a node with no children.\n**Example 1:**\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22\n**Output:** true\n**Explanation:** The root-to-leaf path with the target sum is shown.\n**Example 2:**\n**Input:** root = \\[1,2,3\\], targetSum = 5\n**Output:** false\n**Explanation:** There two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n**Example 3:**\n**Input:** root = \\[\\], targetSum = 0\n**Output:** false\n**Explanation:** Since the tree is empty, there are no root-to-leaf paths.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`\nInput:\nroot = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22\nOutput:\ntrue\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\n}\npublic boolean hasPathSum(TreeNode root, int targetSum) {\nif (root == null) return false;\nif (root.left == null && root.right == null) return targetSum - root.val == 0;\nreturn hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 46
                },
                {
                        "id": "pretrain_java_data_14521927",
                        "content": "<reponame>naddym/competitive-programming\n/**\nGiven the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.\nExample 1:\n5\n/   \\\n4     8\n/     /  \\\n11    13   4\n/  \\         \\\n7   2         1\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExample 2:\nInput: root = [1,2,3], targetSum = 5\nOutput: false\nExample 3:\nInput: root = [1,2], targetSum = 0\nOutput: false\nConstraints:\nThe number of nodes in the tree is in the range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\npublic boolean hasPathSum(TreeNode root, int sum) {\nif ( root == null)\nreturn false;\nreturn hasSum(root, sum);\n}\nprivate boolean hasSum(TreeNode root, int sum){\n// base case\nif (root == null)\nreturn false;\nif (root.val == sum && root.left == null & root.right == null){\nreturn true;\n}\nreturn hasSum(root.left, sum - root.val) || hasSum(root.right, sum - root.val);\n}\n}",
                        "max_stars_repo_path": "leetcode/easy/path-sum/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 46
                },
                {
                        "shared string": " path such that adding up all the values along the path equals "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_112",
                        "content": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.\nA **leaf** is a node with no children.\n**Example 1:**\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22\n**Output:** true\n**Explanation:** The root-to-leaf path with the target sum is shown.\n**Example 2:**\n**Input:** root = \\[1,2,3\\], targetSum = 5\n**Output:** false\n**Explanation:** There two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n**Example 3:**\n**Input:** root = \\[\\], targetSum = 0\n**Output:** false\n**Explanation:** Since the tree is empty, there are no root-to-leaf paths.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`\nInput:\nroot = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22\nOutput:\ntrue\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\n}\npublic boolean hasPathSum(TreeNode root, int targetSum) {\nif (root == null) return false;\nif (root.left == null && root.right == null) return targetSum - root.val == 0;\nreturn hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 46
                },
                {
                        "id": "pretrain_java_data_14521927",
                        "content": "<reponame>naddym/competitive-programming\n/**\nGiven the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.\nExample 1:\n5\n/   \\\n4     8\n/     /  \\\n11    13   4\n/  \\         \\\n7   2         1\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExample 2:\nInput: root = [1,2,3], targetSum = 5\nOutput: false\nExample 3:\nInput: root = [1,2], targetSum = 0\nOutput: false\nConstraints:\nThe number of nodes in the tree is in the range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\npublic boolean hasPathSum(TreeNode root, int sum) {\nif ( root == null)\nreturn false;\nreturn hasSum(root, sum);\n}\nprivate boolean hasSum(TreeNode root, int sum){\n// base case\nif (root == null)\nreturn false;\nif (root.val == sum && root.left == null & root.right == null){\nreturn true;\n}\nreturn hasSum(root.left, sum - root.val) || hasSum(root.right, sum - root.val);\n}\n}",
                        "max_stars_repo_path": "leetcode/easy/path-sum/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 46
                },
                {
                        "shared string": " path such that adding up all the values along the path equals "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_14424694",
                        "content": "<filename>leetcode/medium/coin-change/Solution.java<gh_stars>0\n/**\nYou are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExample 1:\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\nInput: coins = [2], amount = 3\nOutput: -1\nExample 3:\nInput: coins = [1], amount = 0\nOutput: 0\nExample 4:\nInput: coins = [1], amount = 1\nOutput: 1\nExample 5:\nInput: coins = [1], amount = 2\nOutput: 2\nConstraints:\n1 <= coins.length <= 12\n1 <= coins[i] <= 231 - 1\n0 <= amount <= 104\n*/\nclass Solution {\npublic int coinChange(int[] coins, int amount) {\nint[] dp = new int[amount + 1];\nArrays.fill(dp, Integer.MAX_VALUE);\ndp[0] = 0;\nfor (int i = 1; i <= amount; i++) {\nfor (int j = 0; j < coins.length; j++) {\nif (i - coins[j] >= 0 && dp[i - coins[j]] != Integer.MAX_VALUE) {\ndp[i] = Math.min(dp[i], 1 + dp[i - coins[j]]);\n}\n}\n}\nreturn dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];\n}\n}",
                        "max_stars_repo_path": "leetcode/medium/coin-change/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 342
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_322",
                        "content": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\nYou may assume that you have an infinite number of each kind of coin.\n**Example 1:**\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n**Example 2:**\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n**Example 3:**\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0\n**Constraints:**\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`\nInput:\ncoins = \\[1,2,5\\], amount = 11\nOutput:\n3\n```java\npublic int coinChange(int[] coins, int amount) {\nint[] dp = new int[amount + 1];\nArrays.fill(dp, amount + 1);\ndp[0] = 0;\nfor (int coin : coins) {\nfor (int i = coin; i <= amount; i++) {\ndp[i] = Math.min(dp[i], dp[i - coin] + 1);\n}\n}\nreturn dp[amount] <= amount ? dp[amount] : -1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 342
                },
                {
                        "shared string": ". If that amount of money cannot be made up by any combination of the coins, return "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_14571461",
                        "content": "<filename>src/main/java/com/amazon/StringToInteger.java\npackage com.amazon;\n/**\n* Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n*\n* The algorithm for myAtoi(string s) is as follows:\n* 1. Read in and ignore any leading whitespace.\n* 2. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either.\n*    This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n* 3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n* 4. Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0.\n*    Change the sign as necessary (from step 2).\n* 5. If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range.\n*    Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n* 6. Return the integer as the final result.\n*\n* Note:\n* Only the space character ' ' is considered a whitespace character.\n* Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n*\n* Example 1\n* Input: s = \"   -42\"\n* Output: -42\n* Explanation:\n* Step 1: \"   -42\" (leading whitespace is read and ignored)\n*             ^\n* Step 2: \"   -42\" ('-' is read, so the result should be negative)\n*              ^\n* Step 3: \"   -42\" (\"42\" is read in)\n*                ^\n* The parsed integer is -42.\n* Since -42 is in the range [-231, 231 - 1], the final result is -42.\n*\n* Example 2:\n* Input: s = \"4193 with words\"\n* Output: 4193\n* Explanation:\n* Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n*          ^\n* Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n*          ^\n* Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n*              ^\n* The parsed integer is 4193.\n* Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n*\n* Constraints:\n* 0 <= s.length <= 200\n* s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.\n*\n*/\npublic class StringToInteger {\npublic int myAtoi(String s) {\n//Step 1: Ignore any leading whitespace.\ns = s.trim();\nif(s.length()>0) {\n//Step 2: Determine if negative or positive\nboolean flag = false;\nboolean positive = true;\nif (s.charAt(0) == '-') {\nflag = true;\npositive = false;\n} else if (s.charAt(0) == '+') {\nflag = true;\npositive = true;\n}\n//Step 3: Read till a non digit is encountered\nint i = flag ? 1 : 0;\nfor (; i < s.length(); i++) {\nif (s.charAt(i) < 48 || s.charAt(i) > 57) {\nbreak;\n}\n}\ns = flag ? s.substring(1, i) : s.substring(0, i);\nif(s.length()==0)\nreturn 0;\n//Step 4: Convert to Integer\nint temp = 0;\ntry {\ntemp = positive ? Integer.parseInt(s) : -1 * Integer.parseInt(s);\nreturn temp;\n} catch(NumberFormatException nfe){\nif (positive)\nreturn (int) (Math.pow(2, 31) - 1);\nelse\nreturn (int) (Math.pow(-2, 31));\n}\n}\nreturn 0;\n}\npublic static void main(String[] args) {\nStringToInteger obj = new StringToInteger();\nSystem.out.println(obj.myAtoi(\"-2147483649\"));\n}\n}\n",
                        "max_stars_repo_path": "src/main/java/com/amazon/StringToInteger.java",
                        "max_stars_repo_name": "ankitagrahari/Learn",
                        "max_stars_count": 0,
                        "__cluster__": 214
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_8",
                        "content": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\nThe algorithm for `myAtoi(string s)` is as follows:\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n**Note:**\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n**Example 1:**\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"42 \" ( \"42 \" is read in)\n^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n**Example 2:**\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n**Example 3:**\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193.\n**Constraints:**\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.\nInput:\ns =  \"42 \"\nOutput:\n42\n```java\npublic int myAtoi(String s) {\nlong result = 0;\nint i = 0, sign = 1;\nwhile (i < s.length() && s.charAt(i) == ' ') i++;\nif (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\nsign = (s.charAt(i++) == '+') ? 1 : -1;\n}\nwhile (i < s.length() && Character.isDigit(s.charAt(i))) {\nresult = result * 10 + (s.charAt(i++) - '0');\nif (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\nif (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n}\nreturn (int) (result * sign);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 214
                },
                {
                        "shared string": " function, which converts a string to a 32-bit signed integer (similar to C/C++'s "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_323",
                        "content": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\nReturn _the number of connected components in the graph_.\n**Example 1:**\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\n**Output:** 2\n**Example 2:**\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 1\n**Constraints:**\n*   `1 <= n <= 2000`\n*   `1 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai <= bi < n`\n*   `ai != bi`\n*   There are no repeated edges.\nInput:\nn = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\nOutput:\n2\n```java\nimport java.util.ArrayList;\nimport java.util.List;\npublic int countComponents(int n, int[][] edges) {\nList<List<Integer>> adjList = new ArrayList<>();\nfor (int i = 0; i < n; i++) {\nadjList.add(new ArrayList<>());\n}\nfor (int[] edge : edges) {\nadjList.get(edge[0]).add(edge[1]);\nadjList.get(edge[1]).add(edge[0]);\n}\nboolean[] visited = new boolean[n];\nint connectedComponents = 0;\nfor (int i = 0; i < n; i++) {\nif (!visited[i]) {\ndfs(i, visited, adjList);\nconnectedComponents++;\n}\n}\nreturn connectedComponents;\n}\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\nvisited[node] = true;\nfor (int neighbor : adjList.get(node)) {\nif (!visited[neighbor]) {\ndfs(neighbor, visited, adjList);\n}\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 165
                },
                {
                        "id": "pretrain_java_data_1985000",
                        "content": "package leetcode.problems.linkedin;\nimport java.util.ArrayList;\nimport java.util.List;\n/** 323. Number of Connected Components in an Undirected Graph\n* You have a graph of n nodes. You are given an integer n and an array edges where\n* edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.\n*\n* Return the number of connected components in the graph.\n*\n* Example 1:\n* Input: n = 5, edges = [[0,1],[1,2],[3,4]]\n* Output: 2\n*\n* Example 2:\n* Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]\n* Output: 1\n*\n* Constraints:\n*     1 <= n <= 2000\n*     1 <= edges.length <= 5000\n*     edges[i].length == 2\n*     0 <= ai <= bi < n\n*     ai != bi\n*     There are no repeated edges.\n*/\npublic class _323NumberOfConnectedComponents {\nprivate void dfs(List<Integer>[] adjList, int[] visited, int startNode) {\nvisited[startNode] = 1;\nfor (int i = 0; i < adjList[startNode].size(); i++) {\nif (visited[adjList[startNode].get(i)] == 0) {\ndfs(adjList, visited, adjList[startNode].get(i));\n}\n}\n}\npublic int countComponents(int n, int[][] edges) {\nint components = 0;\nint[] visited = new int[n];\nList<Integer>[] adjList = new ArrayList[n];\nfor (int i = 0; i < n; i++) {\nadjList[i] = new ArrayList<Integer>();\n}\nfor (int i = 0; i < edges.length; i++) {\nadjList[edges[i][0]].add(edges[i][1]);\nadjList[edges[i][1]].add(edges[i][0]);\n}\nfor (int i = 0; i < n; i++) {\nif (visited[i] == 0) {\ncomponents++;\ndfs(adjList, visited, i);\n}\n}\nreturn components;\n}\n}",
                        "max_stars_repo_path": "src/leetcode/problems/linkedin/_323NumberOfConnectedComponents.java",
                        "max_stars_repo_name": "alparslansari/algorithm",
                        "max_stars_count": 0,
                        "__cluster__": 165
                },
                {
                        "shared string": "the number of connected components in the graph"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_323",
                        "content": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\nReturn _the number of connected components in the graph_.\n**Example 1:**\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\n**Output:** 2\n**Example 2:**\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 1\n**Constraints:**\n*   `1 <= n <= 2000`\n*   `1 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai <= bi < n`\n*   `ai != bi`\n*   There are no repeated edges.\nInput:\nn = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\nOutput:\n2\n```java\nimport java.util.ArrayList;\nimport java.util.List;\npublic int countComponents(int n, int[][] edges) {\nList<List<Integer>> adjList = new ArrayList<>();\nfor (int i = 0; i < n; i++) {\nadjList.add(new ArrayList<>());\n}\nfor (int[] edge : edges) {\nadjList.get(edge[0]).add(edge[1]);\nadjList.get(edge[1]).add(edge[0]);\n}\nboolean[] visited = new boolean[n];\nint connectedComponents = 0;\nfor (int i = 0; i < n; i++) {\nif (!visited[i]) {\ndfs(i, visited, adjList);\nconnectedComponents++;\n}\n}\nreturn connectedComponents;\n}\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\nvisited[node] = true;\nfor (int neighbor : adjList.get(node)) {\nif (!visited[neighbor]) {\ndfs(neighbor, visited, adjList);\n}\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 165
                },
                {
                        "id": "pretrain_java_data_1985000",
                        "content": "package leetcode.problems.linkedin;\nimport java.util.ArrayList;\nimport java.util.List;\n/** 323. Number of Connected Components in an Undirected Graph\n* You have a graph of n nodes. You are given an integer n and an array edges where\n* edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.\n*\n* Return the number of connected components in the graph.\n*\n* Example 1:\n* Input: n = 5, edges = [[0,1],[1,2],[3,4]]\n* Output: 2\n*\n* Example 2:\n* Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]\n* Output: 1\n*\n* Constraints:\n*     1 <= n <= 2000\n*     1 <= edges.length <= 5000\n*     edges[i].length == 2\n*     0 <= ai <= bi < n\n*     ai != bi\n*     There are no repeated edges.\n*/\npublic class _323NumberOfConnectedComponents {\nprivate void dfs(List<Integer>[] adjList, int[] visited, int startNode) {\nvisited[startNode] = 1;\nfor (int i = 0; i < adjList[startNode].size(); i++) {\nif (visited[adjList[startNode].get(i)] == 0) {\ndfs(adjList, visited, adjList[startNode].get(i));\n}\n}\n}\npublic int countComponents(int n, int[][] edges) {\nint components = 0;\nint[] visited = new int[n];\nList<Integer>[] adjList = new ArrayList[n];\nfor (int i = 0; i < n; i++) {\nadjList[i] = new ArrayList<Integer>();\n}\nfor (int i = 0; i < edges.length; i++) {\nadjList[edges[i][0]].add(edges[i][1]);\nadjList[edges[i][1]].add(edges[i][0]);\n}\nfor (int i = 0; i < n; i++) {\nif (visited[i] == 0) {\ncomponents++;\ndfs(adjList, visited, i);\n}\n}\nreturn components;\n}\n}",
                        "max_stars_repo_path": "src/leetcode/problems/linkedin/_323NumberOfConnectedComponents.java",
                        "max_stars_repo_name": "alparslansari/algorithm",
                        "max_stars_count": 0,
                        "__cluster__": 165
                },
                {
                        "shared string": "the number of connected components in the graph"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_323",
                        "content": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\nReturn _the number of connected components in the graph_.\n**Example 1:**\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\n**Output:** 2\n**Example 2:**\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 1\n**Constraints:**\n*   `1 <= n <= 2000`\n*   `1 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai <= bi < n`\n*   `ai != bi`\n*   There are no repeated edges.\nInput:\nn = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\nOutput:\n2\n```java\nimport java.util.ArrayList;\nimport java.util.List;\npublic int countComponents(int n, int[][] edges) {\nList<List<Integer>> adjList = new ArrayList<>();\nfor (int i = 0; i < n; i++) {\nadjList.add(new ArrayList<>());\n}\nfor (int[] edge : edges) {\nadjList.get(edge[0]).add(edge[1]);\nadjList.get(edge[1]).add(edge[0]);\n}\nboolean[] visited = new boolean[n];\nint connectedComponents = 0;\nfor (int i = 0; i < n; i++) {\nif (!visited[i]) {\ndfs(i, visited, adjList);\nconnectedComponents++;\n}\n}\nreturn connectedComponents;\n}\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\nvisited[node] = true;\nfor (int neighbor : adjList.get(node)) {\nif (!visited[neighbor]) {\ndfs(neighbor, visited, adjList);\n}\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 165
                },
                {
                        "id": "pretrain_java_data_1985000",
                        "content": "package leetcode.problems.linkedin;\nimport java.util.ArrayList;\nimport java.util.List;\n/** 323. Number of Connected Components in an Undirected Graph\n* You have a graph of n nodes. You are given an integer n and an array edges where\n* edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.\n*\n* Return the number of connected components in the graph.\n*\n* Example 1:\n* Input: n = 5, edges = [[0,1],[1,2],[3,4]]\n* Output: 2\n*\n* Example 2:\n* Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]\n* Output: 1\n*\n* Constraints:\n*     1 <= n <= 2000\n*     1 <= edges.length <= 5000\n*     edges[i].length == 2\n*     0 <= ai <= bi < n\n*     ai != bi\n*     There are no repeated edges.\n*/\npublic class _323NumberOfConnectedComponents {\nprivate void dfs(List<Integer>[] adjList, int[] visited, int startNode) {\nvisited[startNode] = 1;\nfor (int i = 0; i < adjList[startNode].size(); i++) {\nif (visited[adjList[startNode].get(i)] == 0) {\ndfs(adjList, visited, adjList[startNode].get(i));\n}\n}\n}\npublic int countComponents(int n, int[][] edges) {\nint components = 0;\nint[] visited = new int[n];\nList<Integer>[] adjList = new ArrayList[n];\nfor (int i = 0; i < n; i++) {\nadjList[i] = new ArrayList<Integer>();\n}\nfor (int i = 0; i < edges.length; i++) {\nadjList[edges[i][0]].add(edges[i][1]);\nadjList[edges[i][1]].add(edges[i][0]);\n}\nfor (int i = 0; i < n; i++) {\nif (visited[i] == 0) {\ncomponents++;\ndfs(adjList, visited, i);\n}\n}\nreturn components;\n}\n}",
                        "max_stars_repo_path": "src/leetcode/problems/linkedin/_323NumberOfConnectedComponents.java",
                        "max_stars_repo_name": "alparslansari/algorithm",
                        "max_stars_count": 0,
                        "__cluster__": 165
                },
                {
                        "shared string": "the number of connected components in the graph"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_323",
                        "content": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\nReturn _the number of connected components in the graph_.\n**Example 1:**\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\n**Output:** 2\n**Example 2:**\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 1\n**Constraints:**\n*   `1 <= n <= 2000`\n*   `1 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai <= bi < n`\n*   `ai != bi`\n*   There are no repeated edges.\nInput:\nn = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\nOutput:\n2\n```java\nimport java.util.ArrayList;\nimport java.util.List;\npublic int countComponents(int n, int[][] edges) {\nList<List<Integer>> adjList = new ArrayList<>();\nfor (int i = 0; i < n; i++) {\nadjList.add(new ArrayList<>());\n}\nfor (int[] edge : edges) {\nadjList.get(edge[0]).add(edge[1]);\nadjList.get(edge[1]).add(edge[0]);\n}\nboolean[] visited = new boolean[n];\nint connectedComponents = 0;\nfor (int i = 0; i < n; i++) {\nif (!visited[i]) {\ndfs(i, visited, adjList);\nconnectedComponents++;\n}\n}\nreturn connectedComponents;\n}\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\nvisited[node] = true;\nfor (int neighbor : adjList.get(node)) {\nif (!visited[neighbor]) {\ndfs(neighbor, visited, adjList);\n}\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 165
                },
                {
                        "id": "pretrain_java_data_1985000",
                        "content": "package leetcode.problems.linkedin;\nimport java.util.ArrayList;\nimport java.util.List;\n/** 323. Number of Connected Components in an Undirected Graph\n* You have a graph of n nodes. You are given an integer n and an array edges where\n* edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.\n*\n* Return the number of connected components in the graph.\n*\n* Example 1:\n* Input: n = 5, edges = [[0,1],[1,2],[3,4]]\n* Output: 2\n*\n* Example 2:\n* Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]\n* Output: 1\n*\n* Constraints:\n*     1 <= n <= 2000\n*     1 <= edges.length <= 5000\n*     edges[i].length == 2\n*     0 <= ai <= bi < n\n*     ai != bi\n*     There are no repeated edges.\n*/\npublic class _323NumberOfConnectedComponents {\nprivate void dfs(List<Integer>[] adjList, int[] visited, int startNode) {\nvisited[startNode] = 1;\nfor (int i = 0; i < adjList[startNode].size(); i++) {\nif (visited[adjList[startNode].get(i)] == 0) {\ndfs(adjList, visited, adjList[startNode].get(i));\n}\n}\n}\npublic int countComponents(int n, int[][] edges) {\nint components = 0;\nint[] visited = new int[n];\nList<Integer>[] adjList = new ArrayList[n];\nfor (int i = 0; i < n; i++) {\nadjList[i] = new ArrayList<Integer>();\n}\nfor (int i = 0; i < edges.length; i++) {\nadjList[edges[i][0]].add(edges[i][1]);\nadjList[edges[i][1]].add(edges[i][0]);\n}\nfor (int i = 0; i < n; i++) {\nif (visited[i] == 0) {\ncomponents++;\ndfs(adjList, visited, i);\n}\n}\nreturn components;\n}\n}",
                        "max_stars_repo_path": "src/leetcode/problems/linkedin/_323NumberOfConnectedComponents.java",
                        "max_stars_repo_name": "alparslansari/algorithm",
                        "max_stars_count": 0,
                        "__cluster__": 165
                },
                {
                        "shared string": "the number of connected components in the graph"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```java\npublic int minPathSum(int[][] grid) {\nint m = grid.length, n = grid[0].length;\nfor(int i = 1; i < m; i++)\ngrid[i][0] += grid[i - 1][0];\nfor(int i = 1; i < n; i++)\ngrid[0][i] += grid[0][i - 1];\nfor(int i = 1; i < m; i++){\nfor(int j = 1; j < n; j++){\ngrid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n}\n}\nreturn grid[m - 1][n - 1];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 251
                },
                {
                        "id": "pretrain_java_data_1915950",
                        "content": "//Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right\n//which minimizes the sum of all numbers along its path.\n//Note: You can only move either down or right at any point in time.\n//Example 1:\n//[[1,3,1],\n//[1,5,1],\n//[4,2,1]]\n//Given the above grid map, return 7. Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\nclass MinimumPathSum {\npublic int minPathSum(int[][] grid) {\nfor(int i = 1; i < grid.length; i++) {\ngrid[i][0] += grid[i - 1][0];\n}\nfor(int i = 1; i < grid[0].length; i++) {\ngrid[0][i] += grid[0][i - 1];\n}\nfor(int i = 1; i < grid.length; i++) {\nfor(int j = 1; j < grid[0].length; j++) {\ngrid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n}\n}\nreturn grid[grid.length - 1][grid[0].length - 1];\n}\n}",
                        "max_stars_repo_path": "leetcode/array/MinimumPathSum.java",
                        "max_stars_repo_name": "ChickenMomos/interviews",
                        "max_stars_count": 60910,
                        "__cluster__": 251
                },
                {
                        "shared string": " filled with non-negative numbers, find a path from top left to bottom right"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\n}\npublic boolean isValidBST(TreeNode root) {\nreturn isValidBSTHelper(root, Long.MIN_VALUE, Long.MAX_VALUE);\n}\nprivate boolean isValidBSTHelper(TreeNode node, long min, long max) {\nif (node == null) return true;\nif (node.val <= min || node.val >= max) return false;\nreturn isValidBSTHelper(node.left, min, node.val) && isValidBSTHelper(node.right, node.val, max);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 18
                },
                {
                        "id": "pretrain_java_data_16390681",
                        "content": "<filename>algorithmsJava/Tree/Validate Binary Search Tree/Solution.java\n/*\nProblem :: Given a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\n2\n/ \\\n1   3\nInput: [2,1,3]\nOutput: true\nExample 2:\n5\n/ \\\n1   4\n/ \\\n3   6\nInput: [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n*/\n/*\nAnalysis ::\nTime Complexity :: O(n)\nSpace Complexity :: O(n)\n*/\nclass Solution {\nprivate boolean helper(TreeNode root, long min, long max){\nif(root==null)\nreturn true;\nif(min<root.val && max>root.val){\nboolean left = helper(root.left,min,root.val);\nboolean right = helper(root.right,root.val,max);\nreturn (left && right);\n}else\nreturn false;\n}\npublic boolean isValidBST(TreeNode root) {\nreturn helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\n}\n}",
                        "max_stars_repo_path": "algorithmsJava/Tree/Validate Binary Search Tree/Solution.java",
                        "max_stars_repo_name": "Chinmayswaroop/LeetCode",
                        "max_stars_count": 1,
                        "__cluster__": 18
                },
                {
                        "shared string": " Both the left and right subtrees must also be binary search trees. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\n}\npublic boolean isValidBST(TreeNode root) {\nreturn isValidBSTHelper(root, Long.MIN_VALUE, Long.MAX_VALUE);\n}\nprivate boolean isValidBSTHelper(TreeNode node, long min, long max) {\nif (node == null) return true;\nif (node.val <= min || node.val >= max) return false;\nreturn isValidBSTHelper(node.left, min, node.val) && isValidBSTHelper(node.right, node.val, max);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 18
                },
                {
                        "id": "pretrain_java_data_16390681",
                        "content": "<filename>algorithmsJava/Tree/Validate Binary Search Tree/Solution.java\n/*\nProblem :: Given a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\n2\n/ \\\n1   3\nInput: [2,1,3]\nOutput: true\nExample 2:\n5\n/ \\\n1   4\n/ \\\n3   6\nInput: [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n*/\n/*\nAnalysis ::\nTime Complexity :: O(n)\nSpace Complexity :: O(n)\n*/\nclass Solution {\nprivate boolean helper(TreeNode root, long min, long max){\nif(root==null)\nreturn true;\nif(min<root.val && max>root.val){\nboolean left = helper(root.left,min,root.val);\nboolean right = helper(root.right,root.val,max);\nreturn (left && right);\n}else\nreturn false;\n}\npublic boolean isValidBST(TreeNode root) {\nreturn helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\n}\n}",
                        "max_stars_repo_path": "algorithmsJava/Tree/Validate Binary Search Tree/Solution.java",
                        "max_stars_repo_name": "Chinmayswaroop/LeetCode",
                        "max_stars_count": 1,
                        "__cluster__": 18
                },
                {
                        "shared string": " Both the left and right subtrees must also be binary search trees. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_16316776",
                        "content": "/*\n* @author <NAME>, <EMAIL>\n*/\npackage com.omtia.un;\nimport com.omtia.utils.ListNode;\n/**\n* Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\n*\n* There is a cycle in a linked list if there is some node in the list that can be reached again by continuously\n* following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is\n* connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\n*\n* Do not modify the linked list.\n*\n*\n*\n* Example 1:\n*\n*\n* Input: head = [3,2,0,-4], pos = 1\n* Output: tail connects to node index 1\n* Explanation: There is a cycle in the linked list, where tail connects to the second node.\n* Example 2:\n*\n*\n* Input: head = [1,2], pos = 0\n* Output: tail connects to node index 0\n* Explanation: There is a cycle in the linked list, where tail connects to the first node.\n* Example 3:\n*\n*\n* Input: head = [1], pos = -1\n* Output: no cycle\n* Explanation: There is no cycle in the linked list.\n*\n*\n* Constraints:\n*\n* The number of the nodes in the list is in the range [0, 104].\n* -105 <= Node.val <= 105\n* pos is -1 or a valid index in the linked-list.\n*\n*\n* Follow up: Can you solve it using O(1) (i.e. constant) memory?\n*/\npublic class _142_Linked_List_Cycle_II {\npublic ListNode detectCycle(ListNode head) {\nif(head == null) return null;\nif(head.next == null) return null;\nListNode slow = head.next;\nListNode fast = head.next.next;\nwhile(slow != fast) {\nif(fast == null || fast.next == null) return null;\nslow = slow.next;\nfast = fast.next.next;\n}\nwhile(head != fast) {\nhead = head.next;\nfast = fast.next;\n}\nreturn head;\n}\n}",
                        "max_stars_repo_path": "src/main/java/com/omtia/un/_142_Linked_List_Cycle_II.java",
                        "max_stars_repo_name": "Andreii/algo",
                        "max_stars_count": 0,
                        "__cluster__": 278
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_141",
                        "content": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\nReturn `true` _if there is a cycle in the linked list_. Otherwise, return `false`.\n**Example 1:**\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n**Example 2:**\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.\n**Example 3:**\n**Input:** head = \\[1\\], pos = -1\n**Output:** false\n**Explanation:** There is no cycle in the linked list.\n**Constraints:**\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?\nInput:\nhead = \\[3,2,0,-4\\], pos = 1\nOutput:\ntrue\n```java\npublic boolean hasCycle(ListNode head) {\nListNode slow = head, fast = head;\nwhile (fast != null && fast.next != null) {\nslow = slow.next;\nfast = fast.next.next;\nif (slow == fast) {\nreturn true;\n}\n}\nreturn false;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 278
                },
                {
                        "shared string": " There is a cycle in a linked list if there is some node in the list that can be reached again by continuously ",
                        "real_dup": 1
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```java\npublic int rob(int[] nums) {\nif (nums.length == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.length - 1; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.length; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn Math.max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "id": "pretrain_java_data_16283878",
                        "content": "<reponame>tom83615/LeetCode_Java\npackage problem;\n//       You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n//\n//        Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n//\n//        Example 1:\n//\n//        Input: nums = [2,3,2]\n//        Output: 3\n//        Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n//\n//        Example 2:\n//\n//        Input: nums = [1,2,3,1]\n//        Output: 4\n//        Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n//        Total amount you can rob = 1 + 3 = 4.\n//\n//        Example 3:\n//\n//        Input: nums = [1,2,3]\n//        Output: 3\n//\n//\n//        Constraints:\n//\n//        1 <= nums.length <= 100\n//        0 <= nums[i] <= 1000\nimport java.util.Arrays;\npublic class HouseRobberII {\npublic static int rob(int[] nums) {\nif (nums.length == 1)\nreturn nums[0];\nint length = nums.length;\nint keepH = helper(nums, 0, length-1);\nint heepT = helper(nums, 1, length);\nreturn Math.max(keepH, heepT);\n}\nprivate static int helper(int[] nums, int start, int end){\nint rob1 = 0, rob2 = 0;\nfor (int i = start; i < end; i++){\nint newRob = Math.max(nums[i] + rob1, rob2);\nrob1 = rob2;\nrob2 = newRob;\n}\nreturn rob2;\n}\n}",
                        "max_stars_repo_path": "src/main/java/problem/HouseRobberII.java",
                        "max_stars_repo_name": "tom83615/LeetCode_Java",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_657",
                        "content": "There is a robot starting at the position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot **ends up at** `(0, 0)` after it completes its moves.\nYou are given a string `moves` that represents the move sequence of the robot where `moves[i]` represents its `ith` move. Valid moves are `'R'` (right), `'L'` (left), `'U'` (up), and `'D'` (down).\nReturn `true` _if the robot returns to the origin after it finishes all of its moves, or_ `false` _otherwise_.\n**Note**: The way that the robot is \"facing \" is irrelevant. `'R'` will always make the robot move to the right once, `'L'` will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n**Example 1:**\n**Input:** moves =  \"UD \"\n**Output:** true\n**Explanation**: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n**Example 2:**\n**Input:** moves =  \"LL \"\n**Output:** false\n**Explanation**: The robot moves left twice. It ends up two  \"moves \" to the left of the origin. We return false because it is not at the origin at the end of its moves.\n**Constraints:**\n*   `1 <= moves.length <= 2 * 104`\n*   `moves` only contains the characters `'U'`, `'D'`, `'L'` and `'R'`.\nInput:\nmoves =  \"UD \"\nOutput:\ntrue\n```java\npublic boolean judgeCircle(String moves) {\nint x = 0, y = 0;\nfor(char move : moves.toCharArray()) {\nif(move == 'U') y++;\nelse if(move == 'D') y--;\nelse if(move == 'R') x++;\nelse if(move == 'L') x--;\n}\nreturn x == 0 && y == 0;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 404
                },
                {
                        "id": "pretrain_java_data_16201285",
                        "content": "package string;\n/**\n* There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.\n*\n* You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' (right), 'L' (left), 'U' (up), and 'D' (down).\n*\n* Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise.\n*\n* Note: The way that the robot is \"facing\" is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n*\n*\n*\n* Example 1:\n*\n* Input: moves = \"UD\"\n* Output: true\n* Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n*/\npublic class RobotReturnToOrigin {\npublic boolean judgeCircle(String moves) {\nint x = 0, y = 0;\nfor (char move : moves.toCharArray()) {\nswitch (move) {\ncase 'U': y++; break;\ncase 'D': y--; break;\ncase 'R': x++; break;\ncase 'L': x--; break;\n}\n}\nreturn x == 0 && y == 0;\n}\n}",
                        "max_stars_repo_path": "src/string/RobotReturnToOrigin.java",
                        "max_stars_repo_name": "gitmichaelz/LeetCodeByTags",
                        "max_stars_count": 0,
                        "__cluster__": 404
                },
                {
                        "shared string": ", the origin, on a 2D plane. Given a sequence of its moves, judge if this robot "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```java\npublic int minPathSum(int[][] grid) {\nint m = grid.length, n = grid[0].length;\nfor(int i = 1; i < m; i++)\ngrid[i][0] += grid[i - 1][0];\nfor(int i = 1; i < n; i++)\ngrid[0][i] += grid[0][i - 1];\nfor(int i = 1; i < m; i++){\nfor(int j = 1; j < n; j++){\ngrid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n}\n}\nreturn grid[m - 1][n - 1];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 251
                },
                {
                        "id": "pretrain_java_data_17957315",
                        "content": "/**\n* Given a m x n grid filled with non-negative numbers,\n* find a path from top left to bottom right which minimizes the sum of all numbers along its path.\n* <p>\n* Note: You can only move either down or right at any point in time.\n* <p>\n* Example 1:\n* [[1,3,1],\n* [1,5,1],\n* [4,2,1]]\n* Given the above grid map, return 7. Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n* <p>\n* Accepted.\n*/\npublic class MinimumPathSum {\npublic int minPathSum(int[][] grid) {\nif (grid.length == 0) {\nreturn 0;\n}\nif (grid.length == 1) {\nif (grid[0].length == 0) {\nreturn 0;\n}\nif (grid[0].length == 1) {\nreturn grid[0][0];\n}\n}\nint[][] matrix = new int[grid.length][grid[0].length];\nmatrix[0][0] = grid[0][0];\nfor (int i = 1; i < grid.length; i++) {\nmatrix[i][0] = matrix[i - 1][0] + grid[i][0];\n}\nfor (int i = 1; i < grid[0].length; i++) {\nmatrix[0][i] = matrix[0][i - 1] + grid[0][i];\n}\nfor (int i = 1; i < grid.length; i++) {\nfor (int j = 1; j < grid[0].length; j++) {\nmatrix[i][j] = Math.min(matrix[i - 1][j] + grid[i][j], matrix[i][j - 1] + grid[i][j]);\n}\n}\nreturn matrix[grid.length - 1][grid[0].length - 1];\n}\n}",
                        "max_stars_repo_path": "Java/src/MinimumPathSum.java",
                        "max_stars_repo_name": "TonnyL/Windary",
                        "max_stars_count": 205,
                        "__cluster__": 251
                },
                {
                        "shared string": " You can only move either down or right at any point in time. *"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_5149301",
                        "content": "<reponame>yanweixin/Algorithms\npackage leetcode.string;\n//Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n//\n//The algorithm for myAtoi(string s) is as follows:\n//\n//Read in and ignore any leading whitespace.\n//Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n//Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n//Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n//If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n//Return the integer as the final result.\n//Note:\n//\n//Only the space character ' ' is considered a whitespace character.\n//Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n//\n//\n//Example 1:\n//\n//Input: s = \"42\"\n//Output: 42\n//Explanation: The underlined characters are what is read in, the caret is the current reader position.\n//Step 1: \"42\" (no characters read because there is no leading whitespace)\n//         ^\n//Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n//         ^\n//Step 3: \"42\" (\"42\" is read in)\n//           ^\n//The parsed integer is 42.\n//Since 42 is in the range [-231, 231 - 1], the final result is 42.\n//Example 2:\n//\n//Input: s = \"   -42\"\n//Output: -42\n//Explanation:\n//Step 1: \"   -42\" (leading whitespace is read and ignored)\n//            ^\n//Step 2: \"   -42\" ('-' is read, so the result should be negative)\n//             ^\n//Step 3: \"   -42\" (\"42\" is read in)\n//               ^\n//The parsed integer is -42.\n//Since -42 is in the range [-231, 231 - 1], the final result is -42.\n//Example 3:\n//\n//Input: s = \"4193 with words\"\n//Output: 4193\n//Explanation:\n//Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n//         ^\n//Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n//         ^\n//Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n//             ^\n//The parsed integer is 4193.\n//Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n//Example 4:\n//\n//Input: s = \"words and 987\"\n//Output: 0\n//Explanation:\n//Step 1: \"words and 987\" (no characters read because there is no leading whitespace)\n//         ^\n//Step 2: \"words and 987\" (no characters read because there is neither a '-' nor '+')\n//         ^\n//Step 3: \"words and 987\" (reading stops immediately because there is a non-digit 'w')\n//         ^\n//The parsed integer is 0 because no digits were read.\n//Since 0 is in the range [-231, 231 - 1], the final result is 0.\n//Example 5:\n//\n//Input: s = \"-91283472332\"\n//Output: -2147483648\n//Explanation:\n//Step 1: \"-91283472332\" (no characters read because there is no leading whitespace)\n//         ^\n//Step 2: \"-91283472332\" ('-' is read, so the result should be negative)\n//          ^\n//Step 3: \"-91283472332\" (\"91283472332\" is read in)\n//                     ^\n//The parsed integer is -91283472332.\n//Since -91283472332 is less than the lower bound of the range [-2^31, 2^31 - 1], the final result is clamped to -231 = -2147483648.\n//\n//\n//Constraints:\n//\n//0 <= s.length <= 200\n//s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.\npublic class IntegerInString {\npublic int myAtoi(String s) {\nint result = 0;\nint len;\nif (s == null || (len = s.length()) == 0) {\nreturn result;\n}\nboolean sign = true;\nint i = 0;\nwhile (i < len && s.charAt(i) == ' ') {\ni++;\n}\nif (i == len) {\nreturn result;\n}\nchar ch = s.charAt(i);\nif (ch == '+') {\ni++;\n} else if (ch == '-') {\ni++;\nsign = false;\n}\nwhile (i < len && (ch = s.charAt(i)) >= '0' && ch <= '9') {\nif (result > Integer.MAX_VALUE / 10 || result == Integer.MAX_VALUE / 10 && (sign ? ch > '7' : ch > '8')) {\nreturn sign ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n}\nresult = result * 10 + (ch - '0');\ni++;\n}\nreturn sign ? result : -result;\n}\n}",
                        "max_stars_repo_path": "test/leetcode/src/main/java/leetcode/string/IntegerInString.java",
                        "max_stars_repo_name": "yanweixin/Algorithms",
                        "max_stars_count": 0,
                        "__cluster__": 214
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_8",
                        "content": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\nThe algorithm for `myAtoi(string s)` is as follows:\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n**Note:**\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n**Example 1:**\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"42 \" ( \"42 \" is read in)\n^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n**Example 2:**\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n**Example 3:**\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193.\n**Constraints:**\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.\nInput:\ns =  \"42 \"\nOutput:\n42\n```java\npublic int myAtoi(String s) {\nlong result = 0;\nint i = 0, sign = 1;\nwhile (i < s.length() && s.charAt(i) == ' ') i++;\nif (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\nsign = (s.charAt(i++) == '+') ? 1 : -1;\n}\nwhile (i < s.length() && Character.isDigit(s.charAt(i))) {\nresult = result * 10 + (s.charAt(i++) - '0');\nif (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\nif (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n}\nreturn (int) (result * sign);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 214
                },
                {
                        "shared string": ". Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_450",
                        "content": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return _the **root node reference** (possibly updated) of the BST_.\nBasically, the deletion can be divided into two stages:\n1.  Search for a node to remove.\n2.  If the node is found, delete the node.\n**Example 1:**\n**Input:** root = \\[5,3,6,2,4,null,7\\], key = 3\n**Output:** \\[5,4,6,2,null,null,7\\]\n**Explanation:** Given key to delete is 3. So we find the node with value 3 and delete it.\nOne valid answer is \\[5,4,6,2,null,null,7\\], shown in the above BST.\nPlease notice that another valid answer is \\[5,2,6,null,4,null,7\\] and it's also accepted.\n**Example 2:**\n**Input:** root = \\[5,3,6,2,4,null,7\\], key = 0\n**Output:** \\[5,3,6,2,4,null,7\\]\n**Explanation:** The tree does not contain a node with value = 0.\n**Example 3:**\n**Input:** root = \\[\\], key = 0\n**Output:** \\[\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   Each node has a **unique** value.\n*   `root` is a valid binary search tree.\n*   `-105 <= key <= 105`\n**Follow up:** Could you solve it with time complexity `O(height of tree)`?\nInput:\nroot = \\[5,3,6,2,4,null,7\\], key = 3\nOutput:\n\\[5,4,6,2,null,null,7\\]\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\npublic TreeNode deleteNode(TreeNode root, int key) {\nif (root == null) return null;\nif (key < root.val) {\nroot.left = deleteNode(root.left, key);\n} else if (key > root.val) {\nroot.right = deleteNode(root.right, key);\n} else {\nif (root.left == null) {\nreturn root.right;\n} else if (root.right == null) {\nreturn root.left;\n} else {\nTreeNode temp = root.right;\nwhile (temp.left != null) temp = temp.left;\nroot.val = temp.val;\nroot.right = deleteNode(root.right, temp.val);\n}\n}\nreturn root;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 376
                },
                {
                        "id": "pretrain_java_data_8360830",
                        "content": "<gh_stars>10-100\n// Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n// Basically, the deletion can be divided into two stages:\n// Search for a node to remove.\n// If the node is found, delete the node.\n// Follow up: Can you solve it with time complexity O(height of tree)?\n// Example 1:\n// Input: root = [5,3,6,2,4,null,7], key = 3\n// Output: [5,4,6,2,null,null,7]\n// Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.\n// One valid answer is [5,4,6,2,null,null,7], shown in the above BST.\n// Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.\n// Example 2:\n// Input: root = [5,3,6,2,4,null,7], key = 0\n// Output: [5,3,6,2,4,null,7]\n// Explanation: The tree does not contain a node with value = 0.\n// Example 3:\n// Input: root = [], key = 0\n// Output: []\n// Constraints:\n// The number of nodes in the tree is in the range [0, 104].\n// -105 <= Node.val <= 105\n// Each node has a unique value.\n// root is a valid binary search tree.\n// -105 <= key <= 105\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode getInorderSuccessor(TreeNode root){\nwhile(root.left!=null)\nroot = root.left;\nreturn root;\n}\npublic TreeNode deleteNode(TreeNode root, int key) {\nif(root==null) return null;\nif(key < root.val)\nroot.left = deleteNode(root.left, key);\nelse if(key > root.val)\nroot.right = deleteNode(root.right, key);\nelse{ // found\nif(root.right == null){\nTreeNode temp = root.left;\nreturn temp;\n}\nelse if(root.left == null){\nTreeNode temp = root.right;\nreturn temp;\n}\nelse{ // both children exist\nTreeNode temp = getInorderSuccessor(root.right);\nroot.val = temp.val;\nroot.right = deleteNode(root.right, root.val);\n}\n}\nreturn root;\n}\n}",
                        "max_stars_repo_path": "Trees/Delete-Node-In-A-BST.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 376
                },
                {
                        "shared string": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_500016",
                        "content": "// You are given two non-empty linked lists representing two non-negative integers.\n//  The digits are stored in reverse order, and each of their nodes contains a single digit.\n//  Add the two numbers and return the sum as a linked list.\n// You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n// Example 1:\n// Input: l1 = [2,4,3], l2 = [5,6,4]\n// Output: [7,0,8]\n// Explanation: 342 + 465 = 807.\n// Example 2:\n// Input: l1 = [0], l2 = [0]\n// Output: [0]\n// Example 3:\n// Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n// Output: [8,9,9,9,0,0,0,1]\n// Constraints:\n// The number of nodes in each linked list is in the range [1, 100].\n// 0 <= Node.val <= 9\n// It is guaranteed that the list represents a number that does not have leading zeros.\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nif(l1 == null) return l2;\nif(l2 == null) return l1;\nint carry = 0;\nListNode dummy = new ListNode();\nListNode temp = dummy;\nwhile(l1 != null || l2 != null || carry != 0){\nint sum = 0;\nif(l1 != null){\nsum += l1.val;\nl1 = l1.next;\n}\nif(l2 != null){\nsum += l2.val;\nl2 = l2.next;\n}\nsum += carry;\ncarry = sum / 10;\nListNode node = new ListNode(sum % 10);\ntemp.next = node;\ntemp = temp.next;\n}\nreturn dummy.next;\n}\n}",
                        "max_stars_repo_path": "Linked-Lists/AddTwoNumbers2.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 211
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```java\npublic class ListNode {\nint val;\nListNode next;\nListNode(int x) { val = x; }\n}\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nListNode dummy = new ListNode(0);\nListNode current = dummy;\nint carry = 0;\nwhile (l1 != null || l2 != null || carry != 0) {\nint sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;\ncarry = sum / 10;\ncurrent.next = new ListNode(sum % 10);\ncurrent = current.next;\nif (l1 != null) l1 = l1.next;\nif (l2 != null) l2 = l2.next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 211
                },
                {
                        "shared string": " You may assume the two numbers do not contain any leading zero, except the number 0 itself. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_630",
                        "content": "There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken **continuously** for `durationi` days and must be finished before or on `lastDayi`.\nYou will start on the `1st` day and you cannot take two or more courses simultaneously.\nReturn _the maximum number of courses that you can take_.\n**Example 1:**\n**Input:** courses = \\[\\[100,200\\],\\[200,1300\\],\\[1000,1250\\],\\[2000,3200\\]\\]\n**Output:** 3\nExplanation:\nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.\nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.\nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n**Example 2:**\n**Input:** courses = \\[\\[1,2\\]\\]\n**Output:** 1\n**Example 3:**\n**Input:** courses = \\[\\[3,2\\],\\[4,3\\]\\]\n**Output:** 0\n**Constraints:**\n*   `1 <= courses.length <= 104`\n*   `1 <= durationi, lastDayi <= 104`\nInput:\ncourses = \\[\\[100,200\\],\\[200,1300\\],\\[1000,1250\\],\\[2000,3200\\]\\]\nOutput:\n3\n```java\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\npublic int scheduleCourse(int[][] courses) {\nArrays.sort(courses, (a, b) -> a[1] - b[1]);\nPriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\nint time = 0;\nfor (int[] course : courses) {\ntime += course[0];\npq.offer(course[0]);\nif (time > course[1]) {\ntime -= pq.poll();\n}\n}\nreturn pq.size();\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 130
                },
                {
                        "id": "pretrain_java_data_2031054",
                        "content": "<filename>leetcode/hard/course-schedule-iii/Solution.java<gh_stars>0\n/**\nThere are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.\nYou will start on the 1st day and you cannot take two or more courses simultaneously.\nReturn the maximum number of courses that you can take.\nExample 1:\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation:\nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.\nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.\nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\nExample 2:\nInput: courses = [[1,2]]\nOutput: 1\nExample 3:\nInput: courses = [[3,2],[4,3]]\nOutput: 0\nConstraints:\n1 <= courses.length <= 104\n1 <= durationi, lastDayi <= 104\n*/\nclass Solution {\npublic int scheduleCourse(int[][] courses) {\nArrays.sort(courses, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> (b - a));\nint totalDuration = 0;\nfor (int[] course: courses) {\n// check if we can take the course\nif (course[0] <= course[1]) {\n// check if we can finish the course\nif (course[0] + totalDuration <= course[1]) {\ntotalDuration += course[0];\nmaxHeap.add(course[0]);\n} else {\n// check if we can swap\nif (maxHeap.peek() > course[0]) {\nint duration = maxHeap.remove();\ntotalDuration -= duration;\nmaxHeap.add(course[0]);\ntotalDuration += course[0];\n}\n}\n}\n}\nreturn maxHeap.size();\n}\n}\n",
                        "max_stars_repo_path": "leetcode/hard/course-schedule-iii/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 130
                },
                {
                        "shared string": " day and you cannot take two or more courses simultaneously. Return "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_630",
                        "content": "There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken **continuously** for `durationi` days and must be finished before or on `lastDayi`.\nYou will start on the `1st` day and you cannot take two or more courses simultaneously.\nReturn _the maximum number of courses that you can take_.\n**Example 1:**\n**Input:** courses = \\[\\[100,200\\],\\[200,1300\\],\\[1000,1250\\],\\[2000,3200\\]\\]\n**Output:** 3\nExplanation:\nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.\nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.\nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n**Example 2:**\n**Input:** courses = \\[\\[1,2\\]\\]\n**Output:** 1\n**Example 3:**\n**Input:** courses = \\[\\[3,2\\],\\[4,3\\]\\]\n**Output:** 0\n**Constraints:**\n*   `1 <= courses.length <= 104`\n*   `1 <= durationi, lastDayi <= 104`\nInput:\ncourses = \\[\\[100,200\\],\\[200,1300\\],\\[1000,1250\\],\\[2000,3200\\]\\]\nOutput:\n3\n```java\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\npublic int scheduleCourse(int[][] courses) {\nArrays.sort(courses, (a, b) -> a[1] - b[1]);\nPriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\nint time = 0;\nfor (int[] course : courses) {\ntime += course[0];\npq.offer(course[0]);\nif (time > course[1]) {\ntime -= pq.poll();\n}\n}\nreturn pq.size();\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 130
                },
                {
                        "id": "pretrain_java_data_2103432",
                        "content": "<filename>leetcode/p0630/Solution.java<gh_stars>0\n/*\nhttps://leetcode.com/problems/course-schedule-iii/\nThere are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.\nYou will start on the 1st day and you cannot take two or more courses simultaneously.\nReturn the maximum number of courses that you can take.\nExample 1:\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation:\nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.\nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.\nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\nExample 2:\nInput: courses = [[1,2]]\nOutput: 1\nExample 3:\nInput: courses = [[3,2],[4,3]]\nOutput: 0\nConstraints:\n1 <= courses.length <= 10^4\n1 <= durationi, lastDayi <= 10^4\n*/\nclass Solution {\npublic int scheduleCourse(int[][] courses) {\nArrays.sort(courses, (c1, c2) -> {\nreturn c1[1] - c2[1];\n});\nQueue<int[]> pq = new PriorityQueue<> ((c1, c2) -> {\nreturn -(c1[0] - c2[0]);\n});\nint count = 0;\nint curDay = 0;\nfor (int[] c : courses) {\ncurDay += c[0];\npq.offer(c);\nif (curDay > c[1]) {\ncurDay -= pq.poll()[0];\n}\n}\nreturn pq.size();\n}\n}",
                        "max_stars_repo_path": "leetcode/p0630/Solution.java",
                        "max_stars_repo_name": "suhwanhwang/problem-solving",
                        "max_stars_count": 0,
                        "__cluster__": 130
                },
                {
                        "shared string": " day and you cannot take two or more courses simultaneously. Return "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_16533111",
                        "content": "<reponame>Tavi3h/LeetCode<filename>src/pers/tavish/solution/easy/RomanToInteger.java\npackage pers.tavish.solution.easy;\nimport java.util.HashMap;\nimport java.util.Map;\n/*\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n- I can be placed before V (5) and X (10) to make 4 and 9.\n- X can be placed before L (50) and C (100) to make 40 and 90.\n- C can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\nExample 1:\nInput: \"III\"\nOutput: 3\nExample 2:\nInput: \"IV\"\nOutput: 4\nExample 3:\nInput: \"IX\"\nOutput: 9\nExample 4:\nInput: \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 5:\nInput: \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\nfor more information = https://leetcode.com/problems/roman-to-integer/description/\n*/\npublic class RomanToInteger {\nprivate static Map<Character, Integer> MAP;\nstatic {\nMAP = new HashMap<>();\nMAP.put('I', 1);\nMAP.put('V', 5);\nMAP.put('X', 10);\nMAP.put('L', 50);\nMAP.put('C', 100);\nMAP.put('D', 500);\nMAP.put('M', 1000);\n}\npublic int romanToInt(String s) {\nint len = s.length() - 1;\nint sum = MAP.get(s.charAt(len--));\nwhile (len >= 0) {\nchar cur = s.charAt(len);\nchar next = s.charAt(len + 1);\nif (cur == 'I' && (next == 'V' || next == 'X'))\nsum -= MAP.get(cur);\nelse if (cur == 'X' && (next == 'L' || next == 'C'))\nsum -= MAP.get(cur);\nelse if (cur == 'C' && (next == 'D' || next == 'M'))\nsum -= MAP.get(cur);\nelse\nsum += MAP.get(cur);\nlen--;\n}\nreturn sum;\n}\n}",
                        "max_stars_repo_path": "src/pers/tavish/solution/easy/RomanToInteger.java",
                        "max_stars_repo_name": "Tavi3h/LeetCode",
                        "max_stars_count": 1,
                        "__cluster__": 215
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_13",
                        "content": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n**Example 1:**\n**Input:** s =  \"III \"\n**Output:** 3\n**Explanation:** III = 3.\n**Example 2:**\n**Input:** s =  \"LVIII \"\n**Output:** 58\n**Explanation:** L = 50, V= 5, III = 3.\n**Example 3:**\n**Input:** s =  \"MCMXCIV \"\n**Output:** 1994\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4.\n**Constraints:**\n*   `1 <= s.length <= 15`\n*   `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.\n*   It is **guaranteed** that `s` is a valid roman numeral in the range `[1, 3999]`.\nInput:\ns =  \"III \"\nOutput:\n3\n```java\npublic int romanToInt(String s) {\nMap<Character, Integer> romanValues = new HashMap<>();\nromanValues.put('I', 1);\nromanValues.put('V', 5);\nromanValues.put('X', 10);\nromanValues.put('L', 50);\nromanValues.put('C', 100);\nromanValues.put('D', 500);\nromanValues.put('M', 1000);\nint total = 0;\nint prevValue = 0;\nfor (char c : s.toCharArray()) {\nint currValue = romanValues.get(c);\ntotal += currValue > prevValue ? currValue - 2 * prevValue : currValue;\nprevValue = currValue;\n}\nreturn total;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 215
                },
                {
                        "shared string": " I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_713",
                        "content": "Given an array of integers `nums` and an integer `k`, return _the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than_ `k`.\n**Example 1:**\n**Input:** nums = \\[10,5,2,6\\], k = 100\n**Output:** 8\n**Explanation:** The 8 subarrays that have product less than 100 are:\n\\[10\\], \\[5\\], \\[2\\], \\[6\\], \\[10, 5\\], \\[5, 2\\], \\[2, 6\\], \\[5, 2, 6\\]\nNote that \\[10, 5, 2\\] is not included as the product of 100 is not strictly less than k.\n**Example 2:**\n**Input:** nums = \\[1,2,3\\], k = 0\n**Output:** 0\n**Constraints:**\n*   `1 <= nums.length <= 3 * 104`\n*   `1 <= nums[i] <= 1000`\n*   `0 <= k <= 106`\nInput:\nnums = \\[10,5,2,6\\], k = 100\nOutput:\n8\n```java\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\nif (k <= 1) return 0;\nint prod = 1, count = 0, left = 0;\nfor (int right = 0; right < nums.length; right++) {\nprod *= nums[right];\nwhile (prod >= k) prod /= nums[left++];\ncount += right - left + 1;\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 415
                },
                {
                        "id": "pretrain_java_data_18133130",
                        "content": "// Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n// Example 1:\n// Input: nums = [10,5,2,6], k = 100\n// Output: 8\n// Explanation: The 8 subarrays that have product less than 100 are:\n// [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\n// Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n// Example 2:\n// Input: nums = [1,2,3], k = 0\n// Output: 0\n// Constraints:\n// 1 <= nums.length <= 3 * 104\n// 1 <= nums[i] <= 1000\n// 0 <= k <= 106\nclass Solution {\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\nint n = nums.length, left = 0, right = 0, pro = 1, count = 0;\nif(k <= 1) return 0;\nwhile(right < n){\npro *= nums[right];\nwhile(pro >= k){\npro /= nums[left++];\n}\ncount += right - left + 1;\nright++;\n}\nreturn count;\n}\n}\n",
                        "max_stars_repo_path": "Sliding-Window/SubarrayProductLessThanK713.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 415
                },
                {
                        "shared string": "the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_713",
                        "content": "Given an array of integers `nums` and an integer `k`, return _the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than_ `k`.\n**Example 1:**\n**Input:** nums = \\[10,5,2,6\\], k = 100\n**Output:** 8\n**Explanation:** The 8 subarrays that have product less than 100 are:\n\\[10\\], \\[5\\], \\[2\\], \\[6\\], \\[10, 5\\], \\[5, 2\\], \\[2, 6\\], \\[5, 2, 6\\]\nNote that \\[10, 5, 2\\] is not included as the product of 100 is not strictly less than k.\n**Example 2:**\n**Input:** nums = \\[1,2,3\\], k = 0\n**Output:** 0\n**Constraints:**\n*   `1 <= nums.length <= 3 * 104`\n*   `1 <= nums[i] <= 1000`\n*   `0 <= k <= 106`\nInput:\nnums = \\[10,5,2,6\\], k = 100\nOutput:\n8\n```java\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\nif (k <= 1) return 0;\nint prod = 1, count = 0, left = 0;\nfor (int right = 0; right < nums.length; right++) {\nprod *= nums[right];\nwhile (prod >= k) prod /= nums[left++];\ncount += right - left + 1;\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 415
                },
                {
                        "id": "pretrain_java_data_18133130",
                        "content": "// Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n// Example 1:\n// Input: nums = [10,5,2,6], k = 100\n// Output: 8\n// Explanation: The 8 subarrays that have product less than 100 are:\n// [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\n// Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n// Example 2:\n// Input: nums = [1,2,3], k = 0\n// Output: 0\n// Constraints:\n// 1 <= nums.length <= 3 * 104\n// 1 <= nums[i] <= 1000\n// 0 <= k <= 106\nclass Solution {\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\nint n = nums.length, left = 0, right = 0, pro = 1, count = 0;\nif(k <= 1) return 0;\nwhile(right < n){\npro *= nums[right];\nwhile(pro >= k){\npro /= nums[left++];\n}\ncount += right - left + 1;\nright++;\n}\nreturn count;\n}\n}\n",
                        "max_stars_repo_path": "Sliding-Window/SubarrayProductLessThanK713.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 415
                },
                {
                        "shared string": "the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```java\npublic class ListNode {\nint val;\nListNode next;\nListNode(int x) { val = x; }\n}\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nListNode dummy = new ListNode(0);\nListNode current = dummy;\nint carry = 0;\nwhile (l1 != null || l2 != null || carry != 0) {\nint sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;\ncarry = sum / 10;\ncurrent.next = new ListNode(sum % 10);\ncurrent = current.next;\nif (l1 != null) l1 = l1.next;\nif (l2 != null) l2 = l2.next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 211
                },
                {
                        "id": "pretrain_java_data_18062212",
                        "content": "<reponame>tirthbharatiya/interview_questions\n/*\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n*/\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nint carry = 0;\nListNode head = new ListNode();\nListNode prev = new ListNode();\nboolean isHead = false;\nwhile(l1 != null || l2 != null) {\nint value = carry;\nif(l1 != null) {\nvalue += l1.val;\n}\nif(l2 != null) {\nvalue += l2.val;\n}\ncarry = value/10;\nprev.next = new ListNode(value%10);\nprev = prev.next;\nif(!isHead) {\nhead = prev;\nisHead = true;\n}\nif(l1 != null) {\nl1 = l1.next;\n}\nif(l2 != null) {\nl2 = l2.next;\n}\n}\nif(carry != 0) {\nprev.next = new ListNode(carry);\n}\nreturn head;\n}\n}",
                        "max_stars_repo_path": "LC_2_add_two_numbers.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 211
                },
                {
                        "shared string": ", and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```java\npublic int rob(int[] nums) {\nif (nums.length == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.length - 1; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.length; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn Math.max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "id": "pretrain_java_data_18159190",
                        "content": "<filename>Problem 213/Problem213.java\n/**\n* You are a professional robber planning to rob houses along a street. Each house has a certain amount of money\n* stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last\n* one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if\n* two adjacent houses were broken into on the same night.\n*\n* Given an integer array nums representing the amount of money of each house, return the maximum amount of money you\n* can rob tonight without alerting the police.\n*\n* Example 1:\n* Input: nums = [2,3,2]\n* Output: 3\n* Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n*\n* Example 2:\n* Input: nums = [1,2,3,1]\n* Output: 4\n* Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n* Total amount you can rob = 1 + 3 = 4.\n*\n* Example 3:\n* Input: nums = [0]\n* Output: 0\n*\n* Constraints:\n* 1 <= nums.length <= 100\n* 0 <= nums[i] <= 1000\n*/\npublic class Problem213 {\n/**\n* Method to return max robMoney possible if the given array is circular\n*\n* Time Complexity: O(N)\n* Space Complexity: O(1)\n*\n* @param nums\n* @return\n*/\nprivate static int rob(int[] nums) {\nif (nums.length == 0) { return 0; }\nif (nums.length == 1) { return nums[0]; }\nint robMoney1 = robMoney(nums, 0, nums.length - 2);\nint robMoney2 = robMoney(nums, 1, nums.length - 1);\nreturn Math.max(robMoney1, robMoney2);\n}\n/**\n* Method to return max robMoney for adjacent houses\n*\n* @param nums\n* @param start\n* @param end\n* @return\n*/\nprivate static int robMoney(int[] nums, int start, int end) {\nint curr = 0, prev = 0;\nfor (int i = start; i <= end; i++) {\nint temp = curr;\ncurr = Math.max(curr, prev + nums[i]);\nprev = temp;\n}\nreturn curr;\n}\n/**\n* Main method for test cases\n*\n* @param args\n*/\npublic static void main(String[] args) {\nint[] nums = {1,2,3,1};\nSystem.out.println(rob(nums));\n}\n}",
                        "max_stars_repo_path": "Problem 213/Problem213.java",
                        "max_stars_repo_name": "innocentdevil09/LeetCode",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money ",
                        "real_dup": 2
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_189",
                        "content": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative.\n**Example 1:**\n**Input:** nums = \\[1,2,3,4,5,6,7\\], k = 3\n**Output:** \\[5,6,7,1,2,3,4\\]\n**Explanation:**\nrotate 1 steps to the right: \\[7,1,2,3,4,5,6\\]\nrotate 2 steps to the right: \\[6,7,1,2,3,4,5\\]\nrotate 3 steps to the right: \\[5,6,7,1,2,3,4\\]\n**Example 2:**\n**Input:** nums = \\[-1,-100,3,99\\], k = 2\n**Output:** \\[3,99,-1,-100\\]\n**Explanation:**\nrotate 1 steps to the right: \\[99,-1,-100,3\\]\nrotate 2 steps to the right: \\[3,99,-1,-100\\]\n**Constraints:**\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `0 <= k <= 105`\n**Follow up:**\n*   Try to come up with as many solutions as you can. There are at least **three** different ways to solve this problem.\n*   Could you do it in-place with `O(1)` extra space?\nInput:\nnums = \\[1,2,3,4,5,6,7\\], k = 3\nOutput:\n\\[5,6,7,1,2,3,4\\]\n```java\npublic void rotate(int[] nums, int k) {\nint n = nums.length;\nk %= n;\nreverse(nums, 0, n - 1);\nreverse(nums, 0, k - 1);\nreverse(nums, k, n - 1);\n}\nprivate void reverse(int[] nums, int start, int end) {\nwhile (start < end) {\nint temp = nums[start];\nnums[start++] = nums[end];\nnums[end--] = temp;\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 291
                },
                {
                        "id": "pretrain_java_data_19640445",
                        "content": "/*\nGiven an array, rotate the array to the right by k steps, where k is non-negative.\nFollow up:\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\nCould you do it in-place with O(1) extra space?\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation:\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\nConstraints:\n1 <= nums.length <= 2 * 104\n-2^31 <= nums[i] <= 2^31 - 1\n0 <= k <= 10^5\n*/\nclass Solution {\npublic void rotate(int[] nums, int k) {\nk %= nums.length;\nreverse(nums, 0, nums.length - 1);\nreverse(nums, 0, k-1);\nreverse(nums, k, nums.length - 1);\n}\npublic void reverse(int[] nums, int start, int end) {\nwhile (start < end) {\nint temp = nums[start];\nnums[start] = nums[end];\nnums[end] = temp;\nstart++;\nend--;\n}\n}\n}",
                        "max_stars_repo_path": "interview_questions/Java/LC_189_rotate_array.java",
                        "max_stars_repo_name": "tirth1/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 291
                },
                {
                        "shared string": ", rotate the array to the right by "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_19626368",
                        "content": "<filename>LC_64_minimum_path_sum.java\n/*\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample 1:\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\nExample 2:\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\n0 <= grid[i][j] <= 100\n*/\nclass Solution {\npublic int minPathSum(int[][] grid) {\nint m = grid.length;\nint n = grid[0].length;\nint[][] dp = new int[m][n];\ndp[m-1][n-1] = grid[m-1][n-1];\nfor(int i=m-2; i>=0; i--) {\ndp[i][n-1] = grid[i][n-1] + dp[i+1][n-1];\n}\nfor(int i=n-2; i>=0; i--) {\ndp[m-1][i] = grid[m-1][i] + dp[m-1][i+1];\n}\nfor(int i=m-2; i>=0; i--) {\nfor(int j = n-2; j>=0; j--) {\ndp[i][j] = Math.min(dp[i][j+1], dp[i+1][j]) + grid[i][j];\n}\n}\nreturn dp[0][0];\n}\n}",
                        "max_stars_repo_path": "LC_64_minimum_path_sum.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 251
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```java\npublic int minPathSum(int[][] grid) {\nint m = grid.length, n = grid[0].length;\nfor(int i = 1; i < m; i++)\ngrid[i][0] += grid[i - 1][0];\nfor(int i = 1; i < n; i++)\ngrid[0][i] += grid[0][i - 1];\nfor(int i = 1; i < m; i++){\nfor(int j = 1; j < n; j++){\ngrid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n}\n}\nreturn grid[m - 1][n - 1];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 251
                },
                {
                        "shared string": " filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_538",
                        "content": "Given the `root` of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a _binary search tree_ is a tree that satisfies these constraints:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\n**Output:** \\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n**Example 2:**\n**Input:** root = \\[0,null,1\\]\n**Output:** \\[1,null,1\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-104 <= Node.val <= 104`\n*   All the values in the tree are **unique**.\n*   `root` is guaranteed to be a valid binary search tree.\n**Note:** This question is the same as 1038: [https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)\nInput:\nroot = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\nOutput:\n\\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\nclass Solution {\nint sum = 0;\npublic TreeNode convertBST(TreeNode root) {\nif (root != null) {\nconvertBST(root.right);\nsum += root.val;\nroot.val = sum;\nconvertBST(root.left);\n}\nreturn root;\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 13
                },
                {
                        "id": "pretrain_java_data_5308610",
                        "content": "/*\nGiven the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\nExample 2:\nInput: root = [0,null,1]\nOutput: [1,null,1]\nConstraints:\nThe number of nodes in the tree is in the range [0, 10^4].\n-10^4 <= Node.val <= 10^4\nAll the values in the tree are unique.\nroot is guaranteed to be a valid binary search tree.\n*/\nclass Solution {\nint prev = 0;\npublic TreeNode convertBST(TreeNode root) {\nif(root == null) {\nreturn root;\n}\nconvertBST(root.right);\nroot.val += prev;\nprev = root.val;\nconvertBST(root.left);\nreturn root;\n}\n}",
                        "max_stars_repo_path": "LC_538_convert_bst_to_greater_tree.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 0,
                        "__cluster__": 13
                },
                {
                        "shared string": " of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_538",
                        "content": "Given the `root` of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a _binary search tree_ is a tree that satisfies these constraints:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\n**Output:** \\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n**Example 2:**\n**Input:** root = \\[0,null,1\\]\n**Output:** \\[1,null,1\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-104 <= Node.val <= 104`\n*   All the values in the tree are **unique**.\n*   `root` is guaranteed to be a valid binary search tree.\n**Note:** This question is the same as 1038: [https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)\nInput:\nroot = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\nOutput:\n\\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\nclass Solution {\nint sum = 0;\npublic TreeNode convertBST(TreeNode root) {\nif (root != null) {\nconvertBST(root.right);\nsum += root.val;\nroot.val = sum;\nconvertBST(root.left);\n}\nreturn root;\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 13
                },
                {
                        "id": "pretrain_java_data_5308610",
                        "content": "/*\nGiven the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\nExample 2:\nInput: root = [0,null,1]\nOutput: [1,null,1]\nConstraints:\nThe number of nodes in the tree is in the range [0, 10^4].\n-10^4 <= Node.val <= 10^4\nAll the values in the tree are unique.\nroot is guaranteed to be a valid binary search tree.\n*/\nclass Solution {\nint prev = 0;\npublic TreeNode convertBST(TreeNode root) {\nif(root == null) {\nreturn root;\n}\nconvertBST(root.right);\nroot.val += prev;\nprev = root.val;\nconvertBST(root.left);\nreturn root;\n}\n}",
                        "max_stars_repo_path": "LC_538_convert_bst_to_greater_tree.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 0,
                        "__cluster__": 13
                },
                {
                        "shared string": " of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```java\npublic class ListNode {\nint val;\nListNode next;\nListNode(int x) { val = x; }\n}\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nListNode dummy = new ListNode(0);\nListNode current = dummy;\nint carry = 0;\nwhile (l1 != null || l2 != null || carry != 0) {\nint sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;\ncarry = sum / 10;\ncurrent.next = new ListNode(sum % 10);\ncurrent = current.next;\nif (l1 != null) l1 = l1.next;\nif (l2 != null) l2 = l2.next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 211
                },
                {
                        "id": "pretrain_java_data_6940485",
                        "content": "// @desc-start\n// You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\n// You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n//\n// Example 1:\n//\n//\n// Input: l1 = [2,4,3], l2 = [5,6,4]\n// Output: [7,0,8]\n// Explanation: 342 + 465 = 807.\n//\n// Example 2:\n//\n// Input: l1 = [0], l2 = [0]\n// Output: [0]\n//\n// Example 3:\n//\n// Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n// Output: [8,9,9,9,0,0,0,1]\n//\n//\n// Constraints:\n//\n// The number of nodes in each linked list is in the range [1, 100].\n// 0 <= Node.val <= 9\n// It is guaranteed that the list represents a number that does not have leading zeros.\n//\n//\n// @desc-end\n// @code-start\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nListNode ret = null;\nListNode curr = ret;\nint c = 0;\nwhile(l1 != null || l2 != null) {\nint v1 = l1 == null ? 0 : l1.val;\nint v2 = l2 == null ? 0 : l2.val;\nint sum = v1 + v2 + c;\nint v = sum % 10;\nc = sum / 10;\nif(curr == null) {\ncurr = new ListNode(v);\nret = curr;\n} else {\nListNode n = new ListNode(v);\ncurr.next = n;\ncurr = n;\n}\nif(l1 != null) l1 = l1.next;\nif(l2 != null) l2 = l2.next;\n}\nif(c > 0) {\ncurr.next = new ListNode(c);\n}\nreturn ret;\n}\n}\n// @code-end",
                        "max_stars_repo_path": "solutions/java/no-0002-add-two-numbers.java",
                        "max_stars_repo_name": "youkabeng/conquer-leetcode",
                        "max_stars_count": 0,
                        "__cluster__": 211
                },
                {
                        "shared string": " You may assume the two numbers do not contain any leading zero, except the number 0 itself. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_8492082",
                        "content": "package com.acesoft.leetcode;\n/*\n* https://leetcode.com/problems/minimum-path-sum\n*\n* Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right,\n* which minimizes the sum of all numbers along its path.\n*\n* Note: You can only move either down or right at any point in time.\n*\n* Example 1:\n* Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n* Output: 7\n* Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n*\n* Example 2:\n* Input: grid = [[1,2,3],[4,5,6]]\n* Output: 12\n*\n* Constraints:\n* m == grid.length\n* n == grid[i].length\n* 1 <= m, n <= 200\n* 0 <= grid[i][j] <= 100\n*/\npublic class LeetCode64 {\nprivate int[][] cache;\nprivate int getShortestPath(int m, int n, int[][] grid) {\nif (m == 0 && n == 0) {\nreturn grid[m][n];\n}\nif (cache[m][n] != 0) {\nreturn cache[m][n];\n}\nif (m == 0) {\ncache[m][n] = grid[m][n] + getShortestPath(m, n - 1, grid);\nreturn cache[m][n];\n}\nif (n == 0) {\ncache[m][n] = grid[m][n] + getShortestPath(m - 1, n, grid);\nreturn cache[m][n];\n}\ncache[m][n] = grid[m][n] + Math.min(getShortestPath(m - 1, n, grid), getShortestPath(m, n - 1, grid));\nreturn cache[m][n];\n}\npublic int minPathSum(int[][] grid) {\nint x = grid.length, y = grid[0].length;\ncache = new int[x][y];\nreturn getShortestPath(x - 1, y - 1, grid);\n}\n}",
                        "max_stars_repo_path": "src/main/java/com/acesoft/leetcode/LeetCode64.java",
                        "max_stars_repo_name": "anchit-choudhry/LeetCode",
                        "max_stars_count": 1,
                        "__cluster__": 251
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```java\npublic int minPathSum(int[][] grid) {\nint m = grid.length, n = grid[0].length;\nfor(int i = 1; i < m; i++)\ngrid[i][0] += grid[i - 1][0];\nfor(int i = 1; i < n; i++)\ngrid[0][i] += grid[0][i - 1];\nfor(int i = 1; i < m; i++){\nfor(int j = 1; j < n; j++){\ngrid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n}\n}\nreturn grid[m - 1][n - 1];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 251
                },
                {
                        "shared string": " filled with non-negative numbers, find a path from top left to bottom right, ",
                        "real_dup": 2
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_8598089",
                        "content": "package pers.tavish.leetcode.easy;\n/*\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\n- The number of nodes in the tree is in the range [0, 105].\n- -1000 <= Node.val <= 1000\nfor more information: https://leetcode.com/problems/minimum-depth-of-binary-tree/\n*/\nimport pers.tavish.leetcode.struct.TreeNode;\nimport java.util.Objects;\npublic class MinimumDepthOfBinaryTree {\npublic int minDepth(TreeNode root) {\nif (Objects.isNull(root)) {\nreturn 0;\n}\nint l = minDepth(root.left), r = minDepth(root.right);\nreturn l == 0 || r == 0 ? 1 + l + r : 1 + Math.min(l, r);\n}\n}",
                        "max_stars_repo_path": "src/main/java/pers/tavish/leetcode/easy/MinimumDepthOfBinaryTree.java",
                        "max_stars_repo_name": "Tavi3h/LeetCode_3rd",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_8598089",
                        "content": "package pers.tavish.leetcode.easy;\n/*\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\n- The number of nodes in the tree is in the range [0, 105].\n- -1000 <= Node.val <= 1000\nfor more information: https://leetcode.com/problems/minimum-depth-of-binary-tree/\n*/\nimport pers.tavish.leetcode.struct.TreeNode;\nimport java.util.Objects;\npublic class MinimumDepthOfBinaryTree {\npublic int minDepth(TreeNode root) {\nif (Objects.isNull(root)) {\nreturn 0;\n}\nint l = minDepth(root.left), r = minDepth(root.right);\nreturn l == 0 || r == 0 ? 1 + l + r : 1 + Math.min(l, r);\n}\n}",
                        "max_stars_repo_path": "src/main/java/pers/tavish/leetcode/easy/MinimumDepthOfBinaryTree.java",
                        "max_stars_repo_name": "Tavi3h/LeetCode_3rd",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_8598089",
                        "content": "package pers.tavish.leetcode.easy;\n/*\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\n- The number of nodes in the tree is in the range [0, 105].\n- -1000 <= Node.val <= 1000\nfor more information: https://leetcode.com/problems/minimum-depth-of-binary-tree/\n*/\nimport pers.tavish.leetcode.struct.TreeNode;\nimport java.util.Objects;\npublic class MinimumDepthOfBinaryTree {\npublic int minDepth(TreeNode root) {\nif (Objects.isNull(root)) {\nreturn 0;\n}\nint l = minDepth(root.left), r = minDepth(root.right);\nreturn l == 0 || r == 0 ? 1 + l + r : 1 + Math.min(l, r);\n}\n}",
                        "max_stars_repo_path": "src/main/java/pers/tavish/leetcode/easy/MinimumDepthOfBinaryTree.java",
                        "max_stars_repo_name": "Tavi3h/LeetCode_3rd",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_263",
                        "content": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\nGiven an integer `n`, return `true` _if_ `n` _is an **ugly number**_.\n**Example 1:**\n**Input:** n = 6\n**Output:** true\n**Explanation:** 6 = 2 \\* 3\n**Example 2:**\n**Input:** n = 1\n**Output:** true\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n**Example 3:**\n**Input:** n = 14\n**Output:** false\n**Explanation:** 14 is not ugly since it includes the prime factor 7.\n**Constraints:**\n*   `-231 <= n <= 231 - 1`\nInput:\nn = 6\nOutput:\ntrue\n```java\npublic boolean isUgly(int n) {\nif (n <= 0) return false;\nwhile (n % 2 == 0) n /= 2;\nwhile (n % 3 == 0) n /= 3;\nwhile (n % 5 == 0) n /= 5;\nreturn n == 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 321
                },
                {
                        "id": "pretrain_java_data_10108691",
                        "content": "/*\nAn ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return true if n is an ugly number.\nExample 1:\nInput: n = 6\nOutput: true\nExplanation: 6 = 2 \u00d7 3\nExample 2:\nInput: n = 8\nOutput: true\nExplanation: 8 = 2 \u00d7 2 \u00d7 2\nExample 3:\nInput: n = 14\nOutput: false\nExplanation: 14 is not ugly since it includes the prime factor 7.\nExample 4:\nInput: n = 1\nOutput: true\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nConstraints:\n-2^31 <= n <= 2^31 - 1\n*/\nclass Solution {\npublic boolean isUgly(int n) {\nif(n<1) {\nreturn false;\n}\nwhile(n%2 == 0) {\nn /= 2;\n}\nwhile(n%3 == 0) {\nn /= 3;\n}\nwhile(n%5 == 0) {\nn /= 5;\n}\nreturn n==1;\n}\n}",
                        "max_stars_repo_path": "LC_263_ugly_number.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 321
                },
                {
                        "shared string": " 1 has no prime factors, therefore all of its prime factors are limited to 2, "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_147",
                        "content": "Given the `head` of a singly linked list, sort the list using **insertion sort**, and return _the sorted list's head_.\nThe steps of the **insertion sort** algorithm:\n1.  Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.\n2.  At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.\n3.  It repeats until no input elements remain.\nThe following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\n**Example 1:**\n**Input:** head = \\[4,2,1,3\\]\n**Output:** \\[1,2,3,4\\]\n**Example 2:**\n**Input:** head = \\[-1,5,3,4,0\\]\n**Output:** \\[-1,0,3,4,5\\]\n**Constraints:**\n*   The number of nodes in the list is in the range `[1, 5000]`.\n*   `-5000 <= Node.val <= 5000`\nInput:\nhead = \\[4,2,1,3\\]\nOutput:\n\\[1,2,3,4\\]\n```java\nclass ListNode {\nint val;\nListNode next;\n}\npublic ListNode insertionSortList(ListNode head) {\nListNode dummy = new ListNode(0);\nListNode cur;\nwhile (head != null) {\ncur = dummy;\nwhile (cur.next != null && cur.next.val < head.val) {\ncur = cur.next;\n}\nListNode temp = head.next;\nhead.next = cur.next;\ncur.next = head;\nhead = temp;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 281
                },
                {
                        "id": "pretrain_java_data_10186190",
                        "content": "<reponame>devangi2000/Data-Structures-Algorithms-Handbook<filename>Linked-Lists/InsertionSortList147.java\n// Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.\n// The steps of the insertion sort algorithm:\n// Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.\n// At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.\n// It repeats until no input elements remain.\n// The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\n// Example 1:\n// Input: head = [4,2,1,3]\n// Output: [1,2,3,4]\n// Example 2:\n// Input: head = [-1,5,3,4,0]\n// Output: [-1,0,3,4,5]\n// Constraints:\n// The number of nodes in the list is in the range [1, 5000].\n// -5000 <= Node.val <= 5000\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode insertionSortList(ListNode head) {\nListNode dummy = new ListNode(0), curr = head, next = null;\nwhile(curr != null){\nnext = curr.next;\nListNode it = dummy;\nwhile(it.next != null && it.next.val < curr.val)\nit = it.next;\ncurr.next = it.next;\nit.next = curr;\ncurr = next;\n}\nreturn dummy.next;\n}\n}",
                        "max_stars_repo_path": "Linked-Lists/InsertionSortList147.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 281
                },
                {
                        "shared string": " At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted li"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_142",
                        "content": "Given the `head` of a linked list, return _the node where the cycle begins. If there is no cycle, return_ `null`.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to (**0-indexed**). It is `-1` if there is no cycle. **Note that** `pos` **is not passed as a parameter**.\n**Do not modify** the linked list.\n**Example 1:**\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** tail connects to node index 1\n**Explanation:** There is a cycle in the linked list, where tail connects to the second node.\n**Example 2:**\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** tail connects to node index 0\n**Explanation:** There is a cycle in the linked list, where tail connects to the first node.\n**Example 3:**\n**Input:** head = \\[1\\], pos = -1\n**Output:** no cycle\n**Explanation:** There is no cycle in the linked list.\n**Constraints:**\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?\nInput:\nhead = \\[3,2,0,-4\\], pos = 1\nOutput:\ntail connects to node index 1\n```java\npublic class ListNode {\nint val;\nListNode next;\n}\npublic ListNode detectCycle(ListNode head) {\nListNode slow = head, fast = head;\nwhile (fast != null && fast.next != null) {\nslow = slow.next;\nfast = fast.next.next;\nif (slow == fast) {\nListNode start = head;\nwhile (start != slow) {\nstart = start.next;\nslow = slow.next;\n}\nreturn start;\n}\n}\nreturn null;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 278
                },
                {
                        "id": "pretrain_java_data_13264259",
                        "content": "<reponame>mukeshkumargupta/data-structure-algorithms-java-tutorials\npackage com.interview.linklist;\n/*\n* https://leetcode.com/problems/linked-list-cycle-ii/\n* Category: Medium, Must Do\n* Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\nExample 3:\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.\nConstraints:\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.\nFollow up: Can you solve it using O(1) (i.e. constant) memory?\n*/\npublic class LinkedListCycleII {\npublic ListNode detectCycle(ListNode head) {\nListNode slow = head;\nListNode fast = head;\nwhile (fast != null && fast.next != null) {\nslow = slow.next;\nfast = fast.next.next;\nif (slow == fast) {\nfast = head;\nwhile (slow != fast) {\nslow = slow.next;\nfast = fast.next;\n}\nreturn slow;\n}\n}\nreturn null;\n}\npublic static void main(String[] args) {\n// TODO Auto-generated method stub\n}\n}",
                        "max_stars_repo_path": "src/com/interview/linklist/LinkedListCycleII.java",
                        "max_stars_repo_name": "mukeshkumargupta/data-structure-algorithms-java-tutorials",
                        "max_stars_count": 0,
                        "__cluster__": 278
                },
                {
                        "shared string": ". There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_14921588",
                        "content": "/**\n* You are given an array of binary strings strs and two integers m and n.\n* <p>\n* Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\n* <p>\n* A set x is a subset of a set y if all elements of x are also elements of y.\n* <p>\n* <p>\n* <p>\n* Example 1:\n* <p>\n* Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n* Output: 4\n* Explanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\n* Other valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\n* {\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\n* Example 2:\n* <p>\n* Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n* Output: 2\n* Explanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\n* <p>\n* <p>\n* Constraints:\n* <p>\n* 1 <= strs.length <= 600\n* 1 <= strs[i].length <= 100\n* strs[i] consists only of digits '0' and '1'.\n* 1 <= m, n <= 100\n*/\npackage org.phoenix.leetcode.challenges;\npublic class Problem02_OnesAndZeroes {\npublic int findMaxForm(String[] strs, int m, int n) {\nint[][] dp = new int[m + 1][n + 1];\nfor (String str: strs)\n{\nint zeros = 0, ones = 0;\nchar[] charArr = str.toCharArray();\nfor (char c: charArr)\n{\nif (c == '0') zeros++;\nelse ones++;\n}\nfor (int i = m; i >= zeros; i--)\n{\nfor (int j = n; j >= ones; j--)\n{\ndp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n}\n}\n}\nreturn dp[m][n];\n}\n}",
                        "max_stars_repo_path": "april-2021-leetcode-challenge/src/main/java/org/phoenix/leetcode/challenges/Problem02_OnesAndZeroes.java",
                        "max_stars_repo_name": "vibhorsingh11/LeetCode",
                        "max_stars_count": 0,
                        "__cluster__": 383
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_474",
                        "content": "You are given an array of binary strings `strs` and two integers `m` and `n`.\nReturn _the size of the largest subset of `strs` such that there are **at most**_ `m` `0`_'s and_ `n` `1`_'s in the subset_.\nA set `x` is a **subset** of a set `y` if all elements of `x` are also elements of `y`.\n**Example 1:**\n**Input:** strs = \\[ \"10 \", \"0001 \", \"111001 \", \"1 \", \"0 \"\\], m = 5, n = 3\n**Output:** 4\n**Explanation:** The largest subset with at most 5 0's and 3 1's is { \"10 \",  \"0001 \",  \"1 \",  \"0 \"}, so the answer is 4.\nOther valid but smaller subsets include { \"0001 \",  \"1 \"} and { \"10 \",  \"1 \",  \"0 \"}.\n{ \"111001 \"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\n**Example 2:**\n**Input:** strs = \\[ \"10 \", \"0 \", \"1 \"\\], m = 1, n = 1\n**Output:** 2\n**Explanation:** The largest subset is { \"0 \",  \"1 \"}, so the answer is 2.\n**Constraints:**\n*   `1 <= strs.length <= 600`\n*   `1 <= strs[i].length <= 100`\n*   `strs[i]` consists only of digits `'0'` and `'1'`.\n*   `1 <= m, n <= 100`\nInput:\nstrs = \\[ \"10 \", \"0001 \", \"111001 \", \"1 \", \"0 \"\\], m = 5, n = 3\nOutput:\n4\n```java\nimport java.util.Arrays;\npublic int findMaxForm(String[] strs, int m, int n) {\nint[][] dp = new int[m + 1][n + 1];\nfor (String str: strs) {\nint ones = (int) str.chars().filter(ch -> ch == '1').count();\nint zeros = str.length() - ones;\nfor (int i = m; i >= zeros; --i) {\nfor (int j = n; j >= ones; --j) {\ndp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n}\n}\n}\nreturn dp[m][n];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 383
                },
                {
                        "shared string": " The largest subset with at most 5 0's and 3 1's is {"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_463",
                        "content": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n**Example 1:**\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n**Example 2:**\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n**Example 3:**\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4\n**Constraints:**\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.\nInput:\ngrid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\nOutput:\n16\n```java\npublic int islandPerimeter(int[][] grid) {\nint perimeter = 0;\nfor (int row = 0; row < grid.length; row++) {\nfor (int col = 0; col < grid[row].length; col++) {\nif (grid[row][col] == 1) {\nperimeter += 4;\nif (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\nif (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n}\n}\n}\nreturn perimeter;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 379
                },
                {
                        "id": "pretrain_java_data_2360751",
                        "content": "<filename>Matrix/IslandPerimeter463.java\n// You are given row x col grid representing a map where grid[i][j] = 1 represents\n// land and grid[i][j] = 0 represents water.\n// Grid cells are connected horizontally/vertically (not diagonally). The grid is completely\n// surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n// The island doesn't have \"lakes\", meaning the water inside isn't connected to the water around\n//  the island. One cell is a square with side length 1. The grid is rectangular, width and\n//  height don't exceed 100. Determine the perimeter of the island.\n// Example 1:\n// Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n// Output: 16\n// Explanation: The perimeter is the 16 yellow stripes in the image above.\n// Example 2:\n// Input: grid = [[1]]\n// Output: 4\n// Example 3:\n// Input: grid = [[1,0]]\n// Output: 4\n// Constraints:\n// row == grid.length\n// col == grid[i].length\n// 1 <= row, col <= 100\n// grid[i][j] is 0 or 1.\n// There is exactly one island in grid.\nclass Solution {\npublic int islandPerimeter(int[][] grid) {\nint n = grid.length, m = grid[0].length, ans = 0;\nfor(int i = 0; i < n; i++){\nfor(int j = 0; j < m; j++){\nif(grid[i][j] == 1){\nans += 4;\nans -= (i > 0 && grid[i-1][j] == 1) ? 1 : 0;\nans -= (i < n - 1 && grid[i+1][j] == 1) ? 1 : 0;\nans -= (j > 0 && grid[i][j-1] == 1) ? 1 : 0;\nans -= (j < m - 1 && grid[i][j+1] == 1) ? 1 : 0;\n}\n}\n}\nreturn ans;\n}\n}",
                        "max_stars_repo_path": "Matrix/IslandPerimeter463.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 379
                },
                {
                        "shared string": " surrounded by water, and there is exactly one island (i.e., one or more connected land cells). "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_463",
                        "content": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n**Example 1:**\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n**Example 2:**\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n**Example 3:**\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4\n**Constraints:**\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.\nInput:\ngrid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\nOutput:\n16\n```java\npublic int islandPerimeter(int[][] grid) {\nint perimeter = 0;\nfor (int row = 0; row < grid.length; row++) {\nfor (int col = 0; col < grid[row].length; col++) {\nif (grid[row][col] == 1) {\nperimeter += 4;\nif (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\nif (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n}\n}\n}\nreturn perimeter;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 379
                },
                {
                        "id": "pretrain_java_data_2360751",
                        "content": "<filename>Matrix/IslandPerimeter463.java\n// You are given row x col grid representing a map where grid[i][j] = 1 represents\n// land and grid[i][j] = 0 represents water.\n// Grid cells are connected horizontally/vertically (not diagonally). The grid is completely\n// surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n// The island doesn't have \"lakes\", meaning the water inside isn't connected to the water around\n//  the island. One cell is a square with side length 1. The grid is rectangular, width and\n//  height don't exceed 100. Determine the perimeter of the island.\n// Example 1:\n// Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n// Output: 16\n// Explanation: The perimeter is the 16 yellow stripes in the image above.\n// Example 2:\n// Input: grid = [[1]]\n// Output: 4\n// Example 3:\n// Input: grid = [[1,0]]\n// Output: 4\n// Constraints:\n// row == grid.length\n// col == grid[i].length\n// 1 <= row, col <= 100\n// grid[i][j] is 0 or 1.\n// There is exactly one island in grid.\nclass Solution {\npublic int islandPerimeter(int[][] grid) {\nint n = grid.length, m = grid[0].length, ans = 0;\nfor(int i = 0; i < n; i++){\nfor(int j = 0; j < m; j++){\nif(grid[i][j] == 1){\nans += 4;\nans -= (i > 0 && grid[i-1][j] == 1) ? 1 : 0;\nans -= (i < n - 1 && grid[i+1][j] == 1) ? 1 : 0;\nans -= (j > 0 && grid[i][j-1] == 1) ? 1 : 0;\nans -= (j < m - 1 && grid[i][j+1] == 1) ? 1 : 0;\n}\n}\n}\nreturn ans;\n}\n}",
                        "max_stars_repo_path": "Matrix/IslandPerimeter463.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 379
                },
                {
                        "shared string": " surrounded by water, and there is exactly one island (i.e., one or more connected land cells). "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_2376630",
                        "content": "/*\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed.\nAll houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile,\nadjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [0]\nOutput: 0\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000\n*/\nclass Solution {\npublic int rob(int[] nums) {\nint len = nums.length;\nif(len == 0) {\nreturn 0;\n}\nif(len == 1) {\nreturn nums[0];\n}\nif(len == 2) {\nreturn Math.max(nums[0], nums[1]);\n}\nreturn Math.max(maxAmount(nums, 0, len-2), maxAmount(nums, 1, len-1));\n}\nint maxAmount(int[] nums, int start, int end) {\nint prev1 = 0;\nint prev2 = 0;\nfor(int i= start; i<=end; i++) {\nint temp = prev1;\nprev1 = Math.max(prev2+nums[i], prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n}",
                        "max_stars_repo_path": "interview_questions/Java/LC_213_house_robber_II.java",
                        "max_stars_repo_name": "tirth1/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 301
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```java\npublic int rob(int[] nums) {\nif (nums.length == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.length - 1; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.length; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn Math.max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are ",
                        "real_dup": 2
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_230",
                        "content": "Given the `root` of a binary search tree, and an integer `k`, return _the_ `kth` _smallest value (**1-indexed**) of all the values of the nodes in the tree_.\n**Example 1:**\n**Input:** root = \\[3,1,4,null,2\\], k = 1\n**Output:** 1\n**Example 2:**\n**Input:** root = \\[5,3,6,2,4,null,null,1\\], k = 3\n**Output:** 3\n**Constraints:**\n*   The number of nodes in the tree is `n`.\n*   `1 <= k <= n <= 104`\n*   `0 <= Node.val <= 104`\n**Follow up:** If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?\nInput:\nroot = \\[3,1,4,null,2\\], k = 1\nOutput:\n1\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\npublic int kthSmallest(TreeNode root, int k) {\nStack<TreeNode> stk = new Stack<>();\nTreeNode curr = root;\nwhile (true) {\nwhile (curr != null) {\nstk.push(curr);\ncurr = curr.left;\n}\ncurr = stk.pop();\nif (--k == 0) return curr.val;\ncurr = curr.right;\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 12
                },
                {
                        "id": "pretrain_java_data_16732550",
                        "content": "<filename>Trees/KthSmallestElementInBST.java\n// Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the\n//  values of the nodes in the tree.\n// Example 1:\n// Input: root = [3,1,4,null,2], k = 1\n// Output: 1\n// Example 2:\n// Input: root = [5,3,6,2,4,null,null,1], k = 3\n// Output: 3\n// Constraints:\n// The number of nodes in the tree is n.\n// 1 <= k <= n <= 104\n// 0 <= Node.val <= 104\n// Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the\n// kth smallest frequently, how would you optimize?\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic int kthSmallest(TreeNode root, int k) {\nStack<TreeNode> st = new Stack<>();\nwhile(root != null || !st.isEmpty()){\nwhile(root != null){\nst.push(root);\nroot = root.left;\n}\nroot = st.pop();\nif(--k == 0) return root.val;\nelse root = root.right;\n}\nreturn -1;\n}\n}",
                        "max_stars_repo_path": "Trees/KthSmallestElementInBST.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 12
                },
                {
                        "shared string": " If the BST is modified often (i.e., we can do "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_35",
                        "content": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with `O(log n)` runtime complexity.\n**Example 1:**\n**Input:** nums = \\[1,3,5,6\\], target = 5\n**Output:** 2\n**Example 2:**\n**Input:** nums = \\[1,3,5,6\\], target = 2\n**Output:** 1\n**Example 3:**\n**Input:** nums = \\[1,3,5,6\\], target = 7\n**Output:** 4\n**Constraints:**\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` contains **distinct** values sorted in **ascending** order.\n*   `-104 <= target <= 104`\nInput:\nnums = \\[1,3,5,6\\], target = 5\nOutput:\n2\n```java\npublic int searchInsert(int[] nums, int target) {\nint left = 0, right = nums.length - 1;\nwhile (left <= right) {\nint mid = left + (right - left) / 2;\nif (nums[mid] == target) return mid;\nif (nums[mid] < target) left = mid + 1;\nelse right = mid - 1;\n}\nreturn left;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 233
                },
                {
                        "id": "pretrain_java_data_16710445",
                        "content": "<gh_stars>10-100\n// Given a sorted array of distinct integers and a target value, return the index\n// if the target is found. If not, return the index where it would be if\n//   it were inserted in order.\n// You must write an algorithm with O(log n) runtime complexity.\n// Example 1:\n// Input: nums = [1,3,5,6], target = 5\n// Output: 2\n// Example 2:\n// Input: nums = [1,3,5,6], target = 2\n// Output: 1\n// Example 3:\n// Input: nums = [1,3,5,6], target = 7\n// Output: 4\n// Example 4:\n// Input: nums = [1,3,5,6], target = 0\n// Output: 0\n// Example 5:\n// Input: nums = [1], target = 0\n// Output: 0\n// Constraints:\n// 1 <= nums.length <= 104\n// -104 <= nums[i] <= 104\n// nums contains distinct values sorted in ascending order.\n// -104 <= target <= 104\nclass Solution {\npublic int searchInsert(int[] nums, int target) {\nif(target < nums[0]) return 0;\nif(target > nums[nums.length - 1]) return nums.length;\nint low = 0, high = nums.length - 1, ans = -1, last = -1;\nwhile(low <= high){\nint mid = low + (high - low) / 2;\nif(nums[mid] == target){\nans = mid;\nbreak;\n}\nelse if(nums[mid] < target){\nlow = mid + 1;\nlast = mid;\n}\nelse high = mid - 1;\n}\nreturn ans == -1 ? last + 1 : ans;\n}\n}",
                        "max_stars_repo_path": "Binary-Search/Search-Insert-Position-35.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 233
                },
                {
                        "shared string": "Given a sorted array of distinct integers and a target value, return the index "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_322",
                        "content": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\nYou may assume that you have an infinite number of each kind of coin.\n**Example 1:**\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n**Example 2:**\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n**Example 3:**\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0\n**Constraints:**\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`\nInput:\ncoins = \\[1,2,5\\], amount = 11\nOutput:\n3\n```java\npublic int coinChange(int[] coins, int amount) {\nint[] dp = new int[amount + 1];\nArrays.fill(dp, amount + 1);\ndp[0] = 0;\nfor (int coin : coins) {\nfor (int i = coin; i <= amount; i++) {\ndp[i] = Math.min(dp[i], dp[i - coin] + 1);\n}\n}\nreturn dp[amount] <= amount ? dp[amount] : -1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 342
                },
                {
                        "id": "pretrain_java_data_19829471",
                        "content": "// You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n// Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n// You may assume that you have an infinite number of each kind of coin.\n// Example 1:\n// Input: coins = [1,2,5], amount = 11\n// Output: 3\n// Explanation: 11 = 5 + 5 + 1\n// Example 2:\n// Input: coins = [2], amount = 3\n// Output: -1\n// Example 3:\n// Input: coins = [1], amount = 0\n// Output: 0\n// Example 4:\n// Input: coins = [1], amount = 1\n// Output: 1\n// Example 5:\n// Input: coins = [1], amount = 2\n// Output: 2\nclass Solution {\npublic int coinChange(int[] coins, int amount) {\nint n = coins.length;\nif(n == 0 || amount == 0) return 0;\nint[][] dp = new int[n+1][amount+1];\nfor(int i = 0; i <= n; i++){\nfor(int j = 0; j <= amount; j++){\nif(j == 0) dp[i][j] = 0;\nelse if(i == 0) dp[i][j] = 100005;\nelse if(coins[i-1] > j) dp[i][j] = dp[i-1][j];\nelse\ndp[i][j] = Math.min(dp[i-1][j], 1 + dp[i][j-coins[i-1]]);\n}\n}\nreturn dp[n][amount] < 100005 ? dp[n][amount] : -1;\n}\n}",
                        "max_stars_repo_path": "Dynamic Programming/Unbounded Knapsack/Coin-Change-322.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 342
                },
                {
                        "shared string": ". If that amount of money cannot be made up by any combination of the coins, return "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_5568789",
                        "content": "/**\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\n3\n/ \\\n9   20\n/  \\\n15   7\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000\n*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\npublic int minDepth(TreeNode root) {\nreturn minDepthBT(root);\n}\nprivate int minDepthBT(TreeNode root){\nif ( root == null)\nreturn 0;\nif (root.left == null && root.right != null) {\nreturn 1 + minDepthBT(root.right);\n} else if (root.left != null && root.right == null) {\nreturn 1 + minDepthBT(root.left);\n}\nreturn 1 + Math.min(minDepthBT(root.left), minDepthBT(root.right));\n}\n}",
                        "max_stars_repo_path": "leetcode/easy/minimum-depth-of-binary-tree/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_5568789",
                        "content": "/**\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\n3\n/ \\\n9   20\n/  \\\n15   7\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000\n*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\npublic int minDepth(TreeNode root) {\nreturn minDepthBT(root);\n}\nprivate int minDepthBT(TreeNode root){\nif ( root == null)\nreturn 0;\nif (root.left == null && root.right != null) {\nreturn 1 + minDepthBT(root.right);\n} else if (root.left != null && root.right == null) {\nreturn 1 + minDepthBT(root.left);\n}\nreturn 1 + Math.min(minDepthBT(root.left), minDepthBT(root.right));\n}\n}",
                        "max_stars_repo_path": "leetcode/easy/minimum-depth-of-binary-tree/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_5568789",
                        "content": "/**\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\n3\n/ \\\n9   20\n/  \\\n15   7\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000\n*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\npublic int minDepth(TreeNode root) {\nreturn minDepthBT(root);\n}\nprivate int minDepthBT(TreeNode root){\nif ( root == null)\nreturn 0;\nif (root.left == null && root.right != null) {\nreturn 1 + minDepthBT(root.right);\n} else if (root.left != null && root.right == null) {\nreturn 1 + minDepthBT(root.left);\n}\nreturn 1 + Math.min(minDepthBT(root.left), minDepthBT(root.right));\n}\n}",
                        "max_stars_repo_path": "leetcode/easy/minimum-depth-of-binary-tree/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_33",
                        "content": "There is an integer array `nums` sorted in ascending order (with **distinct** values).\nPrior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.\nGiven the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.\nYou must write an algorithm with `O(log n)` runtime complexity.\n**Example 1:**\n**Input:** nums = \\[4,5,6,7,0,1,2\\], target = 0\n**Output:** 4\n**Example 2:**\n**Input:** nums = \\[4,5,6,7,0,1,2\\], target = 3\n**Output:** -1\n**Example 3:**\n**Input:** nums = \\[1\\], target = 0\n**Output:** -1\n**Constraints:**\n*   `1 <= nums.length <= 5000`\n*   `-104 <= nums[i] <= 104`\n*   All values of `nums` are **unique**.\n*   `nums` is an ascending array that is possibly rotated.\n*   `-104 <= target <= 104`\nInput:\nnums = \\[4,5,6,7,0,1,2\\], target = 0\nOutput:\n4\n```java\npublic int search(int[] nums, int target) {\nint left = 0, right = nums.length - 1;\nwhile (left <= right) {\nint mid = left + (right - left) / 2;\nif (nums[mid] == target) {\nreturn mid;\n}\nif (nums[mid] >= nums[left]) {\nif (target >= nums[left] && target < nums[mid]) {\nright = mid - 1;\n} else {\nleft = mid + 1;\n}\n} else {\nif (target > nums[mid] && target <= nums[right]) {\nleft = mid + 1;\n} else {\nright = mid - 1;\n}\n}\n}\nreturn -1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 232
                },
                {
                        "id": "pretrain_java_data_15054285",
                        "content": "<reponame>devangi2000/Data-Structures-Algorithms-Handbook<filename>Binary-Search/Search-in-Rotated-Sorted-Array-33.java\n// There is an integer array nums sorted in ascending order (with distinct values).\n// Prior to being passed to your function, nums is rotated at an unknown pivot index\n// k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],\n//                                                            ..., nums[n-1],\n//                                                            nums[0], nums[1], ..., nums[k-1]] (0-indexed).\n//   For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n// Given the array nums after the rotation and an integer target, return the index of target\n// if it is in nums, or -1 if it is not in nums.\n// You must write an algorithm with O(log n) runtime complexity.\n// Example 1:\n// Input: nums = [4,5,6,7,0,1,2], target = 0\n// Output: 4\n// Example 2:\n// Input: nums = [4,5,6,7,0,1,2], target = 3\n// Output: -1\n// Example 3:\n// Input: nums = [1], target = 0\n// Output: -1\n// Constraints:\n// 1 <= nums.length <= 5000\n// -104 <= nums[i] <= 104\n// All values of nums are unique.\n// nums is guaranteed to be rotated at some pivot.\n// -104 <= target <= 104\nclass Solution {\npublic int search(int[] nums, int target) {\nint start = 0, end = nums.length - 1, mid = 0;\nwhile(start <= end){\nmid = start + (end - start) / 2;\nif(nums[mid] == target)\nreturn mid;\nelse if(nums[mid] >= nums[start]){\nif(nums[start] <= target && nums[mid] >= target)\nend = mid - 1;\nelse start = mid + 1;\n}\nelse if(nums[mid] <= nums[end]){\nif(target >= nums[mid] && target <= nums[end])\nstart = mid + 1;\nelse end = mid - 1;\n}\n}\nreturn -1;\n}\n}",
                        "max_stars_repo_path": "Binary-Search/Search-in-Rotated-Sorted-Array-33.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 232
                },
                {
                        "shared string": " Prior to being passed to your function, "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```java\npublic int rob(int[] nums) {\nif (nums.length == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.length - 1; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.length; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn Math.max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "id": "pretrain_java_data_15041065",
                        "content": "/**\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [0]\nOutput: 0\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000\n*/\nclass Solution {\npublic int rob(int[] nums) {\nint len = nums.length;\nif (len == 1) {\nreturn nums[0];\n}\nreturn Math.max(rob(nums, 1, len - 1), rob(nums, 0, len - 2));\n}\nprivate int rob(int[] nums, int start, int end) {\nint rob1 = 0, rob2 = 0;\nfor(int i = start; i <= end; i++) {\nint newRob = Math.max(nums[i] + rob1, rob2);\nrob1 = rob2;\nrob2 = newRob;\n}\nreturn rob2;\n}\n}",
                        "max_stars_repo_path": "leetcode/medium/house-robber-ii/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_865992",
                        "content": "/*\n* @author <NAME>, <EMAIL>\n*/\npackage com.omtia.un;\n/**\n* You are a professional robber planning to rob houses along a street. Each house has a certain amount of money\n* stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems\n* connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n*\n* Given an integer array nums representing the amount of money of each house, return the maximum amount of money you\n* can rob tonight without alerting the police.\n*\n*\n*\n* Example 1:\n*\n* Input: nums = [1,2,3,1]\n* Output: 4\n* Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n* Total amount you can rob = 1 + 3 = 4.\n* Example 2:\n*\n* Input: nums = [2,7,9,3,1]\n* Output: 12\n* Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n* Total amount you can rob = 2 + 9 + 1 = 12.\n*\n*\n* Constraints:\n*\n* 1 <= nums.length <= 100\n* 0 <= nums[i] <= 400\n*/\npublic class _198_house_robber {\n// TC: O(n)\n// SC: O(n)\npublic int rob(int[] nums) {\nint n = nums.length;\nif(n == 1) return nums[0];\nif(n == 2) return Math.max(nums[0], nums[1]);\nint[] dp = new int[n+1];\ndp[0] = nums[0];\ndp[1] = Math.max(nums[1], nums[0]);\nfor(int i = 2; i < n; i++) {\ndp[i] = Math.max(dp[i-1], nums[i] + dp[i-2]);\n}\nreturn dp[n-1];\n}\n}",
                        "max_stars_repo_path": "src/main/java/com/omtia/un/_198_house_robber.java",
                        "max_stars_repo_name": "Andreii/algo",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": " stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_865992",
                        "content": "/*\n* @author <NAME>, <EMAIL>\n*/\npackage com.omtia.un;\n/**\n* You are a professional robber planning to rob houses along a street. Each house has a certain amount of money\n* stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems\n* connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n*\n* Given an integer array nums representing the amount of money of each house, return the maximum amount of money you\n* can rob tonight without alerting the police.\n*\n*\n*\n* Example 1:\n*\n* Input: nums = [1,2,3,1]\n* Output: 4\n* Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n* Total amount you can rob = 1 + 3 = 4.\n* Example 2:\n*\n* Input: nums = [2,7,9,3,1]\n* Output: 12\n* Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n* Total amount you can rob = 2 + 9 + 1 = 12.\n*\n*\n* Constraints:\n*\n* 1 <= nums.length <= 100\n* 0 <= nums[i] <= 400\n*/\npublic class _198_house_robber {\n// TC: O(n)\n// SC: O(n)\npublic int rob(int[] nums) {\nint n = nums.length;\nif(n == 1) return nums[0];\nif(n == 2) return Math.max(nums[0], nums[1]);\nint[] dp = new int[n+1];\ndp[0] = nums[0];\ndp[1] = Math.max(nums[1], nums[0]);\nfor(int i = 2; i < n; i++) {\ndp[i] = Math.max(dp[i-1], nums[i] + dp[i-2]);\n}\nreturn dp[n-1];\n}\n}",
                        "max_stars_repo_path": "src/main/java/com/omtia/un/_198_house_robber.java",
                        "max_stars_repo_name": "Andreii/algo",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": " stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_865992",
                        "content": "/*\n* @author <NAME>, <EMAIL>\n*/\npackage com.omtia.un;\n/**\n* You are a professional robber planning to rob houses along a street. Each house has a certain amount of money\n* stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems\n* connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n*\n* Given an integer array nums representing the amount of money of each house, return the maximum amount of money you\n* can rob tonight without alerting the police.\n*\n*\n*\n* Example 1:\n*\n* Input: nums = [1,2,3,1]\n* Output: 4\n* Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n* Total amount you can rob = 1 + 3 = 4.\n* Example 2:\n*\n* Input: nums = [2,7,9,3,1]\n* Output: 12\n* Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n* Total amount you can rob = 2 + 9 + 1 = 12.\n*\n*\n* Constraints:\n*\n* 1 <= nums.length <= 100\n* 0 <= nums[i] <= 400\n*/\npublic class _198_house_robber {\n// TC: O(n)\n// SC: O(n)\npublic int rob(int[] nums) {\nint n = nums.length;\nif(n == 1) return nums[0];\nif(n == 2) return Math.max(nums[0], nums[1]);\nint[] dp = new int[n+1];\ndp[0] = nums[0];\ndp[1] = Math.max(nums[1], nums[0]);\nfor(int i = 2; i < n; i++) {\ndp[i] = Math.max(dp[i-1], nums[i] + dp[i-2]);\n}\nreturn dp[n-1];\n}\n}",
                        "max_stars_repo_path": "src/main/java/com/omtia/un/_198_house_robber.java",
                        "max_stars_repo_name": "Andreii/algo",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": " stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_878347",
                        "content": "/*\nLC213. House Robber II\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [1,2,3]\nOutput: 3\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000\n*/\nclass Solution {\npublic int rob(int[] nums) {\nif (nums.length == 0) {\nreturn 0;\n}\nif (nums.length == 1) {\nreturn nums[0];\n}\nint max1 = robHelper(nums, 0, nums.length - 2);\nint max2 = robHelper(nums, 1, nums.length - 1);\nreturn Math.max(max1, max2);\n}\nint robHelper(int[] nums, int start, int end) {\nint one = 0;\nint two = 0;\nint maxAmount = 0;;\nfor (int i = start; i <= end; i++)\n{\nmaxAmount = Math.max(one+nums[i], two);\none = two;\ntwo = maxAmount;\n}\nreturn maxAmount;\n}\n}",
                        "max_stars_repo_path": "src/LC213-HouseRobberII.java",
                        "max_stars_repo_name": "RainbowDragon/LeetCode_Java",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```java\npublic int rob(int[] nums) {\nif (nums.length == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.length - 1; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.length; i++) {\nint temp = Math.max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn Math.max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 301
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are ",
                        "real_dup": 2
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_18411262",
                        "content": "package leetcode.problems.linkedin;\n/** 8. String to Integer (atoi)\n* Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer\n* (similar to C/C++'s atoi function).\n*\n* The algorithm for myAtoi(string s) is as follows:\n*   Read in and ignore any leading whitespace.\n*   Check if the next character (if not already at the end of the string) is '-' or '+'.\n*   Read this character in if it is either. This determines if the final result is negative or positive respectively.\n*   Assume the result is positive if neither is present.\n*  Read in next the characters until the next non-digit character or the end of the input is reached.\n*   The rest of the string is ignored.\n*  Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32).\n*   If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n*  If the integer is out of the 32-bit signed integer range [-231, 231 - 1],\n*   then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be\n*   clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n*  Return the integer as the final result.\n*\n* Note:\n*     Only the space character ' ' is considered a whitespace character.\n*     Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n* Example 1:\n* Input: s = \"42\"\n* Output: 42\n* Explanation: The underlined characters are what is read in, the caret is the current reader position.\n* Step 1: \"42\" (no characters read because there is no leading whitespace)\n*          ^\n* Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n*          ^\n* Step 3: \"42\" (\"42\" is read in)\n*            ^\n* The parsed integer is 42.\n* Since 42 is in the range [-231, 231 - 1], the final result is 42.\n*\n* Example 2:\n* Input: s = \"   -42\"\n* Output: -42\n* Explanation:\n* Step 1: \"   -42\" (leading whitespace is read and ignored)\n*             ^\n* Step 2: \"   -42\" ('-' is read, so the result should be negative)\n*              ^\n* Step 3: \"   -42\" (\"42\" is read in)\n*                ^\n* The parsed integer is -42.\n* Since -42 is in the range [-231, 231 - 1], the final result is -42.\n*\n* Example 3:\n* Input: s = \"4193 with words\"\n* Output: 4193\n* Explanation:\n* Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n*          ^\n* Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n*          ^\n* Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n*              ^\n* The parsed integer is 4193.\n* Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n*\n* Constraints:\n*     0 <= s.length <= 200\n*     s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.\n*/\npublic class _8StringToInteger_atoi {\npublic int myAtoi(String input) {\nint sign = 1;\nint result = 0;\nint index = 0;\nint n = input.length();\n// Discard all spaces from the beginning of the input string.\nwhile (index < n && input.charAt(index) == ' ') {\nindex++;\n}\n// sign = +1, if it's positive number, otherwise sign = -1.\nif (index < n && input.charAt(index) == '+') {\nsign = 1;\nindex++;\n} else if (index < n && input.charAt(index) == '-') {\nsign = -1;\nindex++;\n}\n// Traverse next digits of input and stop if it is not a digit\nwhile (index < n && Character.isDigit(input.charAt(index))) {\nint digit = input.charAt(index) - '0';\n// Check overflow and underflow conditions.\nif ((result > Integer.MAX_VALUE / 10) ||\n(result == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)) {\n// If integer overflowed return 2^31-1, otherwise if underflowed return -2^31.\nreturn sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n}\n// Append current digit to the result.\nresult = 10 * result + digit;\nindex++;\n}\n// We have formed a valid number without any overflow/underflow.\n// Return it after multiplying it with its sign.\nreturn sign * result;\n}\n}",
                        "max_stars_repo_path": "src/leetcode/problems/linkedin/_8StringToInteger_atoi.java",
                        "max_stars_repo_name": "alparslansari/algorithm",
                        "max_stars_count": 0,
                        "__cluster__": 214
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_8",
                        "content": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\nThe algorithm for `myAtoi(string s)` is as follows:\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n**Note:**\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n**Example 1:**\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"42 \" ( \"42 \" is read in)\n^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n**Example 2:**\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n**Example 3:**\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193.\n**Constraints:**\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.\nInput:\ns =  \"42 \"\nOutput:\n42\n```java\npublic int myAtoi(String s) {\nlong result = 0;\nint i = 0, sign = 1;\nwhile (i < s.length() && s.charAt(i) == ' ') i++;\nif (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\nsign = (s.charAt(i++) == '+') ? 1 : -1;\n}\nwhile (i < s.length() && Character.isDigit(s.charAt(i))) {\nresult = result * 10 + (s.charAt(i++) - '0');\nif (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\nif (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n}\nreturn (int) (result * sign);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 214
                },
                {
                        "shared string": " Read this character in if it is either. This determines if the final result is negative or positive respec"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_20015578",
                        "content": "package com.leetcode.strings.medium;\n// Implement the myAtoi(string s) function, which converts a string to a 32-bit\n// signed integer (similar to C/C++'s atoi function).\n//\n// The algorithm for myAtoi(string s) is as follows:\n//\n//\n// Read in and ignore any leading whitespace.\n// Check if the next character (if not already at the end of the string) is '-'\n// or '+'. Read this character in if it is either. This determines if the final\n// result is negative or positive respectively. Assume the result is positive if\n// neither is present.\n// Read in next the characters until the next non-digit character or the end of\n// the input is reached. The rest of the string is ignored.\n// Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If\n// no digits were read, then the integer is 0. Change the sign as necessary (from\n// step 2).\n// If the integer is out of the 32-bit signed integer range [-2\u00b3\u00b9, 2\u00b3\u00b9 - 1],\n// then clamp the integer so that it remains in the range. Specifically, integers\n// less than -2\u00b3\u00b9 should be clamped to -2\u00b3\u00b9, and integers greater than 2\u00b3\u00b9 - 1 should\n// be clamped to 2\u00b3\u00b9 - 1.\n// Return the integer as the final result.\n//\n//\n// Note:\n//\n//\n// Only the space character ' ' is considered a whitespace character.\n// Do not ignore any characters other than the leading whitespace or the rest\n// of the string after the digits.\n//\n//\n//\n// Example 1:\n//\n//\n// Input: s = \"42\"\n// Output: 42\n// Explanation: The underlined characters are what is read in, the caret is the\n// current reader position.\n// Step 1: \"42\" (no characters read because there is no leading whitespace)\n//         ^\n// Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n//         ^\n// Step 3: \"42\" (\"42\" is read in)\n//           ^\n// The parsed integer is 42.\n// Since 42 is in the range [-2\u00b3\u00b9, 2\u00b3\u00b9 - 1], the final result is 42.\n//\n//\n// Example 2:\n//\n//\n// Input: s = \"   -42\"\n// Output: -42\n// Explanation:\n// Step 1: \"   -42\" (leading whitespace is read and ignored)\n//            ^\n// Step 2: \"   -42\" ('-' is read, so the result should be negative)\n//             ^\n// Step 3: \"   -42\" (\"42\" is read in)\n//               ^\n// The parsed integer is -42.\n// Since -42 is in the range [-2\u00b3\u00b9, 2\u00b3\u00b9 - 1], the final result is -42.\n//\n//\n// Example 3:\n//\n//\n// Input: s = \"4193 with words\"\n// Output: 4193\n// Explanation:\n// Step 1: \"4193 with words\" (no characters read because there is no leading\n// whitespace)\n//         ^\n// Step 2: \"4193 with words\" (no characters read because there is neither a '-'\n// nor '+')\n//         ^\n// Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next\n// character is a non-digit)\n//             ^\n// The parsed integer is 4193.\n// Since 4193 is in the range [-2\u00b3\u00b9, 2\u00b3\u00b9 - 1], the final result is 4193.\n//\n//\n//\n// Constraints:\n//\n//\n// 0 <= s.length <= 200\n// s consists of English letters (lower-case and upper-case), digits (0-9), ' ',\n// '+', '-', and '.'.\n//\n// Related Topics String \ud83d\udc4d 1215 \ud83d\udc4e 3443\n/*\nO(n) Runtime: 4 ms, faster than 34.37% of Java online submissions for String to Integer (atoi).\nO(1) Memory Usage: 39.5 MB, less than 30.74% of Java online submissions for String to Integer (atoi).\n*/\n// leetcode submit region begin(Prohibit modification and deletion)\npublic class StringToInteger_8 {\nprivate enum State {\nINIT,\nDIGIT,\n}\npublic int myAtoi(String s) {\nint sign = 1;\nlong result = 0;\nState state = State.INIT;\nfor (int i = 0; i < s.length(); i++) {\nchar c = s.charAt(i);\nif (state == State.INIT) {\nif (!isSign(c) && !isWhiteSpace(c) && !Character.isDigit(c)) {\nbreak;\n}\nif (isSign(c)) {\nif (c == '-') {\nsign = -1;\n}\nstate = State.DIGIT;\n} else if (Character.isDigit(c)) {\nstate = State.DIGIT;\nresult = Character.getNumericValue(c);\n}\n} else {\nif (!Character.isDigit(c)) {\nbreak;\n}\nresult = result * 10 + Character.getNumericValue(c);\nif (result * sign < Integer.MIN_VALUE) {\nreturn Integer.MIN_VALUE;\n}\nif (result * sign > Integer.MAX_VALUE) {\nreturn Integer.MAX_VALUE;\n}\n}\n}\nreturn (int) result * sign;\n}\nprivate boolean isSign(char c) {\nreturn c == '+' || c == '-';\n}\nprivate boolean isWhiteSpace(char c) {\nreturn c == ' ';\n}\n}\n// leetcode submit region end(Prohibit modification and deletion)",
                        "max_stars_repo_path": "src/main/java/com/leetcode/strings/medium/StringToInteger_8.java",
                        "max_stars_repo_name": "Nalhin/Leetcode",
                        "max_stars_count": 0,
                        "__cluster__": 214
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_8",
                        "content": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\nThe algorithm for `myAtoi(string s)` is as follows:\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n**Note:**\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n**Example 1:**\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"42 \" ( \"42 \" is read in)\n^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n**Example 2:**\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n**Example 3:**\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193.\n**Constraints:**\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.\nInput:\ns =  \"42 \"\nOutput:\n42\n```java\npublic int myAtoi(String s) {\nlong result = 0;\nint i = 0, sign = 1;\nwhile (i < s.length() && s.charAt(i) == ' ') i++;\nif (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\nsign = (s.charAt(i++) == '+') ? 1 : -1;\n}\nwhile (i < s.length() && Character.isDigit(s.charAt(i))) {\nresult = result * 10 + (s.charAt(i++) - '0');\nif (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\nif (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n}\nreturn (int) (result * sign);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 214
                },
                {
                        "shared string": " Check if the next character (if not already at the end of the string) is "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_701",
                        "content": "You are given the `root` node of a binary search tree (BST) and a `value` to insert into the tree. Return _the root node of the BST after the insertion_. It is **guaranteed** that the new value does not exist in the original BST.\n**Notice** that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return **any of them**.\n**Example 1:**\n**Input:** root = \\[4,2,7,1,3\\], val = 5\n**Output:** \\[4,2,7,1,3,5\\]\n**Explanation:** Another accepted tree is:\n**Example 2:**\n**Input:** root = \\[40,20,60,10,30,50,70\\], val = 25\n**Output:** \\[40,20,60,10,30,50,70,null,null,25\\]\n**Example 3:**\n**Input:** root = \\[4,2,7,1,3,null,null,null,null,null,null\\], val = 5\n**Output:** \\[4,2,7,1,3,5\\]\n**Constraints:**\n*   The number of nodes in the tree will be in the range `[0, 104]`.\n*   `-108 <= Node.val <= 108`\n*   All the values `Node.val` are **unique**.\n*   `-108 <= val <= 108`\n*   It's **guaranteed** that `val` does not exist in the original BST.\nInput:\nroot = \\[4,2,7,1,3\\], val = 5\nOutput:\n\\[4,2,7,1,3,5\\]\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode() {}\nTreeNode(int val) { this.val = val; }\nTreeNode(int val, TreeNode left, TreeNode right) {\nthis.val = val;\nthis.left = left;\nthis.right = right;\n}\n}\npublic TreeNode insertIntoBST(TreeNode root, int val) {\nif (root == null) {\nreturn new TreeNode(val);\n}\nif (val < root.val) {\nroot.left = insertIntoBST(root.left, val);\n} else {\nroot.right = insertIntoBST(root.right, val);\n}\nreturn root;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 413
                },
                {
                        "id": "pretrain_java_data_4090762",
                        "content": "<gh_stars>0\npackage leetcode.problems.linkedin;\nimport leetcode.models.TreeNode;\n/**\n* 701. Insert into a Binary Search Tree\n* You are given the root node of a binary search tree (BST) and a value to insert into the tree.\n* Return the root node of the BST after the insertion.\n* It is guaranteed that the new value does not exist in the original BST.\n* <p>\n* Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion.\n* You can return any of them.\n* <p>\n* Example 1:\n* Input: root = [4,2,7,1,3], val = 5\n* Output: [4,2,7,1,3,5]\n* Explanation: Another accepted tree is:\n* <p>\n* Example 2:\n* Input: root = [40,20,60,10,30,50,70], val = 25\n* Output: [40,20,60,10,30,50,70,null,null,25]\n* <p>\n* Example 3:\n* Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n* Output: [4,2,7,1,3,5]\n* <p>\n* Constraints:\n* The number of nodes in the tree will be in the range [0, 104].\n* -108 <= Node.val <= 108\n* All the values Node.val are unique.\n* -108 <= val <= 108\n* It's guaranteed that val does not exist in the original BST.\n*/\npublic class _701InsertIntoABinarySearchTree {\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n* int val;\n* TreeNode left;\n* TreeNode right;\n* TreeNode() {}\n* TreeNode(int val) { this.val = val; }\n* TreeNode(int val, TreeNode left, TreeNode right) {\n* this.val = val;\n* this.left = left;\n* this.right = right;\n* }\n* }\n*/\npublic TreeNode insertIntoBST(TreeNode root, int val) {\nif (root == null) return new TreeNode(val);\n// insert into the right subtree\nif (val > root.val) root.right = insertIntoBST(root.right, val);\n// insert into the left subtree\nelse root.left = insertIntoBST(root.left, val);\nreturn root;\n}\n}",
                        "max_stars_repo_path": "src/leetcode/problems/linkedin/_701InsertIntoABinarySearchTree.java",
                        "max_stars_repo_name": "alparslansari/algorithm",
                        "max_stars_count": 0,
                        "__cluster__": 413
                },
                {
                        "shared string": " that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```java\npublic class ListNode {\nint val;\nListNode next;\nListNode(int x) { val = x; }\n}\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nListNode dummy = new ListNode(0);\nListNode current = dummy;\nint carry = 0;\nwhile (l1 != null || l2 != null || carry != 0) {\nint sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;\ncarry = sum / 10;\ncurrent.next = new ListNode(sum % 10);\ncurrent = current.next;\nif (l1 != null) l1 = l1.next;\nif (l2 != null) l2 = l2.next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 211
                },
                {
                        "id": "pretrain_java_data_7234181",
                        "content": "package LeetCode.Medium.AddTwoNumbers;\n/*\n2. Add Two Numbers\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n*/\n// * Definition for singly-linked list.\nclass ListNode {\nint val;\nListNode next;\nListNode() {}\nListNode(int val) {\nthis.val = val;\n}\nListNode(int val, ListNode next) {\nthis.val = val;\nthis.next = next;\n}\n}\npublic class Solution {\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nif (l1 == null && l2 == null) return null;\nif (l1 == null || l2 == null) return l1 == null ? l2 : l1;\nListNode head = new ListNode(-1);\nListNode l3 = head;\nint carry = 0;\nwhile (l1 != null || l2 != null) {\nint firstVal = l1 != null ? l1.val : 0;\nint secondVal = l2 != null ? l2.val : 0;\nint res = firstVal + secondVal + carry;\nl3.next = new ListNode(res % 10);\ncarry = res / 10;\nl1 = l1 != null ? l1.next : null;\nl2 = l2 != null ? l2.next : null;\nl3 = l3.next;\n}\nif (carry != 0) l3.next = new ListNode(carry);\nreturn head.next;\n}\npublic static void main(String[] args) {\nSolution solution = new Solution();\nListNode l1 = new ListNode(9);\nl1.next = new ListNode(9);\nListNode l2 = new ListNode(9);\nl2.next = new ListNode(9);\nl2.next.next = new ListNode(9);\nl2.next.next.next = new ListNode(9);\nl2.next.next.next.next = new ListNode(9);\nListNode res = solution.addTwoNumbers(l1, l2);\n// should be 8 9 0 0 0 1\nwhile (res != null) {\nSystem.out.print(res.val + \" \");\nres = res.next;\n}\n}\n}",
                        "max_stars_repo_path": "LeetCode/Medium/AddTwoNumbers/Solution.java",
                        "max_stars_repo_name": "ArfatSalman/data-structures-and-algorithms",
                        "max_stars_count": 160,
                        "__cluster__": 211
                },
                {
                        "shared string": ", and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_637",
                        "content": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n**Example 2:**\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n\\[3.00000,14.50000,11.00000\\]\n```java\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\npublic List<Double> averageOfLevels(TreeNode root) {\nList<Double> result = new ArrayList<>();\nQueue<TreeNode> queue = new LinkedList<>();\nqueue.add(root);\nwhile (!queue.isEmpty()) {\nlong sum = 0;\nint count = 0;\nQueue<TreeNode> temp = new LinkedList<>();\nwhile (!queue.isEmpty()) {\nTreeNode currentNode = queue.poll();\nsum += currentNode.val;\ncount++;\nif (currentNode.left != null) temp.add(currentNode.left);\nif (currentNode.right != null) temp.add(currentNode.right);\n}\nqueue = temp;\nresult.add((1.0 * sum) / count);\n}\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 28
                },
                {
                        "id": "pretrain_java_data_8940389",
                        "content": "package org.pilgrim.leetcode.y2021;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport org.pilgrim.leetcode.y2020.facebook.MaxPathSumBinarryTree.TreeNode;\n/*Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\nExample 2:\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\npublic class AverageLevelsBinaryTree {\npublic List<Double> averageOfLevels(TreeNode root) {\nif(root == null){\nreturn null;\n}\nlong sum = 0;\ndouble n = 0;\nQueue<TreeNode> q = new LinkedList<>();\nq.add(root);\nList<Double> list = new ArrayList<>();\nwhile(!q.isEmpty()){\nint c = q.size();\nn = c;\nwhile(c-- > 0){\nTreeNode node = q.poll();\nsum += node.val;\nif(node.left != null){\nq.add(node.left);\n}\nif(node.right != null){\nq.add(node.right);\n}\n}\nlist.add(sum/n);\nsum = 0;\n}\nreturn list;\n}\n}",
                        "max_stars_repo_path": "src/main/java/org/pilgrim/leetcode/y2021/AverageLevelsBinaryTree.java",
                        "max_stars_repo_name": "sergeyltd/pilgrim-base",
                        "max_stars_count": 1,
                        "__cluster__": 28
                },
                {
                        "shared string": "the average value of the nodes on each level in the form of an array"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_637",
                        "content": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n**Example 2:**\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n\\[3.00000,14.50000,11.00000\\]\n```java\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\npublic List<Double> averageOfLevels(TreeNode root) {\nList<Double> result = new ArrayList<>();\nQueue<TreeNode> queue = new LinkedList<>();\nqueue.add(root);\nwhile (!queue.isEmpty()) {\nlong sum = 0;\nint count = 0;\nQueue<TreeNode> temp = new LinkedList<>();\nwhile (!queue.isEmpty()) {\nTreeNode currentNode = queue.poll();\nsum += currentNode.val;\ncount++;\nif (currentNode.left != null) temp.add(currentNode.left);\nif (currentNode.right != null) temp.add(currentNode.right);\n}\nqueue = temp;\nresult.add((1.0 * sum) / count);\n}\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 28
                },
                {
                        "id": "pretrain_java_data_8940389",
                        "content": "package org.pilgrim.leetcode.y2021;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport org.pilgrim.leetcode.y2020.facebook.MaxPathSumBinarryTree.TreeNode;\n/*Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\nExample 2:\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\npublic class AverageLevelsBinaryTree {\npublic List<Double> averageOfLevels(TreeNode root) {\nif(root == null){\nreturn null;\n}\nlong sum = 0;\ndouble n = 0;\nQueue<TreeNode> q = new LinkedList<>();\nq.add(root);\nList<Double> list = new ArrayList<>();\nwhile(!q.isEmpty()){\nint c = q.size();\nn = c;\nwhile(c-- > 0){\nTreeNode node = q.poll();\nsum += node.val;\nif(node.left != null){\nq.add(node.left);\n}\nif(node.right != null){\nq.add(node.right);\n}\n}\nlist.add(sum/n);\nsum = 0;\n}\nreturn list;\n}\n}",
                        "max_stars_repo_path": "src/main/java/org/pilgrim/leetcode/y2021/AverageLevelsBinaryTree.java",
                        "max_stars_repo_name": "sergeyltd/pilgrim-base",
                        "max_stars_count": 1,
                        "__cluster__": 28
                },
                {
                        "shared string": "the average value of the nodes on each level in the form of an array"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_637",
                        "content": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n**Example 2:**\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n\\[3.00000,14.50000,11.00000\\]\n```java\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\npublic List<Double> averageOfLevels(TreeNode root) {\nList<Double> result = new ArrayList<>();\nQueue<TreeNode> queue = new LinkedList<>();\nqueue.add(root);\nwhile (!queue.isEmpty()) {\nlong sum = 0;\nint count = 0;\nQueue<TreeNode> temp = new LinkedList<>();\nwhile (!queue.isEmpty()) {\nTreeNode currentNode = queue.poll();\nsum += currentNode.val;\ncount++;\nif (currentNode.left != null) temp.add(currentNode.left);\nif (currentNode.right != null) temp.add(currentNode.right);\n}\nqueue = temp;\nresult.add((1.0 * sum) / count);\n}\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 28
                },
                {
                        "id": "pretrain_java_data_8940389",
                        "content": "package org.pilgrim.leetcode.y2021;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport org.pilgrim.leetcode.y2020.facebook.MaxPathSumBinarryTree.TreeNode;\n/*Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\nExample 2:\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\npublic class AverageLevelsBinaryTree {\npublic List<Double> averageOfLevels(TreeNode root) {\nif(root == null){\nreturn null;\n}\nlong sum = 0;\ndouble n = 0;\nQueue<TreeNode> q = new LinkedList<>();\nq.add(root);\nList<Double> list = new ArrayList<>();\nwhile(!q.isEmpty()){\nint c = q.size();\nn = c;\nwhile(c-- > 0){\nTreeNode node = q.poll();\nsum += node.val;\nif(node.left != null){\nq.add(node.left);\n}\nif(node.right != null){\nq.add(node.right);\n}\n}\nlist.add(sum/n);\nsum = 0;\n}\nreturn list;\n}\n}",
                        "max_stars_repo_path": "src/main/java/org/pilgrim/leetcode/y2021/AverageLevelsBinaryTree.java",
                        "max_stars_repo_name": "sergeyltd/pilgrim-base",
                        "max_stars_count": 1,
                        "__cluster__": 28
                },
                {
                        "shared string": "the average value of the nodes on each level in the form of an array"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_637",
                        "content": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n**Example 2:**\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n\\[3.00000,14.50000,11.00000\\]\n```java\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\npublic List<Double> averageOfLevels(TreeNode root) {\nList<Double> result = new ArrayList<>();\nQueue<TreeNode> queue = new LinkedList<>();\nqueue.add(root);\nwhile (!queue.isEmpty()) {\nlong sum = 0;\nint count = 0;\nQueue<TreeNode> temp = new LinkedList<>();\nwhile (!queue.isEmpty()) {\nTreeNode currentNode = queue.poll();\nsum += currentNode.val;\ncount++;\nif (currentNode.left != null) temp.add(currentNode.left);\nif (currentNode.right != null) temp.add(currentNode.right);\n}\nqueue = temp;\nresult.add((1.0 * sum) / count);\n}\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 28
                },
                {
                        "id": "pretrain_java_data_8940389",
                        "content": "package org.pilgrim.leetcode.y2021;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport org.pilgrim.leetcode.y2020.facebook.MaxPathSumBinarryTree.TreeNode;\n/*Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\nExample 2:\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\npublic class AverageLevelsBinaryTree {\npublic List<Double> averageOfLevels(TreeNode root) {\nif(root == null){\nreturn null;\n}\nlong sum = 0;\ndouble n = 0;\nQueue<TreeNode> q = new LinkedList<>();\nq.add(root);\nList<Double> list = new ArrayList<>();\nwhile(!q.isEmpty()){\nint c = q.size();\nn = c;\nwhile(c-- > 0){\nTreeNode node = q.poll();\nsum += node.val;\nif(node.left != null){\nq.add(node.left);\n}\nif(node.right != null){\nq.add(node.right);\n}\n}\nlist.add(sum/n);\nsum = 0;\n}\nreturn list;\n}\n}",
                        "max_stars_repo_path": "src/main/java/org/pilgrim/leetcode/y2021/AverageLevelsBinaryTree.java",
                        "max_stars_repo_name": "sergeyltd/pilgrim-base",
                        "max_stars_count": 1,
                        "__cluster__": 28
                },
                {
                        "shared string": "the average value of the nodes on each level in the form of an array"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_12121842",
                        "content": "/*LC111: Minimum Depth of Binary Tree\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along\nthe shortest path from the root node down to\nthe nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000*/\nclass Sln{\npublic int minDepth(TreeNode root){\nif (root == null)\treturn 0;\nif (root.left == null)\treturn minDepth(root.right) + 1;\nif (root.right == null) return minDepth(root.left) + 1;\nreturn Math.min(minDepth(root.left),minDepth(root.right)) + 1;\n}\n}",
                        "max_stars_repo_path": "src/Interview_exp/contests/monthly/oct/w4/MinDepthBtree.java",
                        "max_stars_repo_name": "cool-dude/leetcode",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_10589393",
                        "content": "package org.enricogiurin.codingchallenges.leetcode.easy;\nimport org.enricogiurin.codingchallenges.leetcode.util.TreeNode;\n/*\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000\nAccepted\n663,327\nSubmissions\n1,597,347\n*/\npublic class MinimumDepthOfBinaryTree {\nprivate int min = Integer.MAX_VALUE;\npublic int minDepth(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\ndfs(root, 1);\nreturn min;\n}\nprivate void dfs(TreeNode root, int depth) {\nif (root == null || depth >= min) {\nreturn;\n}\nif (root.left == null && root.right == null) {\nthis.min = Math.min(min, depth);\nreturn;\n}\ndfs(root.left, depth + 1);\ndfs(root.right, depth + 1);\n}\n}",
                        "max_stars_repo_path": "src/main/java/org/enricogiurin/codingchallenges/leetcode/easy/MinimumDepthOfBinaryTree.java",
                        "max_stars_repo_name": "egch/coding-challenges",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_12121842",
                        "content": "/*LC111: Minimum Depth of Binary Tree\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along\nthe shortest path from the root node down to\nthe nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000*/\nclass Sln{\npublic int minDepth(TreeNode root){\nif (root == null)\treturn 0;\nif (root.left == null)\treturn minDepth(root.right) + 1;\nif (root.right == null) return minDepth(root.left) + 1;\nreturn Math.min(minDepth(root.left),minDepth(root.right)) + 1;\n}\n}",
                        "max_stars_repo_path": "src/Interview_exp/contests/monthly/oct/w4/MinDepthBtree.java",
                        "max_stars_repo_name": "cool-dude/leetcode",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_10589393",
                        "content": "package org.enricogiurin.codingchallenges.leetcode.easy;\nimport org.enricogiurin.codingchallenges.leetcode.util.TreeNode;\n/*\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000\nAccepted\n663,327\nSubmissions\n1,597,347\n*/\npublic class MinimumDepthOfBinaryTree {\nprivate int min = Integer.MAX_VALUE;\npublic int minDepth(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\ndfs(root, 1);\nreturn min;\n}\nprivate void dfs(TreeNode root, int depth) {\nif (root == null || depth >= min) {\nreturn;\n}\nif (root.left == null && root.right == null) {\nthis.min = Math.min(min, depth);\nreturn;\n}\ndfs(root.left, depth + 1);\ndfs(root.right, depth + 1);\n}\n}",
                        "max_stars_repo_path": "src/main/java/org/enricogiurin/codingchallenges/leetcode/easy/MinimumDepthOfBinaryTree.java",
                        "max_stars_repo_name": "egch/coding-challenges",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_12121842",
                        "content": "/*LC111: Minimum Depth of Binary Tree\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along\nthe shortest path from the root node down to\nthe nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000*/\nclass Sln{\npublic int minDepth(TreeNode root){\nif (root == null)\treturn 0;\nif (root.left == null)\treturn minDepth(root.right) + 1;\nif (root.right == null) return minDepth(root.left) + 1;\nreturn Math.min(minDepth(root.left),minDepth(root.right)) + 1;\n}\n}",
                        "max_stars_repo_path": "src/Interview_exp/contests/monthly/oct/w4/MinDepthBtree.java",
                        "max_stars_repo_name": "cool-dude/leetcode",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```java\npublic int minDepth(TreeNode root) {\nif (root == null) return 0;\nint left = minDepth(root.left);\nint right = minDepth(root.right);\nreturn (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "id": "pretrain_java_data_10589393",
                        "content": "package org.enricogiurin.codingchallenges.leetcode.easy;\nimport org.enricogiurin.codingchallenges.leetcode.util.TreeNode;\n/*\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000\nAccepted\n663,327\nSubmissions\n1,597,347\n*/\npublic class MinimumDepthOfBinaryTree {\nprivate int min = Integer.MAX_VALUE;\npublic int minDepth(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\ndfs(root, 1);\nreturn min;\n}\nprivate void dfs(TreeNode root, int depth) {\nif (root == null || depth >= min) {\nreturn;\n}\nif (root.left == null && root.right == null) {\nthis.min = Math.min(min, depth);\nreturn;\n}\ndfs(root.left, depth + 1);\ndfs(root.right, depth + 1);\n}\n}",
                        "max_stars_repo_path": "src/main/java/org/enricogiurin/codingchallenges/leetcode/easy/MinimumDepthOfBinaryTree.java",
                        "max_stars_repo_name": "egch/coding-challenges",
                        "max_stars_count": 0,
                        "__cluster__": 45
                },
                {
                        "shared string": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```java\npublic class ListNode {\nint val;\nListNode next;\nListNode(int x) { val = x; }\n}\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nListNode dummy = new ListNode(0);\nListNode current = dummy;\nint carry = 0;\nwhile (l1 != null || l2 != null || carry != 0) {\nint sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;\ncarry = sum / 10;\ncurrent.next = new ListNode(sum % 10);\ncurrent = current.next;\nif (l1 != null) l1 = l1.next;\nif (l2 != null) l2 = l2.next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 211
                },
                {
                        "id": "pretrain_java_data_12118321",
                        "content": "<gh_stars>0\n/*\n* You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse\n* order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n* You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n*\n* Example 1:\n* Input: l1 = [2,4,3], l2 = [5,6,4]\n* Output: [7,0,8]\n* Explanation: 342 + 465 = 807.\n*\n* Constraints:\n* The number of nodes in each linked list is in the range [1, 100].\n* 0 <= Node.val <= 9\n* It is guaranteed that the list represents a number that does not have leading zeros.*/\npackage org.phoenix.leetcode.challenges;\npublic class Problem12_AddTwoNumbers {\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nListNode temp = new ListNode(0);\nListNode p = l1, q = l2, curr = temp;\nint carry = 0;\nwhile (p != null || q != null) {\nint x = (p != null) ? p.val : 0;\nint y = (q != null) ? q.val : 0;\nint sum = carry + x + y;\ncarry = sum / 10;\ncurr.next = new ListNode(sum % 10);\ncurr = curr.next;\nif (p != null) p = p.next;\nif (q != null) q = q.next;\n}\nif (carry > 0) {\ncurr.next = new ListNode(carry);\n}\nreturn temp.next;\n}\n}",
                        "max_stars_repo_path": "january-2021-leetcode-challenge/src/main/java/org/phoenix/leetcode/challenges/Problem12_AddTwoNumbers.java",
                        "max_stars_repo_name": "vibhorsingh11/LeetCode",
                        "max_stars_count": 0,
                        "__cluster__": 211
                },
                {
                        "shared string": ", and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_118",
                        "content": "Given an integer `numRows`, return the first numRows of **Pascal's triangle**.\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n**Example 1:**\n**Input:** numRows = 5\n**Output:** \\[\\[1\\],\\[1,1\\],\\[1,2,1\\],\\[1,3,3,1\\],\\[1,4,6,4,1\\]\\]\n**Example 2:**\n**Input:** numRows = 1\n**Output:** \\[\\[1\\]\\]\n**Constraints:**\n*   `1 <= numRows <= 30`\nInput:\nnumRows = 5\nOutput:\n\\[\\[1\\],\\[1,1\\],\\[1,2,1\\],\\[1,3,3,1\\],\\[1,4,6,4,1\\]\\]\n```java\npublic List<List<Integer>> generate(int numRows) {\nList<List<Integer>> pascalsTriangle = new ArrayList<>();\nfor (int i = 0; i < numRows; i++) {\nList<Integer> row = new ArrayList<>();\nrow.add(1);\nfor (int j = 1; j < i; j++) {\nrow.add(pascalsTriangle.get(i - 1).get(j - 1) + pascalsTriangle.get(i - 1).get(j));\n}\nif (i > 0) row.add(1);\npascalsTriangle.add(row);\n}\nreturn pascalsTriangle;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 266
                },
                {
                        "id": "pretrain_java_data_12169045",
                        "content": "// Given an integer numRows, return the first numRows of Pascal's triangle.\n// In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n// Example 1:\n// Input: numRows = 5\n// Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n// Example 2:\n// Input: numRows = 1\n// Output: [[1]]\n// Constraints:\n// 1 <= numRows <= 30\nclass Solution {\npublic List<List<Integer>> generate(int numRows) {\nList<List<Integer>> ans = new ArrayList<>();\nfor(int i = 0; i < numRows; i++){\nList<Integer> row = new ArrayList<>();\nfor(int j = 0; j <= i; j++){\nif(j == 0 || j == i)\nrow.add(1);\nelse\nrow.add(ans.get(i-1).get(j-1) + ans.get(i-1).get(j));\n}\nans.add(row);\n}\nreturn ans;\n}\n}",
                        "max_stars_repo_path": "Dynamic Programming/Pascals-Triangle-118.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 266
                },
                {
                        "shared string": ", each number is the sum of the two numbers directly above it as shown: "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_463",
                        "content": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n**Example 1:**\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n**Example 2:**\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n**Example 3:**\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4\n**Constraints:**\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.\nInput:\ngrid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\nOutput:\n16\n```java\npublic int islandPerimeter(int[][] grid) {\nint perimeter = 0;\nfor (int row = 0; row < grid.length; row++) {\nfor (int col = 0; col < grid[row].length; col++) {\nif (grid[row][col] == 1) {\nperimeter += 4;\nif (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\nif (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n}\n}\n}\nreturn perimeter;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 379
                },
                {
                        "id": "pretrain_java_data_13615150",
                        "content": "/*\nLC463. Island Perimeter\nYou are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\nExample 1:\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16\nExplanation: The perimeter is the 16 yellow stripes in the image above.\nExample 2:\nInput: grid = [[1]]\nOutput: 4\nExample 3:\nInput: grid = [[1,0]]\nOutput: 4\nConstraints:\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 100\ngrid[i][j] is 0 or 1.\nThere is exactly one island in grid.\n*/\nclass Solution {\npublic int islandPerimeter(int[][] grid) {\nif (grid == null || grid.length == 0) {\nreturn 0;\n}\nint nr = grid.length;\nint nc = grid[0].length;\nresult = 0;\nfor (int i = 0; i < nr; i++)\nfor (int j = 0; j < nc; j++)\n{\nif (grid[i][j] == 1) {\ndfs(grid, i, j, nr, nc);\nbreak;\n}\n}\nreturn result;\n}\nstatic int result;\nvoid dfs(int[][] grid, int i, int j, int nr, int nc) {\nif (i < 0 || i >= nr || j < 0 || j >= nc || grid[i][j] != 1) {\nreturn;\n}\ngrid[i][j] = 2;\nif (i == 0 || grid[i-1][j] == 0) {\nresult++;\n}\nif (i == nr - 1 || grid[i+1][j] == 0) {\nresult++;\n}\nif (j == 0 || grid[i][j-1] == 0) {\nresult++;\n}\nif (j == nc - 1 || grid[i][j+1] == 0) {\nresult++;\n}\ndfs(grid, i-1, j, nr, nc);\ndfs(grid, i+1, j, nr, nc);\ndfs(grid, i, j-1, nr, nc);\ndfs(grid, i, j+1, nr, nc);\n}\n}",
                        "max_stars_repo_path": "src/LC463-IslandPerimeter.java",
                        "max_stars_repo_name": "RainbowDragon/LeetCode_Java",
                        "max_stars_count": 0,
                        "__cluster__": 379
                },
                {
                        "shared string": " is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have \"lakes"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_463",
                        "content": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n**Example 1:**\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n**Example 2:**\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n**Example 3:**\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4\n**Constraints:**\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.\nInput:\ngrid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\nOutput:\n16\n```java\npublic int islandPerimeter(int[][] grid) {\nint perimeter = 0;\nfor (int row = 0; row < grid.length; row++) {\nfor (int col = 0; col < grid[row].length; col++) {\nif (grid[row][col] == 1) {\nperimeter += 4;\nif (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\nif (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n}\n}\n}\nreturn perimeter;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 379
                },
                {
                        "id": "pretrain_java_data_13615150",
                        "content": "/*\nLC463. Island Perimeter\nYou are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\nExample 1:\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16\nExplanation: The perimeter is the 16 yellow stripes in the image above.\nExample 2:\nInput: grid = [[1]]\nOutput: 4\nExample 3:\nInput: grid = [[1,0]]\nOutput: 4\nConstraints:\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 100\ngrid[i][j] is 0 or 1.\nThere is exactly one island in grid.\n*/\nclass Solution {\npublic int islandPerimeter(int[][] grid) {\nif (grid == null || grid.length == 0) {\nreturn 0;\n}\nint nr = grid.length;\nint nc = grid[0].length;\nresult = 0;\nfor (int i = 0; i < nr; i++)\nfor (int j = 0; j < nc; j++)\n{\nif (grid[i][j] == 1) {\ndfs(grid, i, j, nr, nc);\nbreak;\n}\n}\nreturn result;\n}\nstatic int result;\nvoid dfs(int[][] grid, int i, int j, int nr, int nc) {\nif (i < 0 || i >= nr || j < 0 || j >= nc || grid[i][j] != 1) {\nreturn;\n}\ngrid[i][j] = 2;\nif (i == 0 || grid[i-1][j] == 0) {\nresult++;\n}\nif (i == nr - 1 || grid[i+1][j] == 0) {\nresult++;\n}\nif (j == 0 || grid[i][j-1] == 0) {\nresult++;\n}\nif (j == nc - 1 || grid[i][j+1] == 0) {\nresult++;\n}\ndfs(grid, i-1, j, nr, nc);\ndfs(grid, i+1, j, nr, nc);\ndfs(grid, i, j-1, nr, nc);\ndfs(grid, i, j+1, nr, nc);\n}\n}",
                        "max_stars_repo_path": "src/LC463-IslandPerimeter.java",
                        "max_stars_repo_name": "RainbowDragon/LeetCode_Java",
                        "max_stars_count": 0,
                        "__cluster__": 379
                },
                {
                        "shared string": " is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have \"lakes"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_309",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n*   After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n**Example 1:**\n**Input:** prices = \\[1,2,3,0,2\\]\n**Output:** 3\n**Explanation:** transactions = \\[buy, sell, cooldown, buy, sell\\]\n**Example 2:**\n**Input:** prices = \\[1\\]\n**Output:** 0\n**Constraints:**\n*   `1 <= prices.length <= 5000`\n*   `0 <= prices[i] <= 1000`\nInput:\nprices = \\[1,2,3,0,2\\]\nOutput:\n3\n```java\npublic int maxProfit(int[] prices) {\nint profit = 0;\nfor (int i = 1; i < prices.length; i++) {\nprofit += Math.max(prices[i] - prices[i - 1], 0);\n}\nreturn profit;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 339
                },
                {
                        "id": "pretrain_java_data_13726677",
                        "content": "<gh_stars>1-10\n/*\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\nAfter you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [1,2,3,0,2]\nOutput: 3\nExplanation: transactions = [buy, sell, cooldown, buy, sell]\nExample 2:\nInput: prices = [1]\nOutput: 0\nConstraints:\n1 <= prices.length <= 5000\n0 <= prices[i] <= 1000\n*/\nclass Solution {\npublic int maxProfit(int[] prices) {\nint obsp = -prices[0];\nint ossp = 0;\nint ocsp = 0;\nfor(int i=1; i<prices.length; i++) {\nint nbsp = 0;\nint nssp = 0;\nint ncsp = 0;\nif(ocsp - prices[i] > obsp) {\nnbsp = ocsp - prices[i];\n} else {\nnbsp = obsp;\n}\nif(obsp + prices[i] > ossp) {\nnssp = obsp + prices[i];\n} else {\nnssp = ossp;\n}\nif(ossp > ocsp) {\nncsp = ossp;\n} else {\nncsp = ocsp;\n}\nobsp = nbsp;\nossp = nssp;\nocsp = ncsp;\n}\nreturn ossp;\n}\n}",
                        "max_stars_repo_path": "LC_309_best_time_to_buy_and_sell_stock_with_cooldown.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 339
                },
                {
                        "shared string": " day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions: "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_17087238",
                        "content": "package string;\n/**\n* 657. Robot Return to Origin\n* <p>\n* There is a robot starting at position (0, 0), the origin, on a 2D plane.\n* Given a sequence of its moves, judge if this robot ends up at (0, 0) after\n* it completes its moves.\n* <p>\n* The move sequence is represented by a string, and the character moves[i]\n* represents its ith move. Valid moves are R (right), L (left), U (up), and D (down).\n* If the robot returns to the origin after it finishes all of its moves, return true.\n* Otherwise, return false.\n* <p>\n* Note: The way that the robot is \"facing\" is irrelevant. \"R\" will always make the robot\n* move to the right once, \"L\" will always make it move left, etc. Also, assume that\n* the magnitude of the robot's movement is the same for each move.\n* <p>\n* Example 1:\n* <p>\n* Input: \"UD\"\n* Output: true\n* Explanation: The robot moves up once, and then down once. All moves have the same magnitude,\n* so it ended up at the origin where it started. Therefore, we return true.\n* <p>\n* <p>\n* Example 2:\n* <p>\n* Input: \"LL\"\n* Output: false\n* Explanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin.\n* We return false because it is not at the origin at the end of its moves.\n* <p>\n* Created by zjm on 2019/8/16 21:06\n*/\npublic class RobotReturnToOrigin {\n//\u8bbe4\u4e2a\u53d8\u91cf\u5206\u522b\u4ee3\u8868\u56db\u4e2a\u65b9\u5411\uff0c\u6700\u540e\u5982\u679c\u5de6\u53f3\uff0c\u4e0a\u4e0b\u4e24\u4e24\u76f8\u7b49\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\npublic boolean judgeCircle(String moves) {\nint r = 0, l = 0, u = 0, d = 0;\nfor(char c : moves.toCharArray()) {\nif(c == 'R') {\nr++;\n}else if(c == 'L') {\nl++;\n}else if(c == 'U') {\nu++;\n}else if(c == 'D') {\nd++;\n}\n}\nreturn r == l && u == d;\n}\n}",
                        "max_stars_repo_path": "club.isparkle.leetcode/string/RobotReturnToOrigin.java",
                        "max_stars_repo_name": "zjm3007210057/leetcode",
                        "max_stars_count": 0,
                        "__cluster__": 404
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_657",
                        "content": "There is a robot starting at the position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot **ends up at** `(0, 0)` after it completes its moves.\nYou are given a string `moves` that represents the move sequence of the robot where `moves[i]` represents its `ith` move. Valid moves are `'R'` (right), `'L'` (left), `'U'` (up), and `'D'` (down).\nReturn `true` _if the robot returns to the origin after it finishes all of its moves, or_ `false` _otherwise_.\n**Note**: The way that the robot is \"facing \" is irrelevant. `'R'` will always make the robot move to the right once, `'L'` will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n**Example 1:**\n**Input:** moves =  \"UD \"\n**Output:** true\n**Explanation**: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n**Example 2:**\n**Input:** moves =  \"LL \"\n**Output:** false\n**Explanation**: The robot moves left twice. It ends up two  \"moves \" to the left of the origin. We return false because it is not at the origin at the end of its moves.\n**Constraints:**\n*   `1 <= moves.length <= 2 * 104`\n*   `moves` only contains the characters `'U'`, `'D'`, `'L'` and `'R'`.\nInput:\nmoves =  \"UD \"\nOutput:\ntrue\n```java\npublic boolean judgeCircle(String moves) {\nint x = 0, y = 0;\nfor(char move : moves.toCharArray()) {\nif(move == 'U') y++;\nelse if(move == 'D') y--;\nelse if(move == 'R') x++;\nelse if(move == 'L') x--;\n}\nreturn x == 0 && y == 0;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 404
                },
                {
                        "shared string": "f the robot returns to the origin after it finishes all of its moves, "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_18708250",
                        "content": "<reponame>cool-dude/leetcode\n/*\nLC64: Minimum Path Sum\nhttps://leetcode.com/problems/minimum-path-sum/\nGiven a m x n grid filled with non-negative numbers,\nfind a path from top left to bottom right\nwhich minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample:\nInput:\n[\n[1,3,1],\n[1,5,1],\n[4,2,1]\n]\nOutput: 7\nExplanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n*/\nclass Sln {\npublic int minPathSum(int[][] grid) {\nint m=grid.length,n=grid[0].length;\nfor(int i=m-1;i>=0;i--){\nfor(int j=n-1;j>=0;j--){\nif(i==m-1 && j!=n-1){\ngrid[i][j]+=grid[i][j+1];\n}\nelse if(i!=m-1 && j==n-1){\ngrid[i][j]+=grid[i+1][j];\n}\nelse if(i!=m-1 && j!=n-1){\ngrid[i][j]+=Math.min(grid[i+1][j],grid[i][j+1]);\n}\n}\n}\nreturn grid[0][0];\n}\n}",
                        "max_stars_repo_path": "src/Interview_exp/contests/monthly/apr/w3/MatrixMinPathSum.java",
                        "max_stars_repo_name": "cool-dude/leetcode",
                        "max_stars_count": 0,
                        "__cluster__": 251
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```java\npublic int minPathSum(int[][] grid) {\nint m = grid.length, n = grid[0].length;\nfor(int i = 1; i < m; i++)\ngrid[i][0] += grid[i - 1][0];\nfor(int i = 1; i < n; i++)\ngrid[0][i] += grid[0][i - 1];\nfor(int i = 1; i < m; i++){\nfor(int j = 1; j < n; j++){\ngrid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n}\n}\nreturn grid[m - 1][n - 1];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 251
                },
                {
                        "shared string": " filled with non-negative numbers, find a path from top left to bottom right"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_18627018",
                        "content": "<reponame>devangi2000/Data-Structures-Algorithms-Handbook\n// Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a\n// space-separated sequence of one or more dictionary words.\n// Note that the same word in the dictionary may be reused multiple times in the segmentation.\n// Example 1:\n// Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n// Output: true\n// Explanation: Return true because \"leetcode\" can be segmented as \"leet code\".\n// Example 2:\n// Input: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\n// Output: true\n// Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\n// Note that you are allowed to reuse a dictionary word.\n// Example 3:\n// Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n// Output: false\n// Constraints:\n// 1 <= s.length <= 300\n// 1 <= wordDict.length <= 1000\n// 1 <= wordDict[i].length <= 20\n// s and wordDict[i] consist of only lowercase English letters.\n// All the strings of wordDict are unique.\nclass Solution {\npublic boolean wordBreak(String s, List<String> wordDict) {\nboolean[] dp = new boolean[s.length() + 1];\nSet<String> set = new HashSet<>();\nset.addAll(wordDict);\ndp[0] = true;\nfor(int i = 1; i <= s.length(); i++){\nfor(int j = i-1; j >= 0; j--){\ndp[i] = dp[j] && set.contains(s.substring(j, i));\nif(dp[i]) break;\n}\n}\nreturn dp[s.length()];\n}\n}",
                        "max_stars_repo_path": "Dynamic Programming/WordBreak.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 95
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_139",
                        "content": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n**Example 1:**\n**Input:** s =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\n**Output:** true\n**Explanation:** Return true because  \"leetcode \" can be segmented as  \"leet code \".\n**Example 2:**\n**Input:** s =  \"applepenapple \", wordDict = \\[ \"apple \", \"pen \"\\]\n**Output:** true\n**Explanation:** Return true because  \"applepenapple \" can be segmented as  \"apple pen apple \".\nNote that you are allowed to reuse a dictionary word.\n**Example 3:**\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** false\n**Constraints:**\n*   `1 <= s.length <= 300`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 20`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.\nInput:\ns =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\nOutput:\ntrue\n```java\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\npublic boolean wordBreak(String s, List<String> wordDict) {\nSet<String> dict = new HashSet<>(wordDict);\nboolean[] dp = new boolean[s.length() + 1];\ndp[0] = true;\nfor (int i = 1; i <= s.length(); i++) {\nfor (int j = 0; j < i; j++) {\nif (dp[j] && dict.contains(s.substring(j, i))) {\ndp[i] = true;\nbreak;\n}\n}\n}\nreturn dp[s.length()];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 95
                },
                {
                        "shared string": " that the same word in the dictionary may be reused multiple times in the segmentation. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_174",
                        "content": "The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\nTo reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.\nReturn _the knight's minimum initial health so that he can rescue the princess_.\n**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n**Example 1:**\n**Input:** dungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\n**Output:** 7\n**Explanation:** The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n**Example 2:**\n**Input:** dungeon = \\[\\[0\\]\\]\n**Output:** 1\n**Constraints:**\n*   `m == dungeon.length`\n*   `n == dungeon[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= dungeon[i][j] <= 1000`\nInput:\ndungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\nOutput:\n7\n```java\npublic int calculateMinimumHP(int[][] dungeon) {\nint m = dungeon.length, n = dungeon[0].length;\nint[][] dp = new int[m][n];\nfor (int i = m - 1; i >= 0; i--) {\nfor (int j = n - 1; j >= 0; j--) {\nif(i == m-1 && j == n-1)\ndp[i][j] = Math.min(0, dungeon[i][j]);\nelse if (i == m - 1)\ndp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\nelse if (j == n - 1)\ndp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\nelse\ndp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n}\n}\nreturn Math.abs(dp[0][0]) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 288
                },
                {
                        "id": "pretrain_java_data_5938405",
                        "content": "<reponame>innocentdevil09/LeetCode<filename>Problem 174/Problem174.java\nimport java.util.Arrays;\nimport java.util.stream.IntStream;\n/**\n* The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon\n* consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room\n* and must fight his way through dungeon to rescue the princess.\n*\n* The knight has an initial health point represented by a positive integer. If at any point his health point drops\n* to 0 or below, he dies immediately.\n*\n* Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon\n* entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the\n* knight's health (represented by positive integers).\n*\n* To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n*\n* Return the knight's minimum initial health so that he can rescue the princess.\n*\n* Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right\n* room where the princess is imprisoned.\n*\n* Example 1:\n* Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n* Output: 7\n* Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT ->\n* DOWN -> DOWN.\n*\n* Example 2:\n* Input: dungeon = [[0]]\n* Output: 1\n*\n* Constraints:\n* m == dungeon.length\n* n == dungeon[i].length\n* 1 <= m, n <= 200\n* -1000 <= dungeon[i][j] <= 1000\n*/\npublic class Problem174 {\n/**\n* DP method\n*\n* Time Complexity: O(M * N)\n* Space Complexity: O(M * N)\n*\n* @param dungeon\n* @return\n*/\nprivate static int calculateMinimumHP(int[][] dungeon) {\nif (dungeon.length == 0 || dungeon[0].length == 0) { return 0; }\nint m = dungeon.length;\nint n = dungeon[0].length;\nint[][] dp = new int[m + 1][n + 1];\nIntStream.range(0, m + 1).forEach(i -> Arrays.fill(dp[i], Integer.MAX_VALUE));\ndp[m][n - 1] = 1;\ndp[m - 1][n] = 1;\nfor (int i = m - 1; i >= 0; i--) {\nfor (int j = n - 1; j >= 0; j--) {\nint val = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\ndp[i][j] = val <= 0 ? 1 : val;\n}\n}\nreturn dp[0][0];\n}\n/**\n* Main method for test cases\n*\n* @param args\n*/\npublic static void main(String[] args) {\nint[][] dungeon = {{-2,-3,3},{-5,-10,1},{10,30,-5}};\nSystem.out.println(calculateMinimumHP(dungeon));\n}\n}",
                        "max_stars_repo_path": "Problem 174/Problem174.java",
                        "max_stars_repo_name": "innocentdevil09/LeetCode",
                        "max_stars_count": 0,
                        "__cluster__": 288
                },
                {
                        "shared string": " rooms laid out in a 2D grid. Our valiant knight was initially positioned in ",
                        "real_dup": 2
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_174",
                        "content": "The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\nTo reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.\nReturn _the knight's minimum initial health so that he can rescue the princess_.\n**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n**Example 1:**\n**Input:** dungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\n**Output:** 7\n**Explanation:** The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n**Example 2:**\n**Input:** dungeon = \\[\\[0\\]\\]\n**Output:** 1\n**Constraints:**\n*   `m == dungeon.length`\n*   `n == dungeon[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= dungeon[i][j] <= 1000`\nInput:\ndungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\nOutput:\n7\n```java\npublic int calculateMinimumHP(int[][] dungeon) {\nint m = dungeon.length, n = dungeon[0].length;\nint[][] dp = new int[m][n];\nfor (int i = m - 1; i >= 0; i--) {\nfor (int j = n - 1; j >= 0; j--) {\nif(i == m-1 && j == n-1)\ndp[i][j] = Math.min(0, dungeon[i][j]);\nelse if (i == m - 1)\ndp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\nelse if (j == n - 1)\ndp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\nelse\ndp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n}\n}\nreturn Math.abs(dp[0][0]) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 288
                },
                {
                        "id": "pretrain_java_data_5938405",
                        "content": "<reponame>innocentdevil09/LeetCode<filename>Problem 174/Problem174.java\nimport java.util.Arrays;\nimport java.util.stream.IntStream;\n/**\n* The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon\n* consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room\n* and must fight his way through dungeon to rescue the princess.\n*\n* The knight has an initial health point represented by a positive integer. If at any point his health point drops\n* to 0 or below, he dies immediately.\n*\n* Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon\n* entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the\n* knight's health (represented by positive integers).\n*\n* To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n*\n* Return the knight's minimum initial health so that he can rescue the princess.\n*\n* Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right\n* room where the princess is imprisoned.\n*\n* Example 1:\n* Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n* Output: 7\n* Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT ->\n* DOWN -> DOWN.\n*\n* Example 2:\n* Input: dungeon = [[0]]\n* Output: 1\n*\n* Constraints:\n* m == dungeon.length\n* n == dungeon[i].length\n* 1 <= m, n <= 200\n* -1000 <= dungeon[i][j] <= 1000\n*/\npublic class Problem174 {\n/**\n* DP method\n*\n* Time Complexity: O(M * N)\n* Space Complexity: O(M * N)\n*\n* @param dungeon\n* @return\n*/\nprivate static int calculateMinimumHP(int[][] dungeon) {\nif (dungeon.length == 0 || dungeon[0].length == 0) { return 0; }\nint m = dungeon.length;\nint n = dungeon[0].length;\nint[][] dp = new int[m + 1][n + 1];\nIntStream.range(0, m + 1).forEach(i -> Arrays.fill(dp[i], Integer.MAX_VALUE));\ndp[m][n - 1] = 1;\ndp[m - 1][n] = 1;\nfor (int i = m - 1; i >= 0; i--) {\nfor (int j = n - 1; j >= 0; j--) {\nint val = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\ndp[i][j] = val <= 0 ? 1 : val;\n}\n}\nreturn dp[0][0];\n}\n/**\n* Main method for test cases\n*\n* @param args\n*/\npublic static void main(String[] args) {\nint[][] dungeon = {{-2,-3,3},{-5,-10,1},{10,30,-5}};\nSystem.out.println(calculateMinimumHP(dungeon));\n}\n}",
                        "max_stars_repo_path": "Problem 174/Problem174.java",
                        "max_stars_repo_name": "innocentdevil09/LeetCode",
                        "max_stars_count": 0,
                        "__cluster__": 288
                },
                {
                        "shared string": " rooms laid out in a 2D grid. Our valiant knight was initially positioned in ",
                        "real_dup": 2
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_9051555",
                        "content": "/*\nLC724. Find Pivot Index\nGiven an array of integers nums, calculate the pivot index of this array.\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.\nIf the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\nReturn the leftmost pivot index. If no such index exists, return -1.\nExample 1:\nInput: nums = [1,7,3,6,5,6]\nOutput: 3\nExplanation:\nThe pivot index is 3.\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\nRight sum = nums[4] + nums[5] = 5 + 6 = 11\nExample 2:\nInput: nums = [1,2,3]\nOutput: -1\nExplanation:\nThere is no index that satisfies the conditions in the problem statement.\nExample 3:\nInput: nums = [2,1,-1]\nOutput: 0\nExplanation:\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums[1] + nums[2] = 1 + -1 = 0\nConstraints:\n1 <= nums.length <= 10^4\n-1000 <= nums[i] <= 1000\n*/\nclass Solution {\npublic int pivotIndex(int[] nums) {\nint leftSum = 0;\nint rightSum = 0;\nfor (int num : nums)\n{\nrightSum += num;\n}\nfor (int index = 0; index < nums.length; index++)\n{\nrightSum -= nums[index];\nif (leftSum == rightSum) {\nreturn index;\n}\nleftSum += nums[index];\n}\nreturn -1;\n}\n}",
                        "max_stars_repo_path": "src/LC724-FindPivotIndex.java",
                        "max_stars_repo_name": "RainbowDragon/LeetCode_Java",
                        "max_stars_count": 0,
                        "__cluster__": 420
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_724",
                        "content": "Given an array of integers `nums`, calculate the **pivot index** of this array.\nThe **pivot index** is the index where the sum of all the numbers **strictly** to the left of the index is equal to the sum of all the numbers **strictly** to the index's right.\nIf the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array.\nReturn _the **leftmost pivot index**_. If no such index exists, return `-1`.\n**Example 1:**\n**Input:** nums = \\[1,7,3,6,5,6\\]\n**Output:** 3\n**Explanation:**\nThe pivot index is 3.\nLeft sum = nums\\[0\\] + nums\\[1\\] + nums\\[2\\] = 1 + 7 + 3 = 11\nRight sum = nums\\[4\\] + nums\\[5\\] = 5 + 6 = 11\n**Example 2:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** -1\n**Explanation:**\nThere is no index that satisfies the conditions in the problem statement.\n**Example 3:**\n**Input:** nums = \\[2,1,-1\\]\n**Output:** 0\n**Explanation:**\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums\\[1\\] + nums\\[2\\] = 1 + -1 = 0\n**Constraints:**\n*   `1 <= nums.length <= 104`\n*   `-1000 <= nums[i] <= 1000`\n**Note:** This question is the same as 1991: [https://leetcode.com/problems/find-the-middle-index-in-array/](https://leetcode.com/problems/find-the-middle-index-in-array/)\nInput:\nnums = \\[1,7,3,6,5,6\\]\nOutput:\n3\n```java\npublic int pivotIndex(int[] nums) {\nint total_sum = 0, left_sum = 0;\nfor (int num : nums)\ntotal_sum += num;\nfor (int i = 0; i < nums.length; ++i) {\nif (left_sum == total_sum - left_sum - nums[i])\nreturn i;\nleft_sum += nums[i];\n}\nreturn -1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 420
                },
                {
                        "shared string": " because there are no elements to the left. This also applies to the right edge of the array. Return "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_42",
                        "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n**Example 1:**\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n**Example 2:**\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n**Constraints:**\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\nInput:\nheight = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\nOutput:\n6\n```java\npublic int trap(int[] height) {\nint n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (left < right) {\nif (height[left] <= height[right]) {\nmaxLeft = Math.max(maxLeft, height[left]);\nwater += maxLeft - height[left];\nleft++;\n} else {\nmaxRight = Math.max(maxRight, height[right]);\nwater += maxRight - height[right];\nright--;\n}\n}\nreturn water;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "id": "pretrain_java_data_10732408",
                        "content": "package pers.tavish.leetcode.hard;\n/*\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9\nConstraints:\n- n == height.length\n- 0 <= n <= 3 * 104\n- 0 <= height[i] <= 105\nfor more information: https://leetcode.com/problems/trapping-rain-water/\n*/\npublic class TrappingRainWater {\npublic int trap(int[] height) {\nint res = 0, l = 0, r = height.length - 1;\nwhile (l < r) {\nint mn = Math.min(height[l], height[r]);\nif (height[l] == mn) {\n++l;\nwhile (l < r && height[l] < mn) {\nres += mn - height[l++];\n}\n} else {\n--r;\nwhile (l < r && height[r] < mn) {\nres += mn - height[r--];\n}\n}\n}\nreturn res;\n}\n}",
                        "max_stars_repo_path": "src/main/java/pers/tavish/leetcode/hard/TrappingRainWater.java",
                        "max_stars_repo_name": "Tavi3h/LeetCode_3rd",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "shared string": " non-negative integers representing an elevation map where the width of each bar is "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_42",
                        "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n**Example 1:**\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n**Example 2:**\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n**Constraints:**\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\nInput:\nheight = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\nOutput:\n6\n```java\npublic int trap(int[] height) {\nint n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (left < right) {\nif (height[left] <= height[right]) {\nmaxLeft = Math.max(maxLeft, height[left]);\nwater += maxLeft - height[left];\nleft++;\n} else {\nmaxRight = Math.max(maxRight, height[right]);\nwater += maxRight - height[right];\nright--;\n}\n}\nreturn water;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "id": "pretrain_java_data_10732408",
                        "content": "package pers.tavish.leetcode.hard;\n/*\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9\nConstraints:\n- n == height.length\n- 0 <= n <= 3 * 104\n- 0 <= height[i] <= 105\nfor more information: https://leetcode.com/problems/trapping-rain-water/\n*/\npublic class TrappingRainWater {\npublic int trap(int[] height) {\nint res = 0, l = 0, r = height.length - 1;\nwhile (l < r) {\nint mn = Math.min(height[l], height[r]);\nif (height[l] == mn) {\n++l;\nwhile (l < r && height[l] < mn) {\nres += mn - height[l++];\n}\n} else {\n--r;\nwhile (l < r && height[r] < mn) {\nres += mn - height[r--];\n}\n}\n}\nreturn res;\n}\n}",
                        "max_stars_repo_path": "src/main/java/pers/tavish/leetcode/hard/TrappingRainWater.java",
                        "max_stars_repo_name": "Tavi3h/LeetCode_3rd",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "shared string": " non-negative integers representing an elevation map where the width of each bar is "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_42",
                        "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n**Example 1:**\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n**Example 2:**\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n**Constraints:**\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\nInput:\nheight = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\nOutput:\n6\n```java\npublic int trap(int[] height) {\nint n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (left < right) {\nif (height[left] <= height[right]) {\nmaxLeft = Math.max(maxLeft, height[left]);\nwater += maxLeft - height[left];\nleft++;\n} else {\nmaxRight = Math.max(maxRight, height[right]);\nwater += maxRight - height[right];\nright--;\n}\n}\nreturn water;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "id": "pretrain_java_data_12295632",
                        "content": "// @desc-start\n// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n//\n// Example 1:\n//\n//\n// Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n// Output: 6\n// Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n//\n// Example 2:\n//\n// Input: height = [4,2,0,3,2,5]\n// Output: 9\n//\n//\n// Constraints:\n//\n// n == height.length\n// 0 <= n <= 3 * 104\n// 0 <= height[i] <= 105\n//\n//\n// @desc-end\n// @code-start\nclass Solution {\npublic int trap(int[] height) {\nif(height.length == 0)\nreturn 0;\nint left = 0;\nint right = height.length - 1;\nint ans = 0;\nint leftMax = height[0];\nint rightMax = height[height.length - 1];\nwhile(left <= right) {\nleftMax = Math.max(leftMax, height[left]);\nrightMax = Math.max(rightMax, height[right]);\nif(leftMax < rightMax) {\nans += leftMax - height[left];\nleft ++;\n} else {\nans += rightMax - height[right];\nright --;\n}\n}\nreturn ans;\n}\n}\n// @code-end",
                        "max_stars_repo_path": "solutions/java/no-0042-trapping-rain-water.java",
                        "max_stars_repo_name": "youkabeng/conquer-leetcode",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "shared string": " non-negative integers representing an elevation map where the width of each bar is "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_42",
                        "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n**Example 1:**\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n**Example 2:**\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n**Constraints:**\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\nInput:\nheight = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\nOutput:\n6\n```java\npublic int trap(int[] height) {\nint n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (left < right) {\nif (height[left] <= height[right]) {\nmaxLeft = Math.max(maxLeft, height[left]);\nwater += maxLeft - height[left];\nleft++;\n} else {\nmaxRight = Math.max(maxRight, height[right]);\nwater += maxRight - height[right];\nright--;\n}\n}\nreturn water;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "id": "pretrain_java_data_12295632",
                        "content": "// @desc-start\n// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n//\n// Example 1:\n//\n//\n// Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n// Output: 6\n// Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n//\n// Example 2:\n//\n// Input: height = [4,2,0,3,2,5]\n// Output: 9\n//\n//\n// Constraints:\n//\n// n == height.length\n// 0 <= n <= 3 * 104\n// 0 <= height[i] <= 105\n//\n//\n// @desc-end\n// @code-start\nclass Solution {\npublic int trap(int[] height) {\nif(height.length == 0)\nreturn 0;\nint left = 0;\nint right = height.length - 1;\nint ans = 0;\nint leftMax = height[0];\nint rightMax = height[height.length - 1];\nwhile(left <= right) {\nleftMax = Math.max(leftMax, height[left]);\nrightMax = Math.max(rightMax, height[right]);\nif(leftMax < rightMax) {\nans += leftMax - height[left];\nleft ++;\n} else {\nans += rightMax - height[right];\nright --;\n}\n}\nreturn ans;\n}\n}\n// @code-end",
                        "max_stars_repo_path": "solutions/java/no-0042-trapping-rain-water.java",
                        "max_stars_repo_name": "youkabeng/conquer-leetcode",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "shared string": " non-negative integers representing an elevation map where the width of each bar is "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_15567996",
                        "content": "package com.solution.medium.houserobber198;\n/**\n* @ClassName HouseRobber\n* @Description 198. House Robber\n* You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n* <p>\n* Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n* <p>\n* <p>\n* <p>\n* Example 1:\n* <p>\n* Input: nums = [1,2,3,1]\n* Output: 4\n* Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n* Total amount you can rob = 1 + 3 = 4.\n* Example 2:\n* <p>\n* Input: nums = [2,7,9,3,1]\n* Output: 12\n* Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n* Total amount you can rob = 2 + 9 + 1 = 12.\n* <p>\n* <p>\n* Constraints:\n* <p>\n* 1 <= nums.length <= 100\n* 0 <= nums[i] <= 400\n* <p>\n* <p>\n* 198. \u6253\u5bb6\u52ab\u820d\n* \u4f60\u662f\u4e00\u4e2a\u4e13\u4e1a\u7684\u5c0f\u5077\uff0c\u8ba1\u5212\u5077\u7a83\u6cbf\u8857\u7684\u623f\u5c4b\u3002\u6bcf\u95f4\u623f\u5185\u90fd\u85cf\u6709\u4e00\u5b9a\u7684\u73b0\u91d1\uff0c\u5f71\u54cd\u4f60\u5077\u7a83\u7684\u552f\u4e00\u5236\u7ea6\u56e0\u7d20\u5c31\u662f\u76f8\u90bb\u7684\u623f\u5c4b\u88c5\u6709\u76f8\u4e92\u8fde\u901a\u7684\u9632\u76d7\u7cfb\u7edf\uff0c\u5982\u679c\u4e24\u95f4\u76f8\u90bb\u7684\u623f\u5c4b\u5728\u540c\u4e00\u665a\u4e0a\u88ab\u5c0f\u5077\u95ef\u5165\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u62a5\u8b66\u3002\n* <p>\n* \u7ed9\u5b9a\u4e00\u4e2a\u4ee3\u8868\u6bcf\u4e2a\u623f\u5c4b\u5b58\u653e\u91d1\u989d\u7684\u975e\u8d1f\u6574\u6570\u6570\u7ec4\uff0c\u8ba1\u7b97\u4f60 \u4e0d\u89e6\u52a8\u8b66\u62a5\u88c5\u7f6e\u7684\u60c5\u51b5\u4e0b \uff0c\u4e00\u591c\u4e4b\u5185\u80fd\u591f\u5077\u7a83\u5230\u7684\u6700\u9ad8\u91d1\u989d\u3002\n* <p>\n*\n* <p>\n* \u793a\u4f8b 1\uff1a\n* <p>\n* \u8f93\u5165\uff1a[1,2,3,1]\n* \u8f93\u51fa\uff1a4\n* \u89e3\u91ca\uff1a\u5077\u7a83 1 \u53f7\u623f\u5c4b (\u91d1\u989d = 1) \uff0c\u7136\u540e\u5077\u7a83 3 \u53f7\u623f\u5c4b (\u91d1\u989d = 3)\u3002\n* \u00a0    \u5077\u7a83\u5230\u7684\u6700\u9ad8\u91d1\u989d = 1 + 3 = 4 \u3002\n* \u793a\u4f8b 2\uff1a\n* <p>\n* \u8f93\u5165\uff1a[2,7,9,3,1]\n* \u8f93\u51fa\uff1a12\n* \u89e3\u91ca\uff1a\u5077\u7a83 1 \u53f7\u623f\u5c4b (\u91d1\u989d = 2), \u5077\u7a83 3 \u53f7\u623f\u5c4b (\u91d1\u989d = 9)\uff0c\u63a5\u7740\u5077\u7a83 5 \u53f7\u623f\u5c4b (\u91d1\u989d = 1)\u3002\n* \u00a0    \u5077\u7a83\u5230\u7684\u6700\u9ad8\u91d1\u989d = 2 + 9 + 1 = 12 \u3002\n*\n* <p>\n* \u63d0\u793a\uff1a\n* <p>\n* 0 <= nums.length <= 100\n* 0 <= nums[i] <= 400\n* <p>\n* \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09\n* \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/house-robber\n* \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002\n* @Author yi\n* @Date 2021/4/15 21:16\n*/\npublic class HouseRobber {\n}\n/**\n* \u52a8\u6001\u89c4\u5212\n*/\nclass Solution {\npublic int rob(int[] nums) {\nint n = nums.length;\nif (n == 0) {\nreturn 0;\n}\nif (n == 1) {\nreturn nums[0];\n}\nif (n == 2) {\nreturn Math.max(nums[0], nums[1]);\n}\nint first = nums[0];\nint second = Math.max(nums[0], nums[1]);\nfor (int i = 2; i < n; i++) {\nint temp = second;\nfirst = Math.max(first + nums[i], second);\nsecond = first;\nfirst = temp;\n}\nreturn second;\n}\n}",
                        "max_stars_repo_path": "src/com/solution/medium/houserobber198/HouseRobber.java",
                        "max_stars_repo_name": "ataraxy-zhi/leetcode_questions_with_java",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_15567996",
                        "content": "package com.solution.medium.houserobber198;\n/**\n* @ClassName HouseRobber\n* @Description 198. House Robber\n* You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n* <p>\n* Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n* <p>\n* <p>\n* <p>\n* Example 1:\n* <p>\n* Input: nums = [1,2,3,1]\n* Output: 4\n* Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n* Total amount you can rob = 1 + 3 = 4.\n* Example 2:\n* <p>\n* Input: nums = [2,7,9,3,1]\n* Output: 12\n* Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n* Total amount you can rob = 2 + 9 + 1 = 12.\n* <p>\n* <p>\n* Constraints:\n* <p>\n* 1 <= nums.length <= 100\n* 0 <= nums[i] <= 400\n* <p>\n* <p>\n* 198. \u6253\u5bb6\u52ab\u820d\n* \u4f60\u662f\u4e00\u4e2a\u4e13\u4e1a\u7684\u5c0f\u5077\uff0c\u8ba1\u5212\u5077\u7a83\u6cbf\u8857\u7684\u623f\u5c4b\u3002\u6bcf\u95f4\u623f\u5185\u90fd\u85cf\u6709\u4e00\u5b9a\u7684\u73b0\u91d1\uff0c\u5f71\u54cd\u4f60\u5077\u7a83\u7684\u552f\u4e00\u5236\u7ea6\u56e0\u7d20\u5c31\u662f\u76f8\u90bb\u7684\u623f\u5c4b\u88c5\u6709\u76f8\u4e92\u8fde\u901a\u7684\u9632\u76d7\u7cfb\u7edf\uff0c\u5982\u679c\u4e24\u95f4\u76f8\u90bb\u7684\u623f\u5c4b\u5728\u540c\u4e00\u665a\u4e0a\u88ab\u5c0f\u5077\u95ef\u5165\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u62a5\u8b66\u3002\n* <p>\n* \u7ed9\u5b9a\u4e00\u4e2a\u4ee3\u8868\u6bcf\u4e2a\u623f\u5c4b\u5b58\u653e\u91d1\u989d\u7684\u975e\u8d1f\u6574\u6570\u6570\u7ec4\uff0c\u8ba1\u7b97\u4f60 \u4e0d\u89e6\u52a8\u8b66\u62a5\u88c5\u7f6e\u7684\u60c5\u51b5\u4e0b \uff0c\u4e00\u591c\u4e4b\u5185\u80fd\u591f\u5077\u7a83\u5230\u7684\u6700\u9ad8\u91d1\u989d\u3002\n* <p>\n*\n* <p>\n* \u793a\u4f8b 1\uff1a\n* <p>\n* \u8f93\u5165\uff1a[1,2,3,1]\n* \u8f93\u51fa\uff1a4\n* \u89e3\u91ca\uff1a\u5077\u7a83 1 \u53f7\u623f\u5c4b (\u91d1\u989d = 1) \uff0c\u7136\u540e\u5077\u7a83 3 \u53f7\u623f\u5c4b (\u91d1\u989d = 3)\u3002\n* \u00a0    \u5077\u7a83\u5230\u7684\u6700\u9ad8\u91d1\u989d = 1 + 3 = 4 \u3002\n* \u793a\u4f8b 2\uff1a\n* <p>\n* \u8f93\u5165\uff1a[2,7,9,3,1]\n* \u8f93\u51fa\uff1a12\n* \u89e3\u91ca\uff1a\u5077\u7a83 1 \u53f7\u623f\u5c4b (\u91d1\u989d = 2), \u5077\u7a83 3 \u53f7\u623f\u5c4b (\u91d1\u989d = 9)\uff0c\u63a5\u7740\u5077\u7a83 5 \u53f7\u623f\u5c4b (\u91d1\u989d = 1)\u3002\n* \u00a0    \u5077\u7a83\u5230\u7684\u6700\u9ad8\u91d1\u989d = 2 + 9 + 1 = 12 \u3002\n*\n* <p>\n* \u63d0\u793a\uff1a\n* <p>\n* 0 <= nums.length <= 100\n* 0 <= nums[i] <= 400\n* <p>\n* \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09\n* \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/house-robber\n* \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002\n* @Author yi\n* @Date 2021/4/15 21:16\n*/\npublic class HouseRobber {\n}\n/**\n* \u52a8\u6001\u89c4\u5212\n*/\nclass Solution {\npublic int rob(int[] nums) {\nint n = nums.length;\nif (n == 0) {\nreturn 0;\n}\nif (n == 1) {\nreturn nums[0];\n}\nif (n == 2) {\nreturn Math.max(nums[0], nums[1]);\n}\nint first = nums[0];\nint second = Math.max(nums[0], nums[1]);\nfor (int i = 2; i < n; i++) {\nint temp = second;\nfirst = Math.max(first + nums[i], second);\nsecond = first;\nfirst = temp;\n}\nreturn second;\n}\n}",
                        "max_stars_repo_path": "src/com/solution/medium/houserobber198/HouseRobber.java",
                        "max_stars_repo_name": "ataraxy-zhi/leetcode_questions_with_java",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_15567996",
                        "content": "package com.solution.medium.houserobber198;\n/**\n* @ClassName HouseRobber\n* @Description 198. House Robber\n* You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n* <p>\n* Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n* <p>\n* <p>\n* <p>\n* Example 1:\n* <p>\n* Input: nums = [1,2,3,1]\n* Output: 4\n* Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n* Total amount you can rob = 1 + 3 = 4.\n* Example 2:\n* <p>\n* Input: nums = [2,7,9,3,1]\n* Output: 12\n* Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n* Total amount you can rob = 2 + 9 + 1 = 12.\n* <p>\n* <p>\n* Constraints:\n* <p>\n* 1 <= nums.length <= 100\n* 0 <= nums[i] <= 400\n* <p>\n* <p>\n* 198. \u6253\u5bb6\u52ab\u820d\n* \u4f60\u662f\u4e00\u4e2a\u4e13\u4e1a\u7684\u5c0f\u5077\uff0c\u8ba1\u5212\u5077\u7a83\u6cbf\u8857\u7684\u623f\u5c4b\u3002\u6bcf\u95f4\u623f\u5185\u90fd\u85cf\u6709\u4e00\u5b9a\u7684\u73b0\u91d1\uff0c\u5f71\u54cd\u4f60\u5077\u7a83\u7684\u552f\u4e00\u5236\u7ea6\u56e0\u7d20\u5c31\u662f\u76f8\u90bb\u7684\u623f\u5c4b\u88c5\u6709\u76f8\u4e92\u8fde\u901a\u7684\u9632\u76d7\u7cfb\u7edf\uff0c\u5982\u679c\u4e24\u95f4\u76f8\u90bb\u7684\u623f\u5c4b\u5728\u540c\u4e00\u665a\u4e0a\u88ab\u5c0f\u5077\u95ef\u5165\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u62a5\u8b66\u3002\n* <p>\n* \u7ed9\u5b9a\u4e00\u4e2a\u4ee3\u8868\u6bcf\u4e2a\u623f\u5c4b\u5b58\u653e\u91d1\u989d\u7684\u975e\u8d1f\u6574\u6570\u6570\u7ec4\uff0c\u8ba1\u7b97\u4f60 \u4e0d\u89e6\u52a8\u8b66\u62a5\u88c5\u7f6e\u7684\u60c5\u51b5\u4e0b \uff0c\u4e00\u591c\u4e4b\u5185\u80fd\u591f\u5077\u7a83\u5230\u7684\u6700\u9ad8\u91d1\u989d\u3002\n* <p>\n*\n* <p>\n* \u793a\u4f8b 1\uff1a\n* <p>\n* \u8f93\u5165\uff1a[1,2,3,1]\n* \u8f93\u51fa\uff1a4\n* \u89e3\u91ca\uff1a\u5077\u7a83 1 \u53f7\u623f\u5c4b (\u91d1\u989d = 1) \uff0c\u7136\u540e\u5077\u7a83 3 \u53f7\u623f\u5c4b (\u91d1\u989d = 3)\u3002\n* \u00a0    \u5077\u7a83\u5230\u7684\u6700\u9ad8\u91d1\u989d = 1 + 3 = 4 \u3002\n* \u793a\u4f8b 2\uff1a\n* <p>\n* \u8f93\u5165\uff1a[2,7,9,3,1]\n* \u8f93\u51fa\uff1a12\n* \u89e3\u91ca\uff1a\u5077\u7a83 1 \u53f7\u623f\u5c4b (\u91d1\u989d = 2), \u5077\u7a83 3 \u53f7\u623f\u5c4b (\u91d1\u989d = 9)\uff0c\u63a5\u7740\u5077\u7a83 5 \u53f7\u623f\u5c4b (\u91d1\u989d = 1)\u3002\n* \u00a0    \u5077\u7a83\u5230\u7684\u6700\u9ad8\u91d1\u989d = 2 + 9 + 1 = 12 \u3002\n*\n* <p>\n* \u63d0\u793a\uff1a\n* <p>\n* 0 <= nums.length <= 100\n* 0 <= nums[i] <= 400\n* <p>\n* \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09\n* \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/house-robber\n* \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002\n* @Author yi\n* @Date 2021/4/15 21:16\n*/\npublic class HouseRobber {\n}\n/**\n* \u52a8\u6001\u89c4\u5212\n*/\nclass Solution {\npublic int rob(int[] nums) {\nint n = nums.length;\nif (n == 0) {\nreturn 0;\n}\nif (n == 1) {\nreturn nums[0];\n}\nif (n == 2) {\nreturn Math.max(nums[0], nums[1]);\n}\nint first = nums[0];\nint second = Math.max(nums[0], nums[1]);\nfor (int i = 2; i < n; i++) {\nint temp = second;\nfirst = Math.max(first + nums[i], second);\nsecond = first;\nfirst = temp;\n}\nreturn second;\n}\n}",
                        "max_stars_repo_path": "src/com/solution/medium/houserobber198/HouseRobber.java",
                        "max_stars_repo_name": "ataraxy-zhi/leetcode_questions_with_java",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_124",
                        "content": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\nThe **path sum** of a path is the sum of the node's values in the path.\nGiven the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.\n**Example 1:**\n**Input:** root = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n**Example 2:**\n**Input:** root = \\[-10,9,20,null,null,15,7\\]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[1,2,3\\]\nOutput:\n6\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\n}\npublic int maxPathSum(TreeNode root) {\nint[] maxSum = new int[]{Integer.MIN_VALUE};\nhelper(root, maxSum);\nreturn maxSum[0];\n}\nprivate int helper(TreeNode root, int[] maxSum) {\nif (root == null) return 0;\nint left = Math.max(0, helper(root.left, maxSum));\nint right = Math.max(0, helper(root.right, maxSum));\nmaxSum[0] = Math.max(maxSum[0], left + right + root.val);\nreturn Math.max(left, right) + root.val;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 271
                },
                {
                        "id": "pretrain_java_data_1399569",
                        "content": "/*\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any path.\nExample 1:\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\nExample 2:\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\nConstraints:\nThe number of nodes in the tree is in the range [1, 3 * 10^4].\n-1000 <= Node.val <= 1000\n*/\nclass Solution {\nint maxSum = Integer.MIN_VALUE;\npublic int maxPathSum(TreeNode root) {\nif(root == null) {\nreturn maxSum;\n}\npathSum(root);\nreturn maxSum;\n}\nint pathSum(TreeNode root) {\nif(root == null) {\nreturn 0;\n}\nint left = Math.max(0, pathSum(root.left));\nint right = Math.max(0, pathSum(root.right));\nmaxSum = Math.max(maxSum, left+right+root.val);\nreturn Math.max(left, right) + root.val;\n}\n}",
                        "max_stars_repo_path": "LC_124_binary_tree_maximum_path_sum.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 271
                },
                {
                        "shared string": " in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_124",
                        "content": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\nThe **path sum** of a path is the sum of the node's values in the path.\nGiven the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.\n**Example 1:**\n**Input:** root = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n**Example 2:**\n**Input:** root = \\[-10,9,20,null,null,15,7\\]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[1,2,3\\]\nOutput:\n6\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\n}\npublic int maxPathSum(TreeNode root) {\nint[] maxSum = new int[]{Integer.MIN_VALUE};\nhelper(root, maxSum);\nreturn maxSum[0];\n}\nprivate int helper(TreeNode root, int[] maxSum) {\nif (root == null) return 0;\nint left = Math.max(0, helper(root.left, maxSum));\nint right = Math.max(0, helper(root.right, maxSum));\nmaxSum[0] = Math.max(maxSum[0], left + right + root.val);\nreturn Math.max(left, right) + root.val;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 271
                },
                {
                        "id": "pretrain_java_data_1399569",
                        "content": "/*\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any path.\nExample 1:\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\nExample 2:\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\nConstraints:\nThe number of nodes in the tree is in the range [1, 3 * 10^4].\n-1000 <= Node.val <= 1000\n*/\nclass Solution {\nint maxSum = Integer.MIN_VALUE;\npublic int maxPathSum(TreeNode root) {\nif(root == null) {\nreturn maxSum;\n}\npathSum(root);\nreturn maxSum;\n}\nint pathSum(TreeNode root) {\nif(root == null) {\nreturn 0;\n}\nint left = Math.max(0, pathSum(root.left));\nint right = Math.max(0, pathSum(root.right));\nmaxSum = Math.max(maxSum, left+right+root.val);\nreturn Math.max(left, right) + root.val;\n}\n}",
                        "max_stars_repo_path": "LC_124_binary_tree_maximum_path_sum.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 271
                },
                {
                        "shared string": " in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_713",
                        "content": "Given an array of integers `nums` and an integer `k`, return _the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than_ `k`.\n**Example 1:**\n**Input:** nums = \\[10,5,2,6\\], k = 100\n**Output:** 8\n**Explanation:** The 8 subarrays that have product less than 100 are:\n\\[10\\], \\[5\\], \\[2\\], \\[6\\], \\[10, 5\\], \\[5, 2\\], \\[2, 6\\], \\[5, 2, 6\\]\nNote that \\[10, 5, 2\\] is not included as the product of 100 is not strictly less than k.\n**Example 2:**\n**Input:** nums = \\[1,2,3\\], k = 0\n**Output:** 0\n**Constraints:**\n*   `1 <= nums.length <= 3 * 104`\n*   `1 <= nums[i] <= 1000`\n*   `0 <= k <= 106`\nInput:\nnums = \\[10,5,2,6\\], k = 100\nOutput:\n8\n```java\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\nif (k <= 1) return 0;\nint prod = 1, count = 0, left = 0;\nfor (int right = 0; right < nums.length; right++) {\nprod *= nums[right];\nwhile (prod >= k) prod /= nums[left++];\ncount += right - left + 1;\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 415
                },
                {
                        "id": "pretrain_java_data_2859365",
                        "content": "package leetcode.problems.linkedin;\n/** 713. Subarray Product Less Than K\n* Given an array of integers nums and an integer k, return the number of contiguous subarrays\n* where the product of all the elements in the subarray is strictly less than k.\n*\n* Example 1:\n* Input: nums = [10,5,2,6], k = 100\n* Output: 8\n* Explanation: The 8 subarrays that have product less than 100 are:\n* [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\n* Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n*\n* Example 2:\n* Input: nums = [1,2,3], k = 0\n* Output: 0\n*\n* Constraints:\n*     1 <= nums.length <= 3 * 104\n*     1 <= nums[i] <= 1000\n*     0 <= k <= 106\n*/\npublic class _713SubarrayProductLessThanK {\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\nif (k <= 1) return 0;\nint prod = 1, ans = 0, left = 0;\nfor (int right = 0; right < nums.length; right++) {\nprod *= nums[right];\nwhile (prod >= k) prod /= nums[left++];\nans += right - left + 1;\n}\nreturn ans;\n}\n}",
                        "max_stars_repo_path": "src/leetcode/problems/linkedin/_713SubarrayProductLessThanK.java",
                        "max_stars_repo_name": "alparslansari/algorithm",
                        "max_stars_count": 0,
                        "__cluster__": 415
                },
                {
                        "shared string": " where the product of all the elements in the subarray is strictly less than"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_713",
                        "content": "Given an array of integers `nums` and an integer `k`, return _the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than_ `k`.\n**Example 1:**\n**Input:** nums = \\[10,5,2,6\\], k = 100\n**Output:** 8\n**Explanation:** The 8 subarrays that have product less than 100 are:\n\\[10\\], \\[5\\], \\[2\\], \\[6\\], \\[10, 5\\], \\[5, 2\\], \\[2, 6\\], \\[5, 2, 6\\]\nNote that \\[10, 5, 2\\] is not included as the product of 100 is not strictly less than k.\n**Example 2:**\n**Input:** nums = \\[1,2,3\\], k = 0\n**Output:** 0\n**Constraints:**\n*   `1 <= nums.length <= 3 * 104`\n*   `1 <= nums[i] <= 1000`\n*   `0 <= k <= 106`\nInput:\nnums = \\[10,5,2,6\\], k = 100\nOutput:\n8\n```java\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\nif (k <= 1) return 0;\nint prod = 1, count = 0, left = 0;\nfor (int right = 0; right < nums.length; right++) {\nprod *= nums[right];\nwhile (prod >= k) prod /= nums[left++];\ncount += right - left + 1;\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 415
                },
                {
                        "id": "pretrain_java_data_2859365",
                        "content": "package leetcode.problems.linkedin;\n/** 713. Subarray Product Less Than K\n* Given an array of integers nums and an integer k, return the number of contiguous subarrays\n* where the product of all the elements in the subarray is strictly less than k.\n*\n* Example 1:\n* Input: nums = [10,5,2,6], k = 100\n* Output: 8\n* Explanation: The 8 subarrays that have product less than 100 are:\n* [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\n* Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n*\n* Example 2:\n* Input: nums = [1,2,3], k = 0\n* Output: 0\n*\n* Constraints:\n*     1 <= nums.length <= 3 * 104\n*     1 <= nums[i] <= 1000\n*     0 <= k <= 106\n*/\npublic class _713SubarrayProductLessThanK {\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\nif (k <= 1) return 0;\nint prod = 1, ans = 0, left = 0;\nfor (int right = 0; right < nums.length; right++) {\nprod *= nums[right];\nwhile (prod >= k) prod /= nums[left++];\nans += right - left + 1;\n}\nreturn ans;\n}\n}",
                        "max_stars_repo_path": "src/leetcode/problems/linkedin/_713SubarrayProductLessThanK.java",
                        "max_stars_repo_name": "alparslansari/algorithm",
                        "max_stars_count": 0,
                        "__cluster__": 415
                },
                {
                        "shared string": " where the product of all the elements in the subarray is strictly less than"
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_18844432",
                        "content": "package org.phoenix.leetcode.challenges;\n/**\n* You are given an array prices where prices[i] is the price of a given stock on the ith day.\n* <p>\n* Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n* <p>\n* After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n* Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n* Constraints:\n* <p>\n* 1 <= prices.length <= 5000\n* 0 <= prices[i] <= 1000\n*/\npublic class Problem15_BestTimeToBuyAndSellStockWithCooldown {\npublic int maxProfit(int[] prices) {\nint profit1 = 0, profit2 = 0;\nfor (int i = 1; i < prices.length; i++) {\nint copy = profit1;\nprofit1 = Math.max(profit1 + prices[i] - prices[i - 1], profit2);\nprofit2 = Math.max(copy, profit2);\n}\nreturn Math.max(profit1, profit2);\n}\n}",
                        "max_stars_repo_path": "october-2021-leetcode-challenge/src/main/java/org/phoenix/leetcode/challenges/Problem15_BestTimeToBuyAndSellStockWithCooldown.java",
                        "max_stars_repo_name": "vibhorsingh11/LeetCode",
                        "max_stars_count": 0,
                        "__cluster__": 339
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_309",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n*   After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n**Example 1:**\n**Input:** prices = \\[1,2,3,0,2\\]\n**Output:** 3\n**Explanation:** transactions = \\[buy, sell, cooldown, buy, sell\\]\n**Example 2:**\n**Input:** prices = \\[1\\]\n**Output:** 0\n**Constraints:**\n*   `1 <= prices.length <= 5000`\n*   `0 <= prices[i] <= 1000`\nInput:\nprices = \\[1,2,3,0,2\\]\nOutput:\n3\n```java\npublic int maxProfit(int[] prices) {\nint profit = 0;\nfor (int i = 1; i < prices.length; i++) {\nprofit += Math.max(prices[i] - prices[i - 1], 0);\n}\nreturn profit;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 339
                },
                {
                        "shared string": " Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions: * "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_494",
                        "content": "You are given an integer array `nums` and an integer `target`.\nYou want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.\n*   For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `\"+2-1 \"`.\nReturn the number of different **expressions** that you can build, which evaluates to `target`.\n**Example 1:**\n**Input:** nums = \\[1,1,1,1,1\\], target = 3\n**Output:** 5\n**Explanation:** There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n**Example 2:**\n**Input:** nums = \\[1\\], target = 1\n**Output:** 1\n**Constraints:**\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 1000`\n*   `0 <= sum(nums[i]) <= 1000`\n*   `-1000 <= target <= 1000`\nInput:\nnums = \\[1,1,1,1,1\\], target = 3\nOutput:\n5\n```java\npublic int findTargetSumWays(int[] nums, int target) {\nint sum = 0;\nfor (int num : nums) sum += num;\nif (sum < target || (sum + target) % 2 != 0) return 0;\nint target_sum = (sum + target) / 2;\nint[] dp = new int[target_sum + 1];\ndp[0] = 1;\nfor (int num : nums) {\nfor (int j = target_sum; j >= num; j--) {\ndp[j] += dp[j - num];\n}\n}\nreturn dp[target_sum];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 385
                },
                {
                        "id": "pretrain_java_data_17353555",
                        "content": "package leetcode.problems;\n/** 494. Target Sum\n* You are given an integer array nums and an integer target.\n* You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n*     For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\n* Return the number of different expressions that you can build, which evaluates to target.\n* Example 1:\n* Input: nums = [1,1,1,1,1], target = 3\n* Output: 5\n* Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n* -1 + 1 + 1 + 1 + 1 = 3\n* +1 - 1 + 1 + 1 + 1 = 3\n* +1 + 1 - 1 + 1 + 1 = 3\n* +1 + 1 + 1 - 1 + 1 = 3\n* +1 + 1 + 1 + 1 - 1 = 3\n* Example 2:\n* Input: nums = [1], target = 1\n* Output: 1\n* Constraints:\n*     1 <= nums.length <= 20\n*     0 <= nums[i] <= 1000\n*     0 <= sum(nums[i]) <= 1000\n*     -1000 <= target <= 1000\n*/\npublic class _494TargetSumBruteForce {\nint count = 0;\npublic int findTargetSumWays(int[] nums, int S) {\ncalculate(nums, 0, 0, S);\nreturn count;\n}\npublic void calculate(int[] nums, int i, int sum, int S) {\nif (i == nums.length) {\nif (sum == S) {\ncount++;\n}\n} else {\ncalculate(nums, i + 1, sum + nums[i], S);\ncalculate(nums, i + 1, sum - nums[i], S);\n}\n}\n}",
                        "max_stars_repo_path": "src/leetcode/problems/_494TargetSumBruteForce.java",
                        "max_stars_repo_name": "alparslansari/algorithm",
                        "max_stars_count": 0,
                        "__cluster__": 385
                },
                {
                        "shared string": " before each integer in nums and then concatenate all the integers. *   "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_538",
                        "content": "Given the `root` of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a _binary search tree_ is a tree that satisfies these constraints:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\n**Output:** \\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n**Example 2:**\n**Input:** root = \\[0,null,1\\]\n**Output:** \\[1,null,1\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-104 <= Node.val <= 104`\n*   All the values in the tree are **unique**.\n*   `root` is guaranteed to be a valid binary search tree.\n**Note:** This question is the same as 1038: [https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)\nInput:\nroot = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\nOutput:\n\\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\nclass Solution {\nint sum = 0;\npublic TreeNode convertBST(TreeNode root) {\nif (root != null) {\nconvertBST(root.right);\nsum += root.val;\nroot.val = sum;\nconvertBST(root.left);\n}\nreturn root;\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 13
                },
                {
                        "id": "pretrain_java_data_18887204",
                        "content": "<filename>Trees/ConvertBSTtoGreaterTree538.java\n// Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key\n//  of the original BST is changed to the original key plus sum of all keys greater than the original\n//  key in BST.\n// As a reminder, a binary search tree is a tree that satisfies these constraints:\n// The left subtree of a node contains only nodes with keys less than the node's key.\n// The right subtree of a node contains only nodes with keys greater than the node's key.\n// Both the left and right subtrees must also be binary search trees.\n// Note: This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\n// Example 1:\n// Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n// Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n// Example 2:\n// Input: root = [0,null,1]\n// Output: [1,null,1]\n// Example 3:\n// Input: root = [1,0,2]\n// Output: [3,3,2]\n// Example 4:\n// Input: root = [3,2,4,1]\n// Output: [7,9,4,10]\n// Constraints:\n// The number of nodes in the tree is in the range [0, 104].\n// -104 <= Node.val <= 104\n// All the values in the tree are unique.\n// root is guaranteed to be a valid binary search tree.\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int sum = 0;\npublic TreeNode convertBST(TreeNode root) {\nif(root == null) return root;\nconvertBST(root.right);\nsum += root.val;\nroot.val = sum;\nconvertBST(root.left);\nreturn root;\n}\n}",
                        "max_stars_repo_path": "Trees/ConvertBSTtoGreaterTree538.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 13
                },
                {
                        "shared string": " of a Binary Search Tree (BST), convert it to a Greater Tree such that every key "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_538",
                        "content": "Given the `root` of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a _binary search tree_ is a tree that satisfies these constraints:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\n**Output:** \\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n**Example 2:**\n**Input:** root = \\[0,null,1\\]\n**Output:** \\[1,null,1\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-104 <= Node.val <= 104`\n*   All the values in the tree are **unique**.\n*   `root` is guaranteed to be a valid binary search tree.\n**Note:** This question is the same as 1038: [https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)\nInput:\nroot = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\nOutput:\n\\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\nclass Solution {\nint sum = 0;\npublic TreeNode convertBST(TreeNode root) {\nif (root != null) {\nconvertBST(root.right);\nsum += root.val;\nroot.val = sum;\nconvertBST(root.left);\n}\nreturn root;\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 13
                },
                {
                        "id": "pretrain_java_data_18887204",
                        "content": "<filename>Trees/ConvertBSTtoGreaterTree538.java\n// Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key\n//  of the original BST is changed to the original key plus sum of all keys greater than the original\n//  key in BST.\n// As a reminder, a binary search tree is a tree that satisfies these constraints:\n// The left subtree of a node contains only nodes with keys less than the node's key.\n// The right subtree of a node contains only nodes with keys greater than the node's key.\n// Both the left and right subtrees must also be binary search trees.\n// Note: This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\n// Example 1:\n// Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n// Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n// Example 2:\n// Input: root = [0,null,1]\n// Output: [1,null,1]\n// Example 3:\n// Input: root = [1,0,2]\n// Output: [3,3,2]\n// Example 4:\n// Input: root = [3,2,4,1]\n// Output: [7,9,4,10]\n// Constraints:\n// The number of nodes in the tree is in the range [0, 104].\n// -104 <= Node.val <= 104\n// All the values in the tree are unique.\n// root is guaranteed to be a valid binary search tree.\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int sum = 0;\npublic TreeNode convertBST(TreeNode root) {\nif(root == null) return root;\nconvertBST(root.right);\nsum += root.val;\nroot.val = sum;\nconvertBST(root.left);\nreturn root;\n}\n}",
                        "max_stars_repo_path": "Trees/ConvertBSTtoGreaterTree538.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 13
                },
                {
                        "shared string": " of a Binary Search Tree (BST), convert it to a Greater Tree such that every key "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_206",
                        "content": "Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.\n**Example 1:**\n**Input:** head = \\[1,2,3,4,5\\]\n**Output:** \\[5,4,3,2,1\\]\n**Example 2:**\n**Input:** head = \\[1,2\\]\n**Output:** \\[2,1\\]\n**Example 3:**\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n**Constraints:**\n*   The number of nodes in the list is the range `[0, 5000]`.\n*   `-5000 <= Node.val <= 5000`\n**Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?\nInput:\nhead = \\[1,2,3,4,5\\]\nOutput:\n\\[5,4,3,2,1\\]\n```java\npublic class ListNode {\nint val;\nListNode next;\n}\npublic ListNode reverseList(ListNode head) {\nListNode prev = null;\nListNode current = head;\nListNode next = null;\nwhile (current != null) {\nnext = current.next;\ncurrent.next = prev;\nprev = current;\ncurrent = next;\n}\nreturn prev;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 299
                },
                {
                        "id": "pretrain_java_data_4523836",
                        "content": "<reponame>tirthbharatiya/interview_questions\n/*\nGiven the head of a singly linked list, reverse the list, and return the reversed list.\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\nExample 2:\nInput: head = [1,2]\nOutput: [2,1]\nExample 3:\nInput: head = []\nOutput: []\nConstraints:\nThe number of nodes in the list is the range [0, 5000].\n-5000 <= Node.val <= 5000\nFollow up: A linked list can be reversed either iteratively or recursively. Could you implement both?\n*/\n// Iteratively\nclass Solution {\npublic ListNode reverseList(ListNode head) {\nListNode prev = null;\nwhile(head != null) {\nListNode temp = head.next;\nhead.next = prev;\nprev = head;\nhead = temp;\n}\nreturn prev;\n}\n}",
                        "max_stars_repo_path": "LC_206_reverse_linked_list.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 299
                },
                {
                        "shared string": " A linked list can be reversed either iteratively or recursively. Could you implement both? "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_206",
                        "content": "Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.\n**Example 1:**\n**Input:** head = \\[1,2,3,4,5\\]\n**Output:** \\[5,4,3,2,1\\]\n**Example 2:**\n**Input:** head = \\[1,2\\]\n**Output:** \\[2,1\\]\n**Example 3:**\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n**Constraints:**\n*   The number of nodes in the list is the range `[0, 5000]`.\n*   `-5000 <= Node.val <= 5000`\n**Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?\nInput:\nhead = \\[1,2,3,4,5\\]\nOutput:\n\\[5,4,3,2,1\\]\n```java\npublic class ListNode {\nint val;\nListNode next;\n}\npublic ListNode reverseList(ListNode head) {\nListNode prev = null;\nListNode current = head;\nListNode next = null;\nwhile (current != null) {\nnext = current.next;\ncurrent.next = prev;\nprev = current;\ncurrent = next;\n}\nreturn prev;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 299
                },
                {
                        "id": "pretrain_java_data_4523836",
                        "content": "<reponame>tirthbharatiya/interview_questions\n/*\nGiven the head of a singly linked list, reverse the list, and return the reversed list.\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\nExample 2:\nInput: head = [1,2]\nOutput: [2,1]\nExample 3:\nInput: head = []\nOutput: []\nConstraints:\nThe number of nodes in the list is the range [0, 5000].\n-5000 <= Node.val <= 5000\nFollow up: A linked list can be reversed either iteratively or recursively. Could you implement both?\n*/\n// Iteratively\nclass Solution {\npublic ListNode reverseList(ListNode head) {\nListNode prev = null;\nwhile(head != null) {\nListNode temp = head.next;\nhead.next = prev;\nprev = head;\nhead = temp;\n}\nreturn prev;\n}\n}",
                        "max_stars_repo_path": "LC_206_reverse_linked_list.java",
                        "max_stars_repo_name": "tirthbharatiya/interview_questions",
                        "max_stars_count": 1,
                        "__cluster__": 299
                },
                {
                        "shared string": " A linked list can be reversed either iteratively or recursively. Could you implement both? "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_42",
                        "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n**Example 1:**\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n**Example 2:**\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n**Constraints:**\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\nInput:\nheight = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\nOutput:\n6\n```java\npublic int trap(int[] height) {\nint n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (left < right) {\nif (height[left] <= height[right]) {\nmaxLeft = Math.max(maxLeft, height[left]);\nwater += maxLeft - height[left];\nleft++;\n} else {\nmaxRight = Math.max(maxRight, height[right]);\nwater += maxRight - height[right];\nright--;\n}\n}\nreturn water;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "id": "pretrain_java_data_7648879",
                        "content": "<filename>leetcode/hard/trapping-rain-water/TwoPointerSolution.java\n/**\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9\nConstraints:\nn == height.length\n0 <= n <= 3 * 104\n0 <= height[i] <= 105\n*/\nclass TwoPointerSolution {\npublic int trap(int[] height) {\nint i = 0, j = height.length - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (i < j) {\nif (height[i] <= height[j]) {\n// handle for maxLeft\nmaxLeft= Math.max(maxLeft, height[i]);\nwater += maxLeft - height[i];\ni++;\n} else {\n// handle for maxRight\nmaxRight = Math.max(maxRight, height[j]);\nwater += maxRight - height[j];\nj--;\n}\n}\nreturn water;\n}\n}",
                        "max_stars_repo_path": "leetcode/hard/trapping-rain-water/TwoPointerSolution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "shared string": " non-negative integers representing an elevation map where the width of each bar is "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_42",
                        "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n**Example 1:**\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n**Example 2:**\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n**Constraints:**\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\nInput:\nheight = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\nOutput:\n6\n```java\npublic int trap(int[] height) {\nint n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (left < right) {\nif (height[left] <= height[right]) {\nmaxLeft = Math.max(maxLeft, height[left]);\nwater += maxLeft - height[left];\nleft++;\n} else {\nmaxRight = Math.max(maxRight, height[right]);\nwater += maxRight - height[right];\nright--;\n}\n}\nreturn water;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "id": "pretrain_java_data_7648879",
                        "content": "<filename>leetcode/hard/trapping-rain-water/TwoPointerSolution.java\n/**\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9\nConstraints:\nn == height.length\n0 <= n <= 3 * 104\n0 <= height[i] <= 105\n*/\nclass TwoPointerSolution {\npublic int trap(int[] height) {\nint i = 0, j = height.length - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (i < j) {\nif (height[i] <= height[j]) {\n// handle for maxLeft\nmaxLeft= Math.max(maxLeft, height[i]);\nwater += maxLeft - height[i];\ni++;\n} else {\n// handle for maxRight\nmaxRight = Math.max(maxRight, height[j]);\nwater += maxRight - height[j];\nj--;\n}\n}\nreturn water;\n}\n}",
                        "max_stars_repo_path": "leetcode/hard/trapping-rain-water/TwoPointerSolution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 237
                },
                {
                        "shared string": " non-negative integers representing an elevation map where the width of each bar is "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_15670182",
                        "content": "// Array\n// Given an array, rotate the array to the right by k steps, where k is non-negative.\n// Example 1:\n// Input: [1,2,3,4,5,6,7] and k = 3\n// Output: [5,6,7,1,2,3,4]\n// Explanation:\n// rotate 1 steps to the right: [7,1,2,3,4,5,6]\n// rotate 2 steps to the right: [6,7,1,2,3,4,5]\n// rotate 3 steps to the right: [5,6,7,1,2,3,4]\n// Example 2:\n// Input: [-1,-100,3,99] and k = 2\n// Output: [3,99,-1,-100]\n// Explanation:\n// rotate 1 steps to the right: [99,-1,-100,3]\n// rotate 2 steps to the right: [3,99,-1,-100]\n// Note:\n// Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n// Could you do it in-place with O(1) extra space?\nclass Solution {\npublic void rotate(int[] nums, int k) {\nk %= nums.length;\nreverse(nums, 0, nums.length - 1);\nreverse(nums, 0, k - 1);\nreverse(nums, k, nums.length - 1);\n}\npublic void reverse(int[] nums, int start, int end) {\nwhile (start < end) {\nint temp = nums[start];\nnums[start] = nums[end];\nnums[end] = temp;\nstart++;\nend--;\n}\n}\n}",
                        "max_stars_repo_path": "LeetCode/189 Rotate Array.java",
                        "max_stars_repo_name": "gesuwen/Algorithms",
                        "max_stars_count": 0,
                        "__cluster__": 291
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_189",
                        "content": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative.\n**Example 1:**\n**Input:** nums = \\[1,2,3,4,5,6,7\\], k = 3\n**Output:** \\[5,6,7,1,2,3,4\\]\n**Explanation:**\nrotate 1 steps to the right: \\[7,1,2,3,4,5,6\\]\nrotate 2 steps to the right: \\[6,7,1,2,3,4,5\\]\nrotate 3 steps to the right: \\[5,6,7,1,2,3,4\\]\n**Example 2:**\n**Input:** nums = \\[-1,-100,3,99\\], k = 2\n**Output:** \\[3,99,-1,-100\\]\n**Explanation:**\nrotate 1 steps to the right: \\[99,-1,-100,3\\]\nrotate 2 steps to the right: \\[3,99,-1,-100\\]\n**Constraints:**\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `0 <= k <= 105`\n**Follow up:**\n*   Try to come up with as many solutions as you can. There are at least **three** different ways to solve this problem.\n*   Could you do it in-place with `O(1)` extra space?\nInput:\nnums = \\[1,2,3,4,5,6,7\\], k = 3\nOutput:\n\\[5,6,7,1,2,3,4\\]\n```java\npublic void rotate(int[] nums, int k) {\nint n = nums.length;\nk %= n;\nreverse(nums, 0, n - 1);\nreverse(nums, 0, k - 1);\nreverse(nums, k, n - 1);\n}\nprivate void reverse(int[] nums, int start, int end) {\nwhile (start < end) {\nint temp = nums[start];\nnums[start++] = nums[end];\nnums[end--] = temp;\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 291
                },
                {
                        "shared string": ", rotate the array to the right by "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_15755213",
                        "content": "package org.enricogiurin.codingchallenges.leetcode.challenge022021;\nimport java.util.Arrays;\n/*\nGiven an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.\nReturn the shortest such subarray and output its length.\nExample 1:\nInput: nums = [2,6,4,8,10,9,15]\nOutput: 5\nExplanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 0\nExample 3:\nInput: nums = [1]\nOutput: 0\nConstraints:\n1 <= nums.length <= 104\n-105 <= nums[i] <= 105\nFollow up: Can you solve it in O(n) time complexity?\n*/\npublic class ShortestUnsortedContinuousSubarray {\n//O(N lgN)\npublic int findUnsortedSubarray(int[] nums) {\nint[] clone = nums.clone();\nArrays.sort(nums);\nint start = nums.length;\nint end = 0;\nfor (int j = 0; j < nums.length; j++) {\nif (nums[j] == clone[j]) {\ncontinue;\n}\nstart = Math.min(start, j);\nend = Math.max(end, j);\n}\nreturn end - start >= 0 ? end - start + 1 : 0;\n}\n}",
                        "max_stars_repo_path": "src/main/java/org/enricogiurin/codingchallenges/leetcode/challenge022021/ShortestUnsortedContinuousSubarray.java",
                        "max_stars_repo_name": "egch/coding-challenges",
                        "max_stars_count": 0,
                        "__cluster__": 1
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_581",
                        "content": "Given an integer array `nums`, you need to find one **continuous subarray** that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.\nReturn _the shortest such subarray and output its length_.\n**Example 1:**\n**Input:** nums = \\[2,6,4,8,10,9,15\\]\n**Output:** 5\n**Explanation:** You need to sort \\[6, 4, 8, 10, 9\\] in ascending order to make the whole array sorted in ascending order.\n**Example 2:**\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 0\n**Example 3:**\n**Input:** nums = \\[1\\]\n**Output:** 0\n**Constraints:**\n*   `1 <= nums.length <= 104`\n*   `-105 <= nums[i] <= 105`\n**Follow up:** Can you solve it in `O(n)` time complexity?\nInput:\nnums = \\[2,6,4,8,10,9,15\\]\nOutput:\n5\n```java\nimport java.util.Arrays;\npublic int findUnsortedSubarray(int[] nums) {\nint[] sortedNums = nums.clone();\nArrays.sort(sortedNums);\nint start = 0, end = nums.length - 1;\nwhile (start < nums.length && nums[start] == sortedNums[start]) start++;\nwhile (end > start && nums[end] == sortedNums[end]) end--;\nreturn end - start + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 1
                },
                {
                        "shared string": " that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_228",
                        "content": "You are given a **sorted unique** integer array `nums`.\nA **range** `[a,b]` is the set of all integers from `a` to `b` (inclusive).\nReturn _the **smallest sorted** list of ranges that **cover all the numbers in the array exactly**_. That is, each element of `nums` is covered by exactly one of the ranges, and there is no integer `x` such that `x` is in one of the ranges but not in `nums`.\nEach range `[a,b]` in the list should be output as:\n*   `\"a->b \"` if `a != b`\n*   `\"a \"` if `a == b`\n**Example 1:**\n**Input:** nums = \\[0,1,2,4,5,7\\]\n**Output:** \\[ \"0->2 \", \"4->5 \", \"7 \"\\]\n**Explanation:** The ranges are:\n\\[0,2\\] -->  \"0->2 \"\n\\[4,5\\] -->  \"4->5 \"\n\\[7,7\\] -->  \"7 \"\n**Example 2:**\n**Input:** nums = \\[0,2,3,4,6,8,9\\]\n**Output:** \\[ \"0 \", \"2->4 \", \"6 \", \"8->9 \"\\]\n**Explanation:** The ranges are:\n\\[0,0\\] -->  \"0 \"\n\\[2,4\\] -->  \"2->4 \"\n\\[6,6\\] -->  \"6 \"\n\\[8,9\\] -->  \"8->9 \"\n**Constraints:**\n*   `0 <= nums.length <= 20`\n*   `-231 <= nums[i] <= 231 - 1`\n*   All the values of `nums` are **unique**.\n*   `nums` is sorted in ascending order.\nInput:\nnums = \\[0,1,2,4,5,7\\]\nOutput:\n\\[ \"0->2 \", \"4->5 \", \"7 \"\\]\n```java\nimport java.util.ArrayList;\nimport java.util.List;\npublic List<String> findRanges(int[] nums) {\nList<String> result = new ArrayList<>();\nint n = nums.length;\nif (n == 0) return result;\nint start = nums[0];\nfor (int i = 1; i < n; i++) {\nif (nums[i] > nums[i-1] + 1) {\nif (start == nums[i-1])\nresult.add(Integer.toString(start));\nelse\nresult.add(start + \"->\" + nums[i-1]);\nstart = nums[i];\n}\n}\nif (start == nums[n-1])\nresult.add(Integer.toString(start));\nelse\nresult.add(start + \"->\" + nums[n-1]);\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 304
                },
                {
                        "id": "pretrain_java_data_1497931",
                        "content": "package com.vaani.leetcode.array;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n* 228. Summary Ranges\n* Easy\n* <p>\n* You are given a sorted unique integer array nums.\n* <p>\n* Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\n* <p>\n* Each range [a,b] in the list should be output as:\n* <p>\n* \"a->b\" if a != b\n* \"a\" if a == b\n* <p>\n* <p>\n* Example 1:\n* <p>\n* Input: nums = [0,1,2,4,5,7]\n* Output: [\"0->2\",\"4->5\",\"7\"]\n* Explanation: The ranges are:\n* [0,2] --> \"0->2\"\n* [4,5] --> \"4->5\"\n* [7,7] --> \"7\"\n* Example 2:\n* <p>\n* Input: nums = [0,2,3,4,6,8,9]\n* Output: [\"0\",\"2->4\",\"6\",\"8->9\"]\n* Explanation: The ranges are:\n* [0,0] --> \"0\"\n* [2,4] --> \"2->4\"\n* [6,6] --> \"6\"\n* [8,9] --> \"8->9\"\n* Example 3:\n* <p>\n* Input: nums = []\n* Output: []\n* Example 4:\n* <p>\n* Input: nums = [-1]\n* Output: [\"-1\"]\n* Example 5:\n* <p>\n* Input: nums = [0]\n* Output: [\"0\"]\n* <p>\n* <p>\n* Constraints:\n* <p>\n* 0 <= nums.length <= 20\n* -2^31 <= nums[i] <= 2^31 - 1\n* All the values of nums are unique.\n*/\npublic class SummaryRanges {\npublic List<String> summaryRanges(int[] nums) {\nList<String> rangeList = new ArrayList<>();\nif (nums == null || nums.length == 0) {\nreturn rangeList;\n}\nint start = nums[0];\nint end = nums[0];\nfor (int i = 0; i < nums.length - 1; i++) {\nint curNum = nums[i];\nint nextNum = nums[i + 1];\nif (nextNum - curNum == 1) {\nend++;\n} else {\nrangeList.add(rangeToString(start, end));\nstart = nextNum;\nend = nextNum;\n}\n}\nrangeList.add(rangeToString(start, end));\nreturn rangeList;\n}\npublic String rangeToString(int start, int end) {\nreturn Integer.toString(start) + (start != end ? \"->\" + end : \"\");\n}\n}",
                        "max_stars_repo_path": "java/leetcode/src/main/java/com/vaani/leetcode/array/SummaryRanges.java",
                        "max_stars_repo_name": "kinshuk4/leetcode-solutions",
                        "max_stars_count": 1,
                        "__cluster__": 304
                },
                {
                        "shared string": " is covered by exactly one of the ranges, and there is no integer "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_19026002",
                        "content": "/*\nhttps://leetcode.com/problems/missing-number/\nGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nFollow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?\nExample 1:\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\nExample 2:\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\nExample 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\nExample 4:\nInput: nums = [0]\nOutput: 1\nExplanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.\nConstraints:\nn == nums.length\n1 <= n <= 104\n0 <= nums[i] <= n\nAll the numbers of nums are unique\n*/\nclass Solution {\npublic int missingNumber(int[] nums) {\nint n = nums.length;\nint sum = n * (n + 1) / 2;\nint numSum = 0;\nfor (int num : nums) {\nnumSum += num;\n}\nreturn sum - numSum;\n}\n}",
                        "max_stars_repo_path": "leetcode/p0268/Solution.java",
                        "max_stars_repo_name": "suhwanhwang/problem-solving",
                        "max_stars_count": 0,
                        "__cluster__": 325
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_268",
                        "content": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._\n**Example 1:**\n**Input:** nums = \\[3,0,1\\]\n**Output:** 2\n**Explanation:** n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums.\n**Example 2:**\n**Input:** nums = \\[0,1\\]\n**Output:** 2\n**Explanation:** n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums.\n**Example 3:**\n**Input:** nums = \\[9,6,4,2,3,5,7,0,1\\]\n**Output:** 8\n**Explanation:** n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums.\n**Constraints:**\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `0 <= nums[i] <= n`\n*   All the numbers of `nums` are **unique**.\n**Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?\nInput:\nnums = \\[3,0,1\\]\nOutput:\n2\n```java\npublic int missingNumber(int[] nums) {\nint n = nums.length;\nint expectedSum = (n * (n + 1)) / 2;\nint actualSum = 0;\nfor (int num : nums) {\nactualSum += num;\n}\nreturn expectedSum - actualSum;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 325
                },
                {
                        "shared string": "]. 2 is the missing number in the range since it does not appear in nums. "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_462",
                        "content": "Given an integer array `nums` of size `n`, return _the minimum number of moves required to make all array elements equal_.\nIn one move, you can increment or decrement an element of the array by `1`.\nTest cases are designed so that the answer will fit in a **32-bit** integer.\n**Example 1:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 2\n**Explanation:**\nOnly two moves are needed (remember each move increments or decrements one element):\n\\[1,2,3\\]  =>  \\[2,2,3\\]  =>  \\[2,2,2\\]\n**Example 2:**\n**Input:** nums = \\[1,10,2,9\\]\n**Output:** 16\n**Constraints:**\n*   `n == nums.length`\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\nInput:\nnums = \\[1,2,3\\]\nOutput:\n2\n```java\npublic int minMoves2(int[] nums) {\nArrays.sort(nums);\nint mid = nums[nums.length / 2];\nint moves = 0;\nfor (int num : nums) {\nmoves += Math.abs(num - mid);\n}\nreturn moves;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 378
                },
                {
                        "id": "pretrain_java_data_12632553",
                        "content": "<reponame>devangi2000/Data-Structures-Algorithms-Handbook\n// Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\n// In one move, you can increment or decrement an element of the array by 1.\n// Test cases are designed so that the answer will fit in a 32-bit integer.\n// Example 1:\n// Input: nums = [1,2,3]\n// Output: 2\n// Explanation:\n// Only two moves are needed (remember each move increments or decrements one element):\n// [1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n// Example 2:\n// Input: nums = [1,10,2,9]\n// Output: 16\n// Constraints:\n// n == nums.length\n// 1 <= nums.length <= 105\n// -109 <= nums[i] <= 109\nclass Solution {\npublic int minMoves2(int[] nums) {\nint i = 0, count = 0, j = nums.length - 1;\nArrays.sort(nums);\nwhile(i < j)\ncount += nums[j--] - nums[i++];\nreturn count;\n}\n}",
                        "max_stars_repo_path": "Arrays/MinimumMovestoEqualArrayElementsII472.java",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38,
                        "__cluster__": 378
                },
                {
                        "shared string": " Only two moves are needed (remember each move increments or decrements one element): "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_230",
                        "content": "Given the `root` of a binary search tree, and an integer `k`, return _the_ `kth` _smallest value (**1-indexed**) of all the values of the nodes in the tree_.\n**Example 1:**\n**Input:** root = \\[3,1,4,null,2\\], k = 1\n**Output:** 1\n**Example 2:**\n**Input:** root = \\[5,3,6,2,4,null,null,1\\], k = 3\n**Output:** 3\n**Constraints:**\n*   The number of nodes in the tree is `n`.\n*   `1 <= k <= n <= 104`\n*   `0 <= Node.val <= 104`\n**Follow up:** If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?\nInput:\nroot = \\[3,1,4,null,2\\], k = 1\nOutput:\n1\n```java\npublic class TreeNode {\nint val;\nTreeNode left;\nTreeNode right;\nTreeNode(int x) { val = x; }\n}\npublic int kthSmallest(TreeNode root, int k) {\nStack<TreeNode> stk = new Stack<>();\nTreeNode curr = root;\nwhile (true) {\nwhile (curr != null) {\nstk.push(curr);\ncurr = curr.left;\n}\ncurr = stk.pop();\nif (--k == 0) return curr.val;\ncurr = curr.right;\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 12
                },
                {
                        "id": "pretrain_java_data_12764178",
                        "content": "/*\n* @author <NAME>, <EMAIL>\n*/\npackage com.omtia.un;\nimport com.omtia.utils.TreeNode;\nimport java.util.LinkedList;\n/**\n* Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values\n* of the nodes in the tree.\n*\n*\n*\n* Example 1:\n*\n*\n* Input: root = [3,1,4,null,2], k = 1\n* Output: 1\n* Example 2:\n*\n*\n* Input: root = [5,3,6,2,4,null,null,1], k = 3\n* Output: 3\n*\n*\n* Constraints:\n*\n* The number of nodes in the tree is n.\n* 1 <= k <= n <= 104\n* 0 <= Node.val <= 104\n*\n*\n* Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth\n* smallest frequently, how would you optimize?\n*/\npublic class _230_Kth_smallest_element_in_BST {\npublic int kthSmallest(TreeNode root, int k) {\nLinkedList<TreeNode> l = new LinkedList<TreeNode>();\nTreeNode curr = root;\nwhile(!l.isEmpty() || curr != null) {\nif(curr!=null) {\nl.push(curr);\ncurr = curr.left;\n} else {\ncurr = l.pop();\nk--;\nif(k == 0) return curr.val;\ncurr = curr.right;\n}\n}\nreturn -1;\n}\n}",
                        "max_stars_repo_path": "src/main/java/com/omtia/un/_230_Kth_smallest_element_in_BST.java",
                        "max_stars_repo_name": "Andreii/algo",
                        "max_stars_count": 0,
                        "__cluster__": 12
                },
                {
                        "shared string": " of a binary search tree, and an integer "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_14214810",
                        "content": "package pers.tavish.leetcode.easy;\nimport java.util.HashMap;\nimport java.util.Map;\n/**\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\nExample 1:\nInput: s = \"III\"\nOutput: 3\nExample 2:\nInput: s = \"IV\"\nOutput: 4\nExample 3:\nInput: s = \"IX\"\nOutput: 9\nExample 4:\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 5:\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\nConstraints:\n- 1 <= s.length <= 15\n- bs contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n- It is guaranteed that s is a valid roman numeral in the range [1, 3999].\nfor more information: https://leetcode.com/problems/roman-to-integer/\n*/\npublic class Roman2Integer {\nprivate static final Map<Character, Integer> MAP;\nstatic {\nMAP = new HashMap<>();\nMAP.put('I', 1);\nMAP.put('V', 5);\nMAP.put('X', 10);\nMAP.put('L', 50);\nMAP.put('C', 100);\nMAP.put('D', 500);\nMAP.put('M', 1000);\n}\npublic int romanToInt(String s) {\nint len = s.length() - 1;\nint sum = MAP.get(s.charAt(len--));\nwhile (len >= 0) {\nchar cur = s.charAt(len);\nchar next = s.charAt(len + 1);\nif (cur == 'I' && (next == 'V' || next == 'X')) {\nsum -= MAP.get(cur);\n} else if (cur == 'X' && (next == 'L' || next == 'C')) {\nsum -= MAP.get(cur);\n} else if (cur == 'C' && (next == 'D' || next == 'M')) {\nsum -= MAP.get(cur);\n} else {\nsum += MAP.get(cur);\n}\nlen--;\n}\nreturn sum;\n}\n}",
                        "max_stars_repo_path": "src/main/java/pers/tavish/leetcode/easy/Roman2Integer.java",
                        "max_stars_repo_name": "Tavi3h/LeetCode_3rd",
                        "max_stars_count": 0,
                        "__cluster__": 215
                },
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_13",
                        "content": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n**Example 1:**\n**Input:** s =  \"III \"\n**Output:** 3\n**Explanation:** III = 3.\n**Example 2:**\n**Input:** s =  \"LVIII \"\n**Output:** 58\n**Explanation:** L = 50, V= 5, III = 3.\n**Example 3:**\n**Input:** s =  \"MCMXCIV \"\n**Output:** 1994\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4.\n**Constraints:**\n*   `1 <= s.length <= 15`\n*   `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.\n*   It is **guaranteed** that `s` is a valid roman numeral in the range `[1, 3999]`.\nInput:\ns =  \"III \"\nOutput:\n3\n```java\npublic int romanToInt(String s) {\nMap<Character, Integer> romanValues = new HashMap<>();\nromanValues.put('I', 1);\nromanValues.put('V', 5);\nromanValues.put('X', 10);\nromanValues.put('L', 50);\nromanValues.put('C', 100);\nromanValues.put('D', 500);\nromanValues.put('M', 1000);\nint total = 0;\nint prevValue = 0;\nfor (char c : s.toCharArray()) {\nint currValue = romanValues.get(c);\ntotal += currValue > prevValue ? currValue - 2 * prevValue : currValue;\nprevValue = currValue;\n}\nreturn total;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 215
                },
                {
                        "shared string": " I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_15852924",
                        "content": "<filename>leetcode/medium/house-robber/Solution.java\n/**\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n*/\nclass Solution {\npublic int rob(int[] nums) {\nint rob1 = 0, rob2 = 0;\nfor(int n: nums) {\nint newRob = Math.max(n + rob1, rob2);\nrob1 = rob2;\nrob2 = newRob;\n}\nreturn rob2;\n}\n}",
                        "max_stars_repo_path": "leetcode/medium/house-robber/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_15852924",
                        "content": "<filename>leetcode/medium/house-robber/Solution.java\n/**\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n*/\nclass Solution {\npublic int rob(int[] nums) {\nint rob1 = 0, rob2 = 0;\nfor(int n: nums) {\nint newRob = Math.max(n + rob1, rob2);\nrob1 = rob2;\nrob2 = newRob;\n}\nreturn rob2;\n}\n}",
                        "max_stars_repo_path": "leetcode/medium/house-robber/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and "
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_java_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```java\npublic int rob(int[] nums) {\nint prev1 = 0, prev2 = 0;\nfor (int num : nums) {\nint temp = prev1;\nprev1 = Math.max(prev2 + num, prev1);\nprev2 = temp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "id": "pretrain_java_data_15852924",
                        "content": "<filename>leetcode/medium/house-robber/Solution.java\n/**\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n*/\nclass Solution {\npublic int rob(int[] nums) {\nint rob1 = 0, rob2 = 0;\nfor(int n: nums) {\nint newRob = Math.max(n + rob1, rob2);\nrob1 = rob2;\nrob2 = newRob;\n}\nreturn rob2;\n}\n}",
                        "max_stars_repo_path": "leetcode/medium/house-robber/Solution.java",
                        "max_stars_repo_name": "naddym/competitive-programming",
                        "max_stars_count": 0,
                        "__cluster__": 296
                },
                {
                        "shared string": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and "
                },
                {
                        "real_dup": "2"
                }
        ]
]