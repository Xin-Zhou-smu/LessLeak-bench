[
        {
                "data_len": 90
        },

        [
                {
                        "id": "pretrain_c_data_88408",
                        "content": "#pragma once\n/*\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample:\nInput:\n[\n[1,3,1],\n[1,5,1],\n[4,2,1]\n]\nOutput: 7\nExplanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n*/\nclass Solution {\npublic:\nint minPathSum(vector<vector<int>>& grid) {\nint rows = grid.size(), columns = grid.empty() ?  0 : grid[0].size();\nif (rows == 0 || columns == 0)\nreturn 0;\n// Initialize the base case\nfor (int c = 1; c < columns; c++)\ngrid[0][c] += grid[0][c-1];\nfor (int r = 1; r < rows; r++) {\ngrid[r][0] += grid[r - 1][0];\nfor (int c = 1; c < columns; c++) {\ngrid[r][c] += min(grid[r][c - 1], grid[r - 1][c]);\n}\n}\nreturn grid[rows - 1][columns - 1];\n}\n};",
                        "max_stars_repo_name": "saidinesh5/30-day-leetcode-challenge-april-2020",
                        "max_stars_count": 1.0,
                        "max_stars_repo_path": "day18.h",
                        "__cluster__": 323
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```cpp\nint minPathSum(vector<vector<int>>& grid) {\nint m = grid.size(), n = grid[0].size();\nfor(int i = 1; i < m; i++)\ngrid[i][0] += grid[i - 1][0];\nfor(int i = 1; i < n; i++)\ngrid[0][i] += grid[0][i - 1];\nfor(int i = 1; i < m; i++){\nfor(int j = 1; j < n; j++){\ngrid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n}\n}\nreturn grid[m - 1][n - 1];\n}\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 323
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_142",
                        "content": "Given the `head` of a linked list, return _the node where the cycle begins. If there is no cycle, return_ `null`.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to (**0-indexed**). It is `-1` if there is no cycle. **Note that** `pos` **is not passed as a parameter**.\n**Do not modify** the linked list.\n**Example 1:**\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** tail connects to node index 1\n**Explanation:** There is a cycle in the linked list, where tail connects to the second node.\n**Example 2:**\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** tail connects to node index 0\n**Explanation:** There is a cycle in the linked list, where tail connects to the first node.\n**Example 3:**\n**Input:** head = \\[1\\], pos = -1\n**Output:** no cycle\n**Explanation:** There is no cycle in the linked list.\n**Constraints:**\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?\nInput:\nhead = \\[3,2,0,-4\\], pos = 1\nOutput:\ntail connects to node index 1\n```cpp\nclass ListNode {\npublic:\nint val;\nListNode* next;\n};\nListNode* detectCycle(ListNode* head) {\nListNode* slow = head;\nListNode* fast = head;\nwhile (fast != nullptr && fast->next != nullptr) {\nslow = slow->next;\nfast = fast->next->next;\nif (slow == fast) {\nListNode* start = head;\nwhile (start != slow) {\nstart = start->next;\nslow = slow->next;\n}\nreturn start;\n}\n}\nreturn nullptr;\n}\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 357
                },
                {
                        "id": "pretrain_c_data_2462237",
                        "content": "// Given the head of a linked list, return the node where the cycle begins.\n// If there is no cycle, return null.\n// There is a cycle in a linked list if there is some node in the list\n// that can be reached again by continuously following the next pointer.\n// Internally, pos is used to denote the index of the node that tail's\n// next pointer is connected to (0-indexed). It is -1 if there is no cycle.\n//  Note that pos is not passed as a parameter.\n// Do not modify the linked list.\n// Example 1:\n// Input: head = [3,2,0,-4], pos = 1\n// Output: tail connects to node index 1\n// Explanation: There is a cycle in the linked list,\n// where tail connects to the second node.\n// Example 2:\n// Input: head = [1,2], pos = 0\n// Output: tail connects to node index 0\n// Explanation: There is a cycle in the linked list,\n// where tail connects to the first node.\n// Example 3:\n// Input: head = [1], pos = -1\n// Output: no cycle\n// Explanation: There is no cycle in the linked list.\n// Constraints:\n// The number of the nodes in the list is in the range [0, 10 4cifang].\n// -105 <= Node.val <= 10 5 cifang\n// pos is -1 or a valid index in the linked-list.\n// Follow up: Can you solve it using O(1) (i.e. constant) memory?\n// \u5bf9\u4e8e\u94fe\u8868\u627e\u73af\u8def\u7684\u95ee\u9898\uff0c\u6709\u4e00\u4e2a\u901a\u7528\u7684\u89e3\u6cd5\u2014\u2014\u5feb\u6162\u6307\u9488\uff08Floyd \u5224\u5708\u6cd5\uff09\u3002\n#pragma once\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// Definition for singly-linked list.\nstruct ListNode\n{\nint val;\nListNode *next;\nListNode(int x) : val(x), next(NULL) {}\n};\nclass Solution\n{\npublic:\nListNode *detectCycle(ListNode *head)\n{\nListNode* fast_ptr = head;\nListNode* slow_ptr = head;\ndo\n{\nif(fast_ptr == nullptr || fast_ptr -> next == nullptr)\n{\nreturn nullptr;\n}\nfast_ptr = fast_ptr -> next -> next;\nslow_ptr = slow_ptr -> next;\n} while(fast_ptr != slow_ptr);\nfast_ptr = head;\nwhile(fast_ptr != slow_ptr)\n{\nfast_ptr = fast_ptr -> next;\nslow_ptr = slow_ptr -> next;\n}\nreturn fast_ptr;\n}\n};\n",
                        "max_stars_repo_name": "forwardkth/leetcode",
                        "max_stars_count": 1.0,
                        "max_stars_repo_path": "first_round/medium/include/linked_list_cycle_II_142.h",
                        "__cluster__": 357
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_1161",
                        "content": "Given the `root` of a binary tree, the level of its root is `1`, the level of its children is `2`, and so on.\nReturn the **smallest** level `x` such that the sum of all the values of nodes at level `x` is **maximal**.\n**Example 1:**\n**Input:** root = \\[1,7,0,7,-8,null,null\\]\n**Output:** 2\n**Explanation:**\nLevel 1 sum = 1.\nLevel 2 sum = 7 + 0 = 7.\nLevel 3 sum = 7 + -8 = -1.\nSo we return the level with the maximum sum which is level 2.\n**Example 2:**\n**Input:** root = \\[989,null,10250,98693,-89388,null,null,null,-32127\\]\n**Output:** 2\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-105 <= Node.val <= 105`\nInput:\nroot = \\[1,7,0,7,-8,null,null\\]\nOutput:\n2\n```cpp\n#include <queue>\nclass TreeNode {\npublic:\nint val;\nTreeNode* left;\nTreeNode* right;\nTreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nint maxLevelSum(TreeNode* root) {\nif (!root) return 0;\nstd::queue<TreeNode*> q;\nq.push(root);\nint level = 0, max_sum = INT_MIN, result_level;\nwhile (!q.empty()) {\nint count = q.size();\nint sum = 0;\nlevel++;\nwhile (count--) {\nTreeNode* temp = q.front(); q.pop();\nsum += temp->val;\nif (temp->left) q.push(temp->left);\nif (temp->right) q.push(temp->right);\n}\nif (sum > max_sum) {\nmax_sum = sum;\nresult_level = level;\n}\n}\nreturn result_level;\n}\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 27
                },
                {
                        "id": "pretrain_c_data_5887079",
                        "content": "#pragma once\n#include <../treenode.h>\n#include <queue>\nnamespace Leet::Medium {\n// Given the root of a binary tree, the level of its root is 1, the level\n// of its children is 2, and so on. Return the smallest level X such that\n// the sum of all the values of nodes at level X is maximal.\n// Example 1:\n// Input: root = [1,7,0,7,-8,null,null]\n// Output: 2\n// Explanation:\n// Level 1 sum = 1.\n// Level 2 sum = 7 + 0 = 7.\n// Level 3 sum = 7 + -8 = -1.\n// So we return the level with the maximum sum which is level 2.\n// Example 2:\n// Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]\n// Output: 2\n// Constraints:\n// The number of nodes in the tree is in the range [1, 104].\n// -105 <= Node.val <= 105\nstruct\n{\nint maxLevelSum(Leet::TreeNode* root)\n{\nauto q = std::queue<Leet::TreeNode*>{};\nint max_level = 1;\nint max_sum = root->val;\nq.push(root->left);\nq.push(root->right);\nint temp = 0;\nint len = 0;\nint level = 1;\nwhile (!q.empty()) {\nlen = q.size();\ntemp = 0;\nlevel++;\nfor (int i = 0; i < len; i++) {\nauto child = q.front();\nq.pop();\nif (child) {\ntemp += child->val;\nif (child->left) q.push(child->left);\nif (child->right) q.push(child->right);\n}\n}\nif (temp > max_sum) {\nmax_sum = temp;\nmax_level = level;\n}\n}\nreturn max_level;\n}\n};\n}  // namespace Leet::Medium",
                        "max_stars_repo_name": "nexes/leetcode",
                        "max_stars_count": 1.0,
                        "max_stars_repo_path": "include/medium/max_level_sum_binary.h",
                        "__cluster__": 27
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_1161",
                        "content": "Given the `root` of a binary tree, the level of its root is `1`, the level of its children is `2`, and so on.\nReturn the **smallest** level `x` such that the sum of all the values of nodes at level `x` is **maximal**.\n**Example 1:**\n**Input:** root = \\[1,7,0,7,-8,null,null\\]\n**Output:** 2\n**Explanation:**\nLevel 1 sum = 1.\nLevel 2 sum = 7 + 0 = 7.\nLevel 3 sum = 7 + -8 = -1.\nSo we return the level with the maximum sum which is level 2.\n**Example 2:**\n**Input:** root = \\[989,null,10250,98693,-89388,null,null,null,-32127\\]\n**Output:** 2\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-105 <= Node.val <= 105`\nInput:\nroot = \\[1,7,0,7,-8,null,null\\]\nOutput:\n2\n```cpp\n#include <queue>\nclass TreeNode {\npublic:\nint val;\nTreeNode* left;\nTreeNode* right;\nTreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nint maxLevelSum(TreeNode* root) {\nif (!root) return 0;\nstd::queue<TreeNode*> q;\nq.push(root);\nint level = 0, max_sum = INT_MIN, result_level;\nwhile (!q.empty()) {\nint count = q.size();\nint sum = 0;\nlevel++;\nwhile (count--) {\nTreeNode* temp = q.front(); q.pop();\nsum += temp->val;\nif (temp->left) q.push(temp->left);\nif (temp->right) q.push(temp->right);\n}\nif (sum > max_sum) {\nmax_sum = sum;\nresult_level = level;\n}\n}\nreturn result_level;\n}\n```",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_path": "NA",
                        "__cluster__": 27
                },
                {
                        "id": "pretrain_c_data_5887079",
                        "content": "#pragma once\n#include <../treenode.h>\n#include <queue>\nnamespace Leet::Medium {\n// Given the root of a binary tree, the level of its root is 1, the level\n// of its children is 2, and so on. Return the smallest level X such that\n// the sum of all the values of nodes at level X is maximal.\n// Example 1:\n// Input: root = [1,7,0,7,-8,null,null]\n// Output: 2\n// Explanation:\n// Level 1 sum = 1.\n// Level 2 sum = 7 + 0 = 7.\n// Level 3 sum = 7 + -8 = -1.\n// So we return the level with the maximum sum which is level 2.\n// Example 2:\n// Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]\n// Output: 2\n// Constraints:\n// The number of nodes in the tree is in the range [1, 104].\n// -105 <= Node.val <= 105\nstruct\n{\nint maxLevelSum(Leet::TreeNode* root)\n{\nauto q = std::queue<Leet::TreeNode*>{};\nint max_level = 1;\nint max_sum = root->val;\nq.push(root->left);\nq.push(root->right);\nint temp = 0;\nint len = 0;\nint level = 1;\nwhile (!q.empty()) {\nlen = q.size();\ntemp = 0;\nlevel++;\nfor (int i = 0; i < len; i++) {\nauto child = q.front();\nq.pop();\nif (child) {\ntemp += child->val;\nif (child->left) q.push(child->left);\nif (child->right) q.push(child->right);\n}\n}\nif (temp > max_sum) {\nmax_sum = temp;\nmax_level = level;\n}\n}\nreturn max_level;\n}\n};\n}  // namespace Leet::Medium",
                        "max_stars_repo_name": "nexes/leetcode",
                        "max_stars_count": 1.0,
                        "max_stars_repo_path": "include/medium/max_level_sum_binary.h",
                        "__cluster__": 27
                },
                {
                        "real_dup": "2"
                }
        ],

        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_714",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n**Example 1:**\n**Input:** prices = \\[1,3,2,8,4,9\\], fee = 2\n**Output:** 8\n**Explanation:** The maximum profit can be achieved by:\n- Buying at prices\\[0\\] = 1\n- Selling at prices\\[3\\] = 8\n- Buying at prices\\[4\\] = 4\n- Selling at prices\\[5\\] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n**Example 2:**\n**Input:** prices = \\[1,3,7,5,10,3\\], fee = 3\n**Output:** 6\n**Constraints:**\n*   `1 <= prices.length <= 5 * 104`\n*   `1 <= prices[i] < 5 * 104`\n*   `0 <= fee < 5 * 104`\nInput:\nprices = \\[1,3,2,8,4,9\\], fee = 2\nOutput:\n8\n```cpp\nint maxProfit(vector<int>& prices, int fee) {\nint cash = 0, hold = -prices[0];\nfor (int price : prices) {\nint temp = cash;\ncash = max(cash, hold + price - fee);\nhold = max(hold, temp - price);\n}\nreturn cash;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 500
                },
                {
                        "id": "pretrain_cpp_data_2425575",
                        "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [1,3,2,8,4,9], fee = 2\nOutput: 8\nExplanation: The maximum profit can be achieved by:\n- Buying at prices[0] = 1\n- Selling at prices[3] = 8\n- Buying at prices[4] = 4\n- Selling at prices[5] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\nclass Solution {\npublic:\nint maxProfit(vector<int>& prices, int fee) {\nif(prices.size() == 0){\nreturn 0;\n}\nvector<vector<int>> dp(prices.size(), vector<int>(2, 0));\ndp[0][0] = -prices[0];\nfor(int i = 1; i < prices.size(); i++){\ndp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\ndp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);\n}\nreturn max(dp[prices.size() - 1][0], dp[prices.size() - 1][1]);\n}\n};",
                        "max_stars_repo_path": "dynamic programming/714. Best Time to Buy and Sell Stock with Transaction Fee.cpp",
                        "max_stars_repo_name": "Constantine-L01/leetcode",
                        "max_stars_count": 1.0,
                        "__cluster__": 500
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_509",
                        "content": "The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\nGiven `n`, calculate `F(n)`.\n**Example 1:**\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.\n**Example 2:**\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.\n**Example 3:**\n**Input:** n = 4\n**Output:** 3\n**Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3.\n**Constraints:**\n*   `0 <= n <= 30`\nInput:\nn = 2\nOutput:\n1\n```cpp\nint fib(int n) {\nif(n < 2) {\nreturn n;\n}\nint a = 0, b = 1, c;\nfor(int i = 2; i <= n; ++i) {\nc = a + b;\na = b;\nb = c;\n}\nreturn b;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 464
                },
                {
                        "id": "pretrain_cpp_data_2415848",
                        "content": "// Source : https://leetcode.com/problems/fibonacci-number/\n// Author : henrytien\n// Date   : 2021-08-08\n/*****************************************************************************************************\n*\n* The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such\n* that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n*\n* F(0) = 0, F(1) = 1\n* F(n) = F(n - 1) + F(n - 2), for n > 1.\n*\n* Given n, calculate F(n).\n*\n* Example 1:\n*\n* Input: n = 2\n* Output: 1\n* Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\n*\n* Example 2:\n*\n* Input: n = 3\n* Output: 2\n* Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\n*\n* Example 3:\n*\n* Input: n = 4\n* Output: 3\n* Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\n*\n* Constraints:\n*\n* \t0 <= n <= 30\n******************************************************************************************************/\nclass Solution {\npublic:\nint fib(int n) {\nif (n == 0 || n == 1)\nreturn n;\nint a = 0, b = 1, c = 0;\nfor(int i = 1; i < n; i++) {\nc = a + b;\na = b;\nb = c;\n}\nreturn c;\n}\n};\n",
                        "max_stars_repo_path": "leetcode/509.fibonacci_number/509.FibonacciNumber_henrytien.cpp",
                        "max_stars_repo_name": "henrytien/AlgorithmSolutions",
                        "max_stars_count": 15.0,
                        "__cluster__": 464
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_2498474",
                        "content": "// Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right,\n// which minimizes the sum of all numbers along its path.\n// Note: You can only move either down or right at any point in time.\n// Example 1:\n// Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n// Output: 7\n// Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n// Example 2:\n// Input: grid = [[1,2,3],[4,5,6]]\n// Output: 12\n// Constraints:\n// m == grid.length\n// n == grid[i].length\n// 1 <= m, n <= 200\n// 0 <= grid[i][j] <= 100\nclass Solution {\npublic:\nint minPathSum(vector<vector<int>>& grid) {\nint n = grid.size(), m = grid[0].size();\nvector<vector<int>> dp(n, vector<int>(m));\ndp[0][0] = grid[0][0];\nfor(int i=0; i<n; i++){\nfor(int j=0; j<m; j++){\nif(i==0 and j==0) continue;\nelse if(i==0) dp[i][j] = grid[i][j] + dp[i][j-1];\nelse if(j==0) dp[i][j] = grid[i][j] + dp[i-1][j];\nelse dp[i][j] = grid[i][j] + min(dp[i][j-1], dp[i-1][j]);\n}\n}\nreturn dp[n-1][m-1];\n}\n};",
                        "max_stars_repo_path": "Dynamic Programming/Minimum-Path-Sum-64.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 323
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```cpp\nint minPathSum(vector<vector<int>>& grid) {\nint m = grid.size(), n = grid[0].size();\nfor(int i = 1; i < m; i++)\ngrid[i][0] += grid[i - 1][0];\nfor(int i = 1; i < n; i++)\ngrid[0][i] += grid[0][i - 1];\nfor(int i = 1; i < m; i++){\nfor(int j = 1; j < n; j++){\ngrid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n}\n}\nreturn grid[m - 1][n - 1];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 323
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_4020656",
                        "content": "// You are a professional robber planning to rob houses along a street. Each house has a certain amount\n//  of money stashed. All houses at this place are arranged in a circle. That means the first house is\n// the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will\n//  automatically contact the police if two adjacent houses were broken into on the same night.\n// Given an integer array nums representing the amount of money of each house, return the maximum\n// amount of money you can rob tonight without alerting the police.\n// Example 1:\n// Input: nums = [2,3,2]\n// Output: 3\n// Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n// Example 2:\n// Input: nums = [1,2,3,1]\n// Output: 4\n// Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n// Total amount you can rob = 1 + 3 = 4.\n// Example 3:\n// Input: nums = [1,2,3]\n// Output: 3\n// Constraints:\n// 1 <= nums.length <= 100\n// 0 <= nums[i] <= 1000\nclass Solution {\npublic:\nint rob(vector<int>& nums) {\nint n = nums.size();\nif(n == 0) return 0;\nif(n == 1) return nums[0];\n// don't include house 0\nint preMax = 0, curMax = 0;\nfor(int i = 1; i < n; i++){\nint t = curMax;\ncurMax = max(curMax, preMax + nums[i]);\npreMax = t;\n}\n// don't include house n-1\nint premax1 = 0, curmax1 = 0;\nfor(int i = 0; i < n-1; i++){\nint t = curmax1;\ncurmax1 = max(curmax1, nums[i] + premax1);\npremax1 = t;\n}\nreturn max(curMax, curmax1);\n}\n};\n",
                        "max_stars_repo_path": "Dynamic Programming/House-Robber-2-213.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 381
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```cpp\nint rob(vector<int>& nums) {\nif (nums.size() == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.size() - 1; i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.size(); i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 381
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_5642747",
                        "content": "<filename>cpp/Add Two Numbers.cpp\n/*\n2. Add Two Numbers\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n*/\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nint carry = 0;\nint x, y;\n(l1 != NULL) ? x = l1->val : x = 0;\n(l2 != NULL) ? y = l2->val : y = 0;\nint sum = carry + x + y;\ncarry = sum/10;\nauto root = new ListNode(sum%10);\nauto temp = root;\nl1 = l1->next;\nl2 = l2->next;\n// Now traverse both the linked lists and add to result linked list i.e. root\nwhile(l1 != NULL || l2 != NULL) {\n(l1 != NULL) ? x = l1->val : x = 0;\n(l2 != NULL) ? y = l2->val : y = 0;\nsum = carry + x + y;\ncarry = sum/10;\ntemp->next = new ListNode(sum%10);\ntemp = temp->next;\nif (l1 != NULL) l1 = l1->next;\nif (l2 != NULL) l2 = l2->next;\n}\nif (carry != 0) temp->next = new ListNode(carry);\nreturn root;\n}\n};",
                        "max_stars_repo_path": "cpp/Add Two Numbers.cpp",
                        "max_stars_repo_name": "vishnureddys/leetcode",
                        "max_stars_count": 0.0,
                        "__cluster__": 292
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```cpp\nstruct ListNode {\nint val;\nListNode *next;\nListNode(int x) : val(x), next(nullptr) {}\n};\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nListNode dummy(0);\nListNode* current = &dummy;\nint carry = 0;\nwhile (l1 || l2 || carry) {\nint sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\ncarry = sum / 10;\ncurrent->next = new ListNode(sum % 10);\ncurrent = current->next;\nif (l1) l1 = l1->next;\nif (l2) l2 = l2->next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 292
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_5629171",
                        "content": "<filename>leetcode/top_interview_questions/medium/linked_lists/1.cpp\n#include <iostream>\nusing namespace std;\n/*\nQ: Add Two Numbers\nYou are given two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order, and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation:\n342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n*/\nstruct ListNode\n{\nint val;\nListNode *next;\nListNode() : val(0), next(nullptr) {}\nListNode(int x) : val(x), next(nullptr) {}\nListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nclass Solution\n{\nprivate:\nvoid addNodes(int val1, int val2, int& carry, ListNode*& node)\n{\nint sum = val1 + val2 + carry;\ncarry = sum / 10;\nif(node == nullptr)\n{\nnode = new ListNode(sum % 10);\n}\nelse\n{\nnode->next = new ListNode(sum % 10);\nnode = node->next;\n}\n}\npublic:\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2)\n{\nint carry = 0;\nListNode* ans = nullptr;\nListNode* node = nullptr;\nwhile(l1 != nullptr && l2 != nullptr)\n{\naddNodes(l1->val, l2->val, carry, node);\nif(ans == nullptr)\n{\nans = node;\n}\nl1 = l1->next;\nl2 = l2->next;\n}\nwhile(l1 != nullptr)\n{\naddNodes(l1->val, 0, carry, node);\nif(ans == nullptr)\n{\nans = node;\n}\nl1 = l1->next;\n}\nwhile(l2 != nullptr)\n{\naddNodes(l2->val, 0, carry, node);\nif(ans == nullptr)\n{\nans = node;\n}\nl2 = l2->next;\n}\nif(carry > 0)\n{\naddNodes(0, 0, carry, node);\n}\nreturn ans;\n}\n};",
                        "max_stars_repo_path": "leetcode/top_interview_questions/medium/linked_lists/1.cpp",
                        "max_stars_repo_name": "bvbasavaraju/competitive_programming",
                        "max_stars_count": 1.0,
                        "__cluster__": 292
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```cpp\nstruct ListNode {\nint val;\nListNode *next;\nListNode(int x) : val(x), next(nullptr) {}\n};\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nListNode dummy(0);\nListNode* current = &dummy;\nint carry = 0;\nwhile (l1 || l2 || carry) {\nint sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\ncarry = sum / 10;\ncurrent->next = new ListNode(sum % 10);\ncurrent = current->next;\nif (l1) l1 = l1->next;\nif (l2) l2 = l2->next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 292
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_1722745",
                        "content": "<filename>Math/ugly-number.cpp\n// An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n// Given an integer n, return true if n is an ugly number.\n// Example 1:\n// Input: n = 6\n// Output: true\n// Explanation: 6 = 2 \u00d7 3\n// Example 2:\n// Input: n = 8\n// Output: true\n// Explanation: 8 = 2 \u00d7 2 \u00d7 2\n// Example 3:\n// Input: n = 14\n// Output: false\n// Explanation: 14 is not ugly since it includes the prime factor 7.\n// Example 4:\n// Input: n = 1\n// Output: true\n// Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nclass Solution {\npublic:\nbool isUgly(int n) {\nif(n==0) return false;\nwhile(n%2==0) n/=2;\nwhile(n%3==0) n/=3;\nwhile(n%5==0) n/=5;\nreturn(n==1);\n}\n};",
                        "max_stars_repo_path": "Math/ugly-number.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 402
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_263",
                        "content": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\nGiven an integer `n`, return `true` _if_ `n` _is an **ugly number**_.\n**Example 1:**\n**Input:** n = 6\n**Output:** true\n**Explanation:** 6 = 2 \\* 3\n**Example 2:**\n**Input:** n = 1\n**Output:** true\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n**Example 3:**\n**Input:** n = 14\n**Output:** false\n**Explanation:** 14 is not ugly since it includes the prime factor 7.\n**Constraints:**\n*   `-231 <= n <= 231 - 1`\nInput:\nn = 6\nOutput:\ntrue\n```cpp\nbool isUgly(int n) {\nif (n <= 0) return false;\nwhile (n % 2 == 0) n /= 2;\nwhile (n % 3 == 0) n /= 3;\nwhile (n % 5 == 0) n /= 5;\nreturn n == 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 402
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_98",
                        "content": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\nA **valid BST** is defined as follows:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n**Example 2:**\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[2,1,3\\]\nOutput:\ntrue\n```cpp\nstruct TreeNode {\nint val;\nTreeNode *left;\nTreeNode *right;\n};\nbool isValidBSTHelper(TreeNode* root, long min, long max) {\nif (root == nullptr) return true;\nif (root->val <= min || root->val >= max) return false;\nreturn isValidBSTHelper(root->left, min, root->val) && isValidBSTHelper(root->right, root->val, max);\n}\nbool isValidBST(TreeNode* root) {\nreturn isValidBSTHelper(root, LONG_MIN, LONG_MAX);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 21
                },
                {
                        "id": "pretrain_cpp_data_2542868",
                        "content": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3]\nOutput: true\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool isValidBSTUtil(TreeNode* root, long long mini, long long maxi){\nif(!root) return true;\nif(root->val > mini && root->val < maxi){\nreturn isValidBSTUtil(root->left, mini, root->val) && isValidBSTUtil(root->right, root->val, maxi);\n} else return false;\n}\nbool isValidBST(TreeNode* root) {\nreturn isValidBSTUtil(root, (long long)INT_MIN-1, (long long)INT_MAX+1);\n}\n};",
                        "max_stars_repo_path": "competitive programming/leetcode/2020-December-Challenge/Day-16-Validate Binary Search Tree.cpp",
                        "max_stars_repo_name": "sureshmangs/Code",
                        "max_stars_count": 16.0,
                        "__cluster__": 21
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_1034",
                        "content": "You are given an `m x n` integer matrix `grid`, and three integers `row`, `col`, and `color`. Each value in the grid represents the color of the grid square at that location.\nTwo squares belong to the same **connected component** if they have the same color and are next to each other in any of the 4 directions.\nThe **border of a connected component** is all the squares in the connected component that are either **4-directionally** adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\nYou should color the **border** of the **connected component** that contains the square `grid[row][col]` with `color`.\nReturn _the final grid_.\n**Example 1:**\n**Input:** grid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\n**Output:** \\[\\[3,3\\],\\[3,2\\]\\]\n**Example 2:**\n**Input:** grid = \\[\\[1,2,2\\],\\[2,3,2\\]\\], row = 0, col = 1, color = 3\n**Output:** \\[\\[1,3,3\\],\\[2,3,3\\]\\]\n**Example 3:**\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], row = 1, col = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,1,2\\],\\[2,2,2\\]\\]\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= grid[i][j], color <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\nInput:\ngrid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\nOutput:\n\\[\\[3,3\\],\\[3,2\\]\\]\n```cpp\n#include <unordered_map>\nint good_subarrays(vector<int>& nums, int k) {\nint count = 0;\nfor (int i = 0; i < nums.size(); i++) {\nunordered_map<int, int> frequency;\nfor (int j = i; j < nums.size(); j++) {\nfrequency[nums[j]]++;\nif (frequency.size() > k) break;\nif (frequency.size() == k) count++;\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 101
                },
                {
                        "id": "pretrain_cpp_data_3311256",
                        "content": "// You are given an m x n integer matrix grid, and three integers row, col, and color.\n// Each value in the grid represents the color of the grid square at that location.\n// Two squares belong to the same connected component if they have the same color and\n// are next to each other in any of the 4 directions.\n// The border of a connected component is all the squares in the connected component that\n// are either 4-directionally adjacent to a square not in the component, or on the boundary\n//  of the grid (the first or last row or column).\n// You should color the border of the connected component that contains the square\n//  grid[row][col] with color.\n// Return the final grid.\n// Example 1:\n// Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n// Output: [[3,3],[3,2]]\n// Example 2:\n// Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n// Output: [[1,3,3],[2,3,3]]\n// Example 3:\n// Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n// Output: [[2,2,2],[2,1,2],[2,2,2]]\n//  Constraints:\n// m == grid.length\n// n == grid[i].length\n// 1 <= m, n <= 50\n// 1 <= grid[i][j], color <= 1000\n// 0 <= row < m\n// 0 <= col < n\nclass Solution {\npublic:\nvoid dfs(vector<vector<int>> &grid, int r, int c, int color){\nif(r < 0 or r >= grid.size() or c < 0 or c >= grid[r].size() or grid[r][c] != color)\nreturn;\ngrid[r][c] = -color;\ndfs(grid, r + 1, c, color);\ndfs(grid, r - 1, c, color);\ndfs(grid, r, c + 1, color);\ndfs(grid, r, c - 1, color);\nif(r > 0 and c > 0 and r < grid.size()-1 and c < grid[r].size()-1 and\nabs(grid[r+1][c]) == color and abs(grid[r-1][c]) == color and abs(grid[r][c+1]) == color\nand abs(grid[r][c-1]) == color)\ngrid[r][c] = color;\n}\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\ndfs(grid, r0, c0, grid[r0][c0]);\nfor(int i = 0; i < grid.size(); ++i)\nfor(int j = 0; j < grid[0].size(); ++j)\ngrid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\nreturn grid;\n}\n};\n",
                        "max_stars_repo_path": "Matrix/ColoringABorder1034.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 101
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_1034",
                        "content": "You are given an `m x n` integer matrix `grid`, and three integers `row`, `col`, and `color`. Each value in the grid represents the color of the grid square at that location.\nTwo squares belong to the same **connected component** if they have the same color and are next to each other in any of the 4 directions.\nThe **border of a connected component** is all the squares in the connected component that are either **4-directionally** adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\nYou should color the **border** of the **connected component** that contains the square `grid[row][col]` with `color`.\nReturn _the final grid_.\n**Example 1:**\n**Input:** grid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\n**Output:** \\[\\[3,3\\],\\[3,2\\]\\]\n**Example 2:**\n**Input:** grid = \\[\\[1,2,2\\],\\[2,3,2\\]\\], row = 0, col = 1, color = 3\n**Output:** \\[\\[1,3,3\\],\\[2,3,3\\]\\]\n**Example 3:**\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], row = 1, col = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,1,2\\],\\[2,2,2\\]\\]\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= grid[i][j], color <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\nInput:\ngrid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\nOutput:\n\\[\\[3,3\\],\\[3,2\\]\\]\n```cpp\n#include <unordered_map>\nint good_subarrays(vector<int>& nums, int k) {\nint count = 0;\nfor (int i = 0; i < nums.size(); i++) {\nunordered_map<int, int> frequency;\nfor (int j = i; j < nums.size(); j++) {\nfrequency[nums[j]]++;\nif (frequency.size() > k) break;\nif (frequency.size() == k) count++;\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 101
                },
                {
                        "id": "pretrain_cpp_data_3311256",
                        "content": "// You are given an m x n integer matrix grid, and three integers row, col, and color.\n// Each value in the grid represents the color of the grid square at that location.\n// Two squares belong to the same connected component if they have the same color and\n// are next to each other in any of the 4 directions.\n// The border of a connected component is all the squares in the connected component that\n// are either 4-directionally adjacent to a square not in the component, or on the boundary\n//  of the grid (the first or last row or column).\n// You should color the border of the connected component that contains the square\n//  grid[row][col] with color.\n// Return the final grid.\n// Example 1:\n// Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n// Output: [[3,3],[3,2]]\n// Example 2:\n// Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n// Output: [[1,3,3],[2,3,3]]\n// Example 3:\n// Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n// Output: [[2,2,2],[2,1,2],[2,2,2]]\n//  Constraints:\n// m == grid.length\n// n == grid[i].length\n// 1 <= m, n <= 50\n// 1 <= grid[i][j], color <= 1000\n// 0 <= row < m\n// 0 <= col < n\nclass Solution {\npublic:\nvoid dfs(vector<vector<int>> &grid, int r, int c, int color){\nif(r < 0 or r >= grid.size() or c < 0 or c >= grid[r].size() or grid[r][c] != color)\nreturn;\ngrid[r][c] = -color;\ndfs(grid, r + 1, c, color);\ndfs(grid, r - 1, c, color);\ndfs(grid, r, c + 1, color);\ndfs(grid, r, c - 1, color);\nif(r > 0 and c > 0 and r < grid.size()-1 and c < grid[r].size()-1 and\nabs(grid[r+1][c]) == color and abs(grid[r-1][c]) == color and abs(grid[r][c+1]) == color\nand abs(grid[r][c-1]) == color)\ngrid[r][c] = color;\n}\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\ndfs(grid, r0, c0, grid[r0][c0]);\nfor(int i = 0; i < grid.size(); ++i)\nfor(int j = 0; j < grid[0].size(); ++j)\ngrid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\nreturn grid;\n}\n};\n",
                        "max_stars_repo_path": "Matrix/ColoringABorder1034.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 101
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_1034",
                        "content": "You are given an `m x n` integer matrix `grid`, and three integers `row`, `col`, and `color`. Each value in the grid represents the color of the grid square at that location.\nTwo squares belong to the same **connected component** if they have the same color and are next to each other in any of the 4 directions.\nThe **border of a connected component** is all the squares in the connected component that are either **4-directionally** adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\nYou should color the **border** of the **connected component** that contains the square `grid[row][col]` with `color`.\nReturn _the final grid_.\n**Example 1:**\n**Input:** grid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\n**Output:** \\[\\[3,3\\],\\[3,2\\]\\]\n**Example 2:**\n**Input:** grid = \\[\\[1,2,2\\],\\[2,3,2\\]\\], row = 0, col = 1, color = 3\n**Output:** \\[\\[1,3,3\\],\\[2,3,3\\]\\]\n**Example 3:**\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], row = 1, col = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,1,2\\],\\[2,2,2\\]\\]\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= grid[i][j], color <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\nInput:\ngrid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\nOutput:\n\\[\\[3,3\\],\\[3,2\\]\\]\n```cpp\n#include <unordered_map>\nint good_subarrays(vector<int>& nums, int k) {\nint count = 0;\nfor (int i = 0; i < nums.size(); i++) {\nunordered_map<int, int> frequency;\nfor (int j = i; j < nums.size(); j++) {\nfrequency[nums[j]]++;\nif (frequency.size() > k) break;\nif (frequency.size() == k) count++;\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 101
                },
                {
                        "id": "pretrain_cpp_data_3311256",
                        "content": "// You are given an m x n integer matrix grid, and three integers row, col, and color.\n// Each value in the grid represents the color of the grid square at that location.\n// Two squares belong to the same connected component if they have the same color and\n// are next to each other in any of the 4 directions.\n// The border of a connected component is all the squares in the connected component that\n// are either 4-directionally adjacent to a square not in the component, or on the boundary\n//  of the grid (the first or last row or column).\n// You should color the border of the connected component that contains the square\n//  grid[row][col] with color.\n// Return the final grid.\n// Example 1:\n// Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n// Output: [[3,3],[3,2]]\n// Example 2:\n// Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n// Output: [[1,3,3],[2,3,3]]\n// Example 3:\n// Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n// Output: [[2,2,2],[2,1,2],[2,2,2]]\n//  Constraints:\n// m == grid.length\n// n == grid[i].length\n// 1 <= m, n <= 50\n// 1 <= grid[i][j], color <= 1000\n// 0 <= row < m\n// 0 <= col < n\nclass Solution {\npublic:\nvoid dfs(vector<vector<int>> &grid, int r, int c, int color){\nif(r < 0 or r >= grid.size() or c < 0 or c >= grid[r].size() or grid[r][c] != color)\nreturn;\ngrid[r][c] = -color;\ndfs(grid, r + 1, c, color);\ndfs(grid, r - 1, c, color);\ndfs(grid, r, c + 1, color);\ndfs(grid, r, c - 1, color);\nif(r > 0 and c > 0 and r < grid.size()-1 and c < grid[r].size()-1 and\nabs(grid[r+1][c]) == color and abs(grid[r-1][c]) == color and abs(grid[r][c+1]) == color\nand abs(grid[r][c-1]) == color)\ngrid[r][c] = color;\n}\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\ndfs(grid, r0, c0, grid[r0][c0]);\nfor(int i = 0; i < grid.size(); ++i)\nfor(int j = 0; j < grid[0].size(); ++j)\ngrid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\nreturn grid;\n}\n};\n",
                        "max_stars_repo_path": "Matrix/ColoringABorder1034.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 101
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_1034",
                        "content": "You are given an `m x n` integer matrix `grid`, and three integers `row`, `col`, and `color`. Each value in the grid represents the color of the grid square at that location.\nTwo squares belong to the same **connected component** if they have the same color and are next to each other in any of the 4 directions.\nThe **border of a connected component** is all the squares in the connected component that are either **4-directionally** adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\nYou should color the **border** of the **connected component** that contains the square `grid[row][col]` with `color`.\nReturn _the final grid_.\n**Example 1:**\n**Input:** grid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\n**Output:** \\[\\[3,3\\],\\[3,2\\]\\]\n**Example 2:**\n**Input:** grid = \\[\\[1,2,2\\],\\[2,3,2\\]\\], row = 0, col = 1, color = 3\n**Output:** \\[\\[1,3,3\\],\\[2,3,3\\]\\]\n**Example 3:**\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], row = 1, col = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,1,2\\],\\[2,2,2\\]\\]\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= grid[i][j], color <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\nInput:\ngrid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\nOutput:\n\\[\\[3,3\\],\\[3,2\\]\\]\n```cpp\n#include <unordered_map>\nint good_subarrays(vector<int>& nums, int k) {\nint count = 0;\nfor (int i = 0; i < nums.size(); i++) {\nunordered_map<int, int> frequency;\nfor (int j = i; j < nums.size(); j++) {\nfrequency[nums[j]]++;\nif (frequency.size() > k) break;\nif (frequency.size() == k) count++;\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 101
                },
                {
                        "id": "pretrain_cpp_data_3311256",
                        "content": "// You are given an m x n integer matrix grid, and three integers row, col, and color.\n// Each value in the grid represents the color of the grid square at that location.\n// Two squares belong to the same connected component if they have the same color and\n// are next to each other in any of the 4 directions.\n// The border of a connected component is all the squares in the connected component that\n// are either 4-directionally adjacent to a square not in the component, or on the boundary\n//  of the grid (the first or last row or column).\n// You should color the border of the connected component that contains the square\n//  grid[row][col] with color.\n// Return the final grid.\n// Example 1:\n// Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n// Output: [[3,3],[3,2]]\n// Example 2:\n// Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n// Output: [[1,3,3],[2,3,3]]\n// Example 3:\n// Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n// Output: [[2,2,2],[2,1,2],[2,2,2]]\n//  Constraints:\n// m == grid.length\n// n == grid[i].length\n// 1 <= m, n <= 50\n// 1 <= grid[i][j], color <= 1000\n// 0 <= row < m\n// 0 <= col < n\nclass Solution {\npublic:\nvoid dfs(vector<vector<int>> &grid, int r, int c, int color){\nif(r < 0 or r >= grid.size() or c < 0 or c >= grid[r].size() or grid[r][c] != color)\nreturn;\ngrid[r][c] = -color;\ndfs(grid, r + 1, c, color);\ndfs(grid, r - 1, c, color);\ndfs(grid, r, c + 1, color);\ndfs(grid, r, c - 1, color);\nif(r > 0 and c > 0 and r < grid.size()-1 and c < grid[r].size()-1 and\nabs(grid[r+1][c]) == color and abs(grid[r-1][c]) == color and abs(grid[r][c+1]) == color\nand abs(grid[r][c-1]) == color)\ngrid[r][c] = color;\n}\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\ndfs(grid, r0, c0, grid[r0][c0]);\nfor(int i = 0; i < grid.size(); ++i)\nfor(int j = 0; j < grid[0].size(); ++j)\ngrid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\nreturn grid;\n}\n};\n",
                        "max_stars_repo_path": "Matrix/ColoringABorder1034.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 101
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_2597946",
                        "content": "/*\nMinimum Depth of Binary Tree\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/\nGiven a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000\n*/\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint minDepth(TreeNode* root) {\nif (!root) return 0;\nint left = minDepth(root->left), right = minDepth(root->right);\nreturn 1 + (min(left, right) ? min(left, right) : max(left, right));\n}\n};",
                        "max_stars_repo_path": "leetcode/problems/easy/111-minimum-depth-of-binary-tree.cpp",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_count": 18.0,
                        "__cluster__": 51
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```cpp\nint minDepth(TreeNode* root) {\nif (!root) return 0;\nint left = minDepth(root->left);\nint right = minDepth(root->right);\nreturn (left == 0 || right == 0) ? left + right + 1 : min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 51
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_700",
                        "content": "You are given the `root` of a binary search tree (BST) and an integer `val`.\nFind the node in the BST that the node's value equals `val` and return the subtree rooted with that node. If such a node does not exist, return `null`.\n**Example 1:**\n**Input:** root = \\[4,2,7,1,3\\], val = 2\n**Output:** \\[2,1,3\\]\n**Example 2:**\n**Input:** root = \\[4,2,7,1,3\\], val = 5\n**Output:** \\[\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 5000]`.\n*   `1 <= Node.val <= 107`\n*   `root` is a binary search tree.\n*   `1 <= val <= 107`\nInput:\nroot = \\[4,2,7,1,3\\], val = 2\nOutput:\n\\[2,1,3\\]\n```cpp\nstruct TreeNode {\nint val;\nTreeNode* left;\nTreeNode* right;\n};\nTreeNode* searchBST(TreeNode* root, int val) {\nif (!root || root->val == val)\nreturn root;\nreturn (root->val < val) ? searchBST(root->right, val) : searchBST(root->left, val);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 497
                },
                {
                        "id": "pretrain_cpp_data_3365133",
                        "content": "// 22/04/14 = Thu\n// 700. Search in a Binary Search Tree [Easy]\n// You are given the root of a binary search tree (BST) and an integer val.\n// Find the node in the BST that the node's value equals val and return the\n// subtree rooted with that node. If such a node does not exist, return null.\n// Example 1:\n// Input: root = [4,2,7,1,3], val = 2\n// Output: [2,1,3]\n// Example 2:\n// Input: root = [4,2,7,1,3], val = 5\n// Output: []\n// Constraints:\n//     The number of nodes in the tree is in the range [1, 5000].\n//     1 <= Node.val <= 10^7\n//     root is a binary search tree.\n//     1 <= val <= 10^7\n// Related Topics:\n// [Binary Search Tree] [Binary Tree*] [Tree]\n// ---------\n// recursive\n// ---------\nclass Solution {\npublic:\nTreeNode *searchBST(TreeNode *root, int val) {\nif (!root || root->val == val) {\nreturn root;\n}\nreturn searchBST(val < root->val ? root->left : root->right, val);\n}\n};\n// ---------\n// iterative\n// ---------\nclass Solution {\npublic:\nTreeNode *searchBST(TreeNode *root, int val) {\nwhile (root && root->val != val) {\nroot = val < root->val ? root->left : root->right;\n}\nreturn root;\n}\n};",
                        "max_stars_repo_path": "c++/0700-search-in-a-binary-search-tree.cpp",
                        "max_stars_repo_name": "aafulei/leetcode",
                        "max_stars_count": 2.0,
                        "__cluster__": 497
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_75",
                        "content": "Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\n**Example 1:**\n**Input:** nums = \\[2,0,2,1,1,0\\]\n**Output:** \\[0,0,1,1,2,2\\]\n**Example 2:**\n**Input:** nums = \\[2,0,1\\]\n**Output:** \\[0,1,2\\]\n**Constraints:**\n*   `n == nums.length`\n*   `1 <= n <= 300`\n*   `nums[i]` is either `0`, `1`, or `2`.\n**Follow up:** Could you come up with a one-pass algorithm using only constant extra space?\nInput:\nnums = \\[2,0,2,1,1,0\\]\nOutput:\n\\[0,0,1,1,2,2\\]\n```cpp\nvoid sortColors(vector<int>& nums) {\nint red = 0, white = 0, blue = nums.size() - 1;\nwhile (white <= blue) {\nif (nums[white] == 0) {\nswap(nums[red++], nums[white++]);\n} else if (nums[white] == 1) {\nwhite++;\n} else {\nswap(nums[white], nums[blue--]);\n}\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 329
                },
                {
                        "id": "pretrain_cpp_data_3393085",
                        "content": "<reponame>wingkwong/competitive-programming\n/*\nSort Colors\nhttps://leetcode.com/problems/sort-colors/\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\nExample 1:\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\nExample 2:\nInput: nums = [2,0,1]\nOutput: [0,1,2]\nExample 3:\nInput: nums = [0]\nOutput: [0]\nExample 4:\nInput: nums = [1]\nOutput: [1]\nConstraints:\nn == nums.length\n1 <= n <= 300\nnums[i] is 0, 1, or 2.\nFollow up: Could you come up with a one-pass algorithm using only constant extra space?\n*/\nclass Solution {\npublic:\nvoid sortColors(vector<int>& nums) {\nint l = 0, r = nums.size() - 1, i = 0;\nwhile(i <= r) {\nif(nums[i] == 0) swap(nums[l++], nums[i++]);\nelse if(nums[i] == 2) swap(nums[i], nums[r--]);\nelse i++;\n}\n}\n};",
                        "max_stars_repo_path": "leetcode/problems/medium/75-sort-colors.cpp",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_count": 18.0,
                        "__cluster__": 329
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_200",
                        "content": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n**Example 1:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n**Example 2:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.\nInput:\ngrid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\nOutput:\n1\n```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\nif(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\nreturn;\ngrid[i][j] = '0';\ndfs(grid, i + 1, j);\ndfs(grid, i - 1, j);\ndfs(grid, i, j + 1);\ndfs(grid, i, j - 1);\n}\nint numIslands(vector<vector<char>>& grid) {\nint count = 0;\nfor(int i = 0; i < grid.size(); i++) {\nfor(int j = 0; j < grid[0].size(); j++) {\nif(grid[i][j] == '1') {\ncount++;\ndfs(grid, i, j);\n}\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 84
                },
                {
                        "id": "pretrain_cpp_data_4151551",
                        "content": "// question\n// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n// Example 1:\n// Input: grid = [\n//   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"0\",\"0\"]\n// ]\n// Output: 1\n// Example 2:\n// Input: grid = [\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"1\",\"1\"]\n// ]\n// Output: 3\nclass Solution {\npublic:\nvoid mark(vector<vector<char>>& grid,int x,int y,int rows,int cols){\nif(x<0 || x>=rows|| y<0|| y>=cols || grid[x][y]!='1'){\nreturn;\n}\ngrid[x][y]='2';\nmark(grid,x+1,y,rows,cols);//down\nmark(grid,x,y+1,rows,cols);//right\nmark(grid,x-1,y,rows,cols);//top\nmark(grid,x,y-1,rows,cols);//left\n}\nint numIslands(vector<vector<char>>& grid) {\nint rows = grid.size();\nif(rows== 0) return 0;\nint cols=grid[0].size();\nint no_of_island = 0;\nfor(int i =0;i<rows;i++){\nfor(int j = 0;j<cols;j++){\nif(grid[i][j]=='1'){\nmark(grid,i,j,rows,cols);\nno_of_island += 1;\n}\n}\n}\nreturn no_of_island;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/Number of Islands.cpp",
                        "max_stars_repo_name": "abdzitter/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 84
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_200",
                        "content": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n**Example 1:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n**Example 2:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.\nInput:\ngrid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\nOutput:\n1\n```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\nif(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\nreturn;\ngrid[i][j] = '0';\ndfs(grid, i + 1, j);\ndfs(grid, i - 1, j);\ndfs(grid, i, j + 1);\ndfs(grid, i, j - 1);\n}\nint numIslands(vector<vector<char>>& grid) {\nint count = 0;\nfor(int i = 0; i < grid.size(); i++) {\nfor(int j = 0; j < grid[0].size(); j++) {\nif(grid[i][j] == '1') {\ncount++;\ndfs(grid, i, j);\n}\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 84
                },
                {
                        "id": "pretrain_cpp_data_4151551",
                        "content": "// question\n// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n// Example 1:\n// Input: grid = [\n//   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"0\",\"0\"]\n// ]\n// Output: 1\n// Example 2:\n// Input: grid = [\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"1\",\"1\"]\n// ]\n// Output: 3\nclass Solution {\npublic:\nvoid mark(vector<vector<char>>& grid,int x,int y,int rows,int cols){\nif(x<0 || x>=rows|| y<0|| y>=cols || grid[x][y]!='1'){\nreturn;\n}\ngrid[x][y]='2';\nmark(grid,x+1,y,rows,cols);//down\nmark(grid,x,y+1,rows,cols);//right\nmark(grid,x-1,y,rows,cols);//top\nmark(grid,x,y-1,rows,cols);//left\n}\nint numIslands(vector<vector<char>>& grid) {\nint rows = grid.size();\nif(rows== 0) return 0;\nint cols=grid[0].size();\nint no_of_island = 0;\nfor(int i =0;i<rows;i++){\nfor(int j = 0;j<cols;j++){\nif(grid[i][j]=='1'){\nmark(grid,i,j,rows,cols);\nno_of_island += 1;\n}\n}\n}\nreturn no_of_island;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/Number of Islands.cpp",
                        "max_stars_repo_name": "abdzitter/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 84
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_200",
                        "content": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n**Example 1:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n**Example 2:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.\nInput:\ngrid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\nOutput:\n1\n```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\nif(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\nreturn;\ngrid[i][j] = '0';\ndfs(grid, i + 1, j);\ndfs(grid, i - 1, j);\ndfs(grid, i, j + 1);\ndfs(grid, i, j - 1);\n}\nint numIslands(vector<vector<char>>& grid) {\nint count = 0;\nfor(int i = 0; i < grid.size(); i++) {\nfor(int j = 0; j < grid[0].size(); j++) {\nif(grid[i][j] == '1') {\ncount++;\ndfs(grid, i, j);\n}\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 84
                },
                {
                        "id": "pretrain_cpp_data_4151551",
                        "content": "// question\n// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n// Example 1:\n// Input: grid = [\n//   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"0\",\"0\"]\n// ]\n// Output: 1\n// Example 2:\n// Input: grid = [\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"1\",\"1\"]\n// ]\n// Output: 3\nclass Solution {\npublic:\nvoid mark(vector<vector<char>>& grid,int x,int y,int rows,int cols){\nif(x<0 || x>=rows|| y<0|| y>=cols || grid[x][y]!='1'){\nreturn;\n}\ngrid[x][y]='2';\nmark(grid,x+1,y,rows,cols);//down\nmark(grid,x,y+1,rows,cols);//right\nmark(grid,x-1,y,rows,cols);//top\nmark(grid,x,y-1,rows,cols);//left\n}\nint numIslands(vector<vector<char>>& grid) {\nint rows = grid.size();\nif(rows== 0) return 0;\nint cols=grid[0].size();\nint no_of_island = 0;\nfor(int i =0;i<rows;i++){\nfor(int j = 0;j<cols;j++){\nif(grid[i][j]=='1'){\nmark(grid,i,j,rows,cols);\nno_of_island += 1;\n}\n}\n}\nreturn no_of_island;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/Number of Islands.cpp",
                        "max_stars_repo_name": "abdzitter/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 84
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_200",
                        "content": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n**Example 1:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n**Example 2:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.\nInput:\ngrid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\nOutput:\n1\n```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\nif(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\nreturn;\ngrid[i][j] = '0';\ndfs(grid, i + 1, j);\ndfs(grid, i - 1, j);\ndfs(grid, i, j + 1);\ndfs(grid, i, j - 1);\n}\nint numIslands(vector<vector<char>>& grid) {\nint count = 0;\nfor(int i = 0; i < grid.size(); i++) {\nfor(int j = 0; j < grid[0].size(); j++) {\nif(grid[i][j] == '1') {\ncount++;\ndfs(grid, i, j);\n}\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 84
                },
                {
                        "id": "pretrain_cpp_data_4151551",
                        "content": "// question\n// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n// Example 1:\n// Input: grid = [\n//   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"0\",\"0\"]\n// ]\n// Output: 1\n// Example 2:\n// Input: grid = [\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"1\",\"1\"]\n// ]\n// Output: 3\nclass Solution {\npublic:\nvoid mark(vector<vector<char>>& grid,int x,int y,int rows,int cols){\nif(x<0 || x>=rows|| y<0|| y>=cols || grid[x][y]!='1'){\nreturn;\n}\ngrid[x][y]='2';\nmark(grid,x+1,y,rows,cols);//down\nmark(grid,x,y+1,rows,cols);//right\nmark(grid,x-1,y,rows,cols);//top\nmark(grid,x,y-1,rows,cols);//left\n}\nint numIslands(vector<vector<char>>& grid) {\nint rows = grid.size();\nif(rows== 0) return 0;\nint cols=grid[0].size();\nint no_of_island = 0;\nfor(int i =0;i<rows;i++){\nfor(int j = 0;j<cols;j++){\nif(grid[i][j]=='1'){\nmark(grid,i,j,rows,cols);\nno_of_island += 1;\n}\n}\n}\nreturn no_of_island;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/Number of Islands.cpp",
                        "max_stars_repo_name": "abdzitter/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 84
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_200",
                        "content": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n**Example 1:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n**Example 2:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.\nInput:\ngrid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\nOutput:\n1\n```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\nif(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\nreturn;\ngrid[i][j] = '0';\ndfs(grid, i + 1, j);\ndfs(grid, i - 1, j);\ndfs(grid, i, j + 1);\ndfs(grid, i, j - 1);\n}\nint numIslands(vector<vector<char>>& grid) {\nint count = 0;\nfor(int i = 0; i < grid.size(); i++) {\nfor(int j = 0; j < grid[0].size(); j++) {\nif(grid[i][j] == '1') {\ncount++;\ndfs(grid, i, j);\n}\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 84
                },
                {
                        "id": "pretrain_cpp_data_4151551",
                        "content": "// question\n// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n// Example 1:\n// Input: grid = [\n//   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"0\",\"0\"]\n// ]\n// Output: 1\n// Example 2:\n// Input: grid = [\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"1\",\"1\"]\n// ]\n// Output: 3\nclass Solution {\npublic:\nvoid mark(vector<vector<char>>& grid,int x,int y,int rows,int cols){\nif(x<0 || x>=rows|| y<0|| y>=cols || grid[x][y]!='1'){\nreturn;\n}\ngrid[x][y]='2';\nmark(grid,x+1,y,rows,cols);//down\nmark(grid,x,y+1,rows,cols);//right\nmark(grid,x-1,y,rows,cols);//top\nmark(grid,x,y-1,rows,cols);//left\n}\nint numIslands(vector<vector<char>>& grid) {\nint rows = grid.size();\nif(rows== 0) return 0;\nint cols=grid[0].size();\nint no_of_island = 0;\nfor(int i =0;i<rows;i++){\nfor(int j = 0;j<cols;j++){\nif(grid[i][j]=='1'){\nmark(grid,i,j,rows,cols);\nno_of_island += 1;\n}\n}\n}\nreturn no_of_island;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/Number of Islands.cpp",
                        "max_stars_repo_name": "abdzitter/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 84
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_200",
                        "content": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n**Example 1:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n**Example 2:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.\nInput:\ngrid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\nOutput:\n1\n```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\nif(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\nreturn;\ngrid[i][j] = '0';\ndfs(grid, i + 1, j);\ndfs(grid, i - 1, j);\ndfs(grid, i, j + 1);\ndfs(grid, i, j - 1);\n}\nint numIslands(vector<vector<char>>& grid) {\nint count = 0;\nfor(int i = 0; i < grid.size(); i++) {\nfor(int j = 0; j < grid[0].size(); j++) {\nif(grid[i][j] == '1') {\ncount++;\ndfs(grid, i, j);\n}\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 84
                },
                {
                        "id": "pretrain_cpp_data_4151551",
                        "content": "// question\n// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n// Example 1:\n// Input: grid = [\n//   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"0\",\"0\"]\n// ]\n// Output: 1\n// Example 2:\n// Input: grid = [\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"1\",\"1\"]\n// ]\n// Output: 3\nclass Solution {\npublic:\nvoid mark(vector<vector<char>>& grid,int x,int y,int rows,int cols){\nif(x<0 || x>=rows|| y<0|| y>=cols || grid[x][y]!='1'){\nreturn;\n}\ngrid[x][y]='2';\nmark(grid,x+1,y,rows,cols);//down\nmark(grid,x,y+1,rows,cols);//right\nmark(grid,x-1,y,rows,cols);//top\nmark(grid,x,y-1,rows,cols);//left\n}\nint numIslands(vector<vector<char>>& grid) {\nint rows = grid.size();\nif(rows== 0) return 0;\nint cols=grid[0].size();\nint no_of_island = 0;\nfor(int i =0;i<rows;i++){\nfor(int j = 0;j<cols;j++){\nif(grid[i][j]=='1'){\nmark(grid,i,j,rows,cols);\nno_of_island += 1;\n}\n}\n}\nreturn no_of_island;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/Number of Islands.cpp",
                        "max_stars_repo_name": "abdzitter/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 84
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_200",
                        "content": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n**Example 1:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n**Example 2:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.\nInput:\ngrid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\nOutput:\n1\n```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\nif(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\nreturn;\ngrid[i][j] = '0';\ndfs(grid, i + 1, j);\ndfs(grid, i - 1, j);\ndfs(grid, i, j + 1);\ndfs(grid, i, j - 1);\n}\nint numIslands(vector<vector<char>>& grid) {\nint count = 0;\nfor(int i = 0; i < grid.size(); i++) {\nfor(int j = 0; j < grid[0].size(); j++) {\nif(grid[i][j] == '1') {\ncount++;\ndfs(grid, i, j);\n}\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 84
                },
                {
                        "id": "pretrain_cpp_data_4151551",
                        "content": "// question\n// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n// Example 1:\n// Input: grid = [\n//   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"0\",\"0\"]\n// ]\n// Output: 1\n// Example 2:\n// Input: grid = [\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"1\",\"1\"]\n// ]\n// Output: 3\nclass Solution {\npublic:\nvoid mark(vector<vector<char>>& grid,int x,int y,int rows,int cols){\nif(x<0 || x>=rows|| y<0|| y>=cols || grid[x][y]!='1'){\nreturn;\n}\ngrid[x][y]='2';\nmark(grid,x+1,y,rows,cols);//down\nmark(grid,x,y+1,rows,cols);//right\nmark(grid,x-1,y,rows,cols);//top\nmark(grid,x,y-1,rows,cols);//left\n}\nint numIslands(vector<vector<char>>& grid) {\nint rows = grid.size();\nif(rows== 0) return 0;\nint cols=grid[0].size();\nint no_of_island = 0;\nfor(int i =0;i<rows;i++){\nfor(int j = 0;j<cols;j++){\nif(grid[i][j]=='1'){\nmark(grid,i,j,rows,cols);\nno_of_island += 1;\n}\n}\n}\nreturn no_of_island;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/Number of Islands.cpp",
                        "max_stars_repo_name": "abdzitter/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 84
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_200",
                        "content": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n**Example 1:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n**Example 2:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.\nInput:\ngrid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\nOutput:\n1\n```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\nif(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\nreturn;\ngrid[i][j] = '0';\ndfs(grid, i + 1, j);\ndfs(grid, i - 1, j);\ndfs(grid, i, j + 1);\ndfs(grid, i, j - 1);\n}\nint numIslands(vector<vector<char>>& grid) {\nint count = 0;\nfor(int i = 0; i < grid.size(); i++) {\nfor(int j = 0; j < grid[0].size(); j++) {\nif(grid[i][j] == '1') {\ncount++;\ndfs(grid, i, j);\n}\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 84
                },
                {
                        "id": "pretrain_cpp_data_4151551",
                        "content": "// question\n// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n// Example 1:\n// Input: grid = [\n//   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"0\",\"0\"]\n// ]\n// Output: 1\n// Example 2:\n// Input: grid = [\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"1\",\"1\"]\n// ]\n// Output: 3\nclass Solution {\npublic:\nvoid mark(vector<vector<char>>& grid,int x,int y,int rows,int cols){\nif(x<0 || x>=rows|| y<0|| y>=cols || grid[x][y]!='1'){\nreturn;\n}\ngrid[x][y]='2';\nmark(grid,x+1,y,rows,cols);//down\nmark(grid,x,y+1,rows,cols);//right\nmark(grid,x-1,y,rows,cols);//top\nmark(grid,x,y-1,rows,cols);//left\n}\nint numIslands(vector<vector<char>>& grid) {\nint rows = grid.size();\nif(rows== 0) return 0;\nint cols=grid[0].size();\nint no_of_island = 0;\nfor(int i =0;i<rows;i++){\nfor(int j = 0;j<cols;j++){\nif(grid[i][j]=='1'){\nmark(grid,i,j,rows,cols);\nno_of_island += 1;\n}\n}\n}\nreturn no_of_island;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/Number of Islands.cpp",
                        "max_stars_repo_name": "abdzitter/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 84
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_200",
                        "content": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n**Example 1:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n**Example 2:**\n**Input:** grid = \\[\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.\nInput:\ngrid = \\[\n\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n\\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n\\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\nOutput:\n1\n```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\nif(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\nreturn;\ngrid[i][j] = '0';\ndfs(grid, i + 1, j);\ndfs(grid, i - 1, j);\ndfs(grid, i, j + 1);\ndfs(grid, i, j - 1);\n}\nint numIslands(vector<vector<char>>& grid) {\nint count = 0;\nfor(int i = 0; i < grid.size(); i++) {\nfor(int j = 0; j < grid[0].size(); j++) {\nif(grid[i][j] == '1') {\ncount++;\ndfs(grid, i, j);\n}\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 84
                },
                {
                        "id": "pretrain_cpp_data_4151551",
                        "content": "// question\n// Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n// Example 1:\n// Input: grid = [\n//   [\"1\",\"1\",\"1\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"1\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"0\",\"0\"]\n// ]\n// Output: 1\n// Example 2:\n// Input: grid = [\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"1\",\"1\",\"0\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"1\",\"0\",\"0\"],\n//   [\"0\",\"0\",\"0\",\"1\",\"1\"]\n// ]\n// Output: 3\nclass Solution {\npublic:\nvoid mark(vector<vector<char>>& grid,int x,int y,int rows,int cols){\nif(x<0 || x>=rows|| y<0|| y>=cols || grid[x][y]!='1'){\nreturn;\n}\ngrid[x][y]='2';\nmark(grid,x+1,y,rows,cols);//down\nmark(grid,x,y+1,rows,cols);//right\nmark(grid,x-1,y,rows,cols);//top\nmark(grid,x,y-1,rows,cols);//left\n}\nint numIslands(vector<vector<char>>& grid) {\nint rows = grid.size();\nif(rows== 0) return 0;\nint cols=grid[0].size();\nint no_of_island = 0;\nfor(int i =0;i<rows;i++){\nfor(int j = 0;j<cols;j++){\nif(grid[i][j]=='1'){\nmark(grid,i,j,rows,cols);\nno_of_island += 1;\n}\n}\n}\nreturn no_of_island;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/Number of Islands.cpp",
                        "max_stars_repo_name": "abdzitter/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 84
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```cpp\nint rob(vector<int>& nums) {\nint prev1 = 0, prev2 = 0;\nfor (const auto& num : nums) {\nint tmp = prev1;\nprev1 = max(prev2 + num, prev1);\nprev2 = tmp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "id": "pretrain_cpp_data_4123837",
                        "content": "<gh_stars>0\n/*\n198. House Robber\nMedium\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n*/\nclass Solution {\npublic:\nint rob(vector<int>& nums) {\nint c1,c2;\nfor(int i=1;i<nums.size();i++){\nc1=i-2<0?nums[i]:nums[i-2]+nums[i];\nc2=nums[i-1];\nnums[i]=max(c1,c2);\n}\nreturn nums[nums.size()-1];\n}\n};",
                        "max_stars_repo_path": "198_House_Robber.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```cpp\nint rob(vector<int>& nums) {\nint prev1 = 0, prev2 = 0;\nfor (const auto& num : nums) {\nint tmp = prev1;\nprev1 = max(prev2 + num, prev1);\nprev2 = tmp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "id": "pretrain_cpp_data_4123837",
                        "content": "<gh_stars>0\n/*\n198. House Robber\nMedium\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n*/\nclass Solution {\npublic:\nint rob(vector<int>& nums) {\nint c1,c2;\nfor(int i=1;i<nums.size();i++){\nc1=i-2<0?nums[i]:nums[i-2]+nums[i];\nc2=nums[i-1];\nnums[i]=max(c1,c2);\n}\nreturn nums[nums.size()-1];\n}\n};",
                        "max_stars_repo_path": "198_House_Robber.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```cpp\nint rob(vector<int>& nums) {\nint prev1 = 0, prev2 = 0;\nfor (const auto& num : nums) {\nint tmp = prev1;\nprev1 = max(prev2 + num, prev1);\nprev2 = tmp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "id": "pretrain_cpp_data_4123837",
                        "content": "<gh_stars>0\n/*\n198. House Robber\nMedium\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n*/\nclass Solution {\npublic:\nint rob(vector<int>& nums) {\nint c1,c2;\nfor(int i=1;i<nums.size();i++){\nc1=i-2<0?nums[i]:nums[i-2]+nums[i];\nc2=nums[i-1];\nnums[i]=max(c1,c2);\n}\nreturn nums[nums.size()-1];\n}\n};",
                        "max_stars_repo_path": "198_House_Robber.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_538",
                        "content": "Given the `root` of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a _binary search tree_ is a tree that satisfies these constraints:\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n**Example 1:**\n**Input:** root = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\n**Output:** \\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n**Example 2:**\n**Input:** root = \\[0,null,1\\]\n**Output:** \\[1,null,1\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-104 <= Node.val <= 104`\n*   All the values in the tree are **unique**.\n*   `root` is guaranteed to be a valid binary search tree.\n**Note:** This question is the same as 1038: [https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)\nInput:\nroot = \\[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8\\]\nOutput:\n\\[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8\\]\n```cpp\nstruct TreeNode {\nint val;\nTreeNode *left;\nTreeNode *right;\nTreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nclass Solution {\npublic:\nint sum = 0;\nTreeNode* convertBST(TreeNode* root) {\nif (root) {\nconvertBST(root->right);\nsum += root->val;\nroot->val = sum;\nconvertBST(root->left);\n}\nreturn root;\n}\n};\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 16
                },
                {
                        "id": "pretrain_cpp_data_4908441",
                        "content": "/*\n538. Convert BST to Greater Tree\nMedium\nGiven the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\nExample 2:\nInput: root = [0,null,1]\nOutput: [1,null,1]\nExample 3:\nInput: root = [1,0,2]\nOutput: [3,3,2]\nExample 4:\nInput: root = [3,2,4,1]\nOutput: [7,9,4,10]\nConstraints:\nThe number of nodes in the tree is in the range [0, 104].\n-104 <= Node.val <= 104\nAll the values in the tree are unique.\nroot is guaranteed to be a valid binary search tree.\nNote: This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\n*/\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\nint sum=0;\nvoid helper(TreeNode* root){\nif(!root) return;\nhelper(root->right);\nsum+=root->val;\nroot->val=sum;\nhelper(root->left);\n}\npublic:\nTreeNode* convertBST(TreeNode* root) {\nhelper(root);\nreturn root;\n}\n};",
                        "max_stars_repo_path": "538_Convert_BST_to_Greater_Tree.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 16
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_42",
                        "content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n**Example 1:**\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n**Example 2:**\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n**Constraints:**\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\nInput:\nheight = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\nOutput:\n6\n```cpp\n#include <vector>\nusing namespace std;\nint trap(vector<int>& height) {\nint n = height.size();\nint left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\nwhile (left < right) {\nif (height[left] <= height[right]) {\nmaxLeft = max(maxLeft, height[left]);\nwater += maxLeft - height[left];\nleft++;\n} else {\nmaxRight = max(maxRight, height[right]);\nwater += maxRight - height[right];\nright--;\n}\n}\nreturn water;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 313
                },
                {
                        "id": "pretrain_cpp_data_4176606",
                        "content": "// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n// Example 1:\n// Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n// Output: 6\n// Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n// Example 2:\n// Input: height = [4,2,0,3,2,5]\n// Output: 9\n// Constraints:\n// n == height.length\n// 1 <= n <= 2 * 104\n// 0 <= height[i] <= 105\n#include <bits/stdc++.h>\nusing namespace std;\nclass Solution\n{\npublic:\nint trap(vector<int> &height)\n{\nint n = height.size();\nif (n == 0)\nreturn 0;\nint leftPointer = 0, rightPointer = n - 1;\nint resultant = 0;\nint leftHighest = height[leftPointer], rightHighest = height[rightPointer];\nwhile (leftPointer < rightPointer)\n{\nif (leftHighest < rightHighest)\n{\nresultant += leftHighest - height[leftPointer];\nleftPointer++;\nleftHighest = max(leftHighest, height[leftPointer]);\n}\nelse\n{\nresultant += rightHighest - height[rightPointer];\nrightPointer--;\nrightHighest = max(rightHighest, height[rightPointer]);\n}\n}\nreturn resultant;\n}\n};\nint main()\n{\nsystem(\"CLS\");\nSolution obj;\nvector<int> height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\ncout << obj.trap(height) << endl;\nreturn 0;\n}",
                        "max_stars_repo_path": "Trapping_Rainwater_Problem.cpp",
                        "max_stars_repo_name": "omkar342/hacktober",
                        "max_stars_count": 0.0,
                        "__cluster__": 313
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_256",
                        "content": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\nReturn _the minimum cost to paint all houses_.\n**Example 1:**\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n**Example 2:**\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2\n**Constraints:**\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`\nInput:\ncosts = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\nOutput:\n10\n```cpp\nint minCost(vector<vector<int>>& costs) {\nif (costs.empty()) return 0;\nfor (int i = 1; i < costs.size(); ++i) {\ncosts[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\ncosts[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\ncosts[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n}\nreturn min(costs.back()[0], min(costs.back()[1], costs.back()[2]));\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 398
                },
                {
                        "id": "pretrain_cpp_data_4975074",
                        "content": "<reponame>wingkwong/competitive-programming\n/*\nPaint House\nhttps://leetcode.com/problems/paint-house/\nThere is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.\nFor example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on...\nReturn the minimum cost to paint all houses.\nExample 1:\nInput: costs = [[17,2,17],[16,16,5],[14,3,19]]\nOutput: 10\nExplanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n*/\nclass Solution {\npublic:\nint minCost(vector<vector<int>>& costs) {\nint n = costs.size();\nfor(int i = 1; i < n; i++) {\ncosts[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\ncosts[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\ncosts[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n}\nreturn min({\ncosts[n - 1][0],\ncosts[n - 1][1],\ncosts[n - 1][2]\n});\n}\n};",
                        "max_stars_repo_path": "leetcode/problems/medium/256-paint-house.cpp",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_count": 18.0,
                        "__cluster__": 398
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_256",
                        "content": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\nReturn _the minimum cost to paint all houses_.\n**Example 1:**\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n**Example 2:**\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2\n**Constraints:**\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`\nInput:\ncosts = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\nOutput:\n10\n```cpp\nint minCost(vector<vector<int>>& costs) {\nif (costs.empty()) return 0;\nfor (int i = 1; i < costs.size(); ++i) {\ncosts[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\ncosts[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\ncosts[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n}\nreturn min(costs.back()[0], min(costs.back()[1], costs.back()[2]));\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 398
                },
                {
                        "id": "pretrain_cpp_data_4975074",
                        "content": "<reponame>wingkwong/competitive-programming\n/*\nPaint House\nhttps://leetcode.com/problems/paint-house/\nThere is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.\nFor example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on...\nReturn the minimum cost to paint all houses.\nExample 1:\nInput: costs = [[17,2,17],[16,16,5],[14,3,19]]\nOutput: 10\nExplanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n*/\nclass Solution {\npublic:\nint minCost(vector<vector<int>>& costs) {\nint n = costs.size();\nfor(int i = 1; i < n; i++) {\ncosts[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\ncosts[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\ncosts[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n}\nreturn min({\ncosts[n - 1][0],\ncosts[n - 1][1],\ncosts[n - 1][2]\n});\n}\n};",
                        "max_stars_repo_path": "leetcode/problems/medium/256-paint-house.cpp",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_count": 18.0,
                        "__cluster__": 398
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_111",
                        "content": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n**Note:** A leaf is a node with no children.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n**Example 2:**\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n2\n```cpp\nint minDepth(TreeNode* root) {\nif (!root) return 0;\nint left = minDepth(root->left);\nint right = minDepth(root->right);\nreturn (left == 0 || right == 0) ? left + right + 1 : min(left, right) + 1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 51
                },
                {
                        "id": "pretrain_cpp_data_5781744",
                        "content": "<reponame>kmykoh97/My-Leetcode<filename>solutions/minimum_depth_of_binary_tree.cpp\n// Given a binary tree, find its minimum depth.\n// The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n// Note: A leaf is a node with no children.\n// Example 1:\n// Input: root = [3,9,20,null,null,15,7]\n// Output: 2\n// Example 2:\n// Input: root = [2,null,3,null,4,null,5,null,6]\n// Output: 5\n// Constraints:\n// The number of nodes in the tree is in the range [0, 105].\n// -1000 <= Node.val <= 1000\n// solution: dfs\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint minDepth(TreeNode* root) {\nif (!root) return 0;\nif (!root->left && !root->right) return 1;\nif (!root->left) return minDepth(root->right) + 1;\nif (!root->right) return minDepth(root->left) + 1;\nreturn min(minDepth(root->left), minDepth(root->right)) + 1;\n}\n};",
                        "max_stars_repo_path": "solutions/minimum_depth_of_binary_tree.cpp",
                        "max_stars_repo_name": "kmykoh97/My-Leetcode",
                        "max_stars_count": 0.0,
                        "__cluster__": 51
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_31",
                        "content": "A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.\n*   For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]`.\nThe **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n*   For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.\n*   Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.\n*   While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.\nGiven an array of integers `nums`, _find the next permutation of_ `nums`.\nThe replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory.\n**Example 1:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[1,3,2\\]\n**Example 2:**\n**Input:** nums = \\[3,2,1\\]\n**Output:** \\[1,2,3\\]\n**Example 3:**\n**Input:** nums = \\[1,1,5\\]\n**Output:** \\[1,5,1\\]\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 100`\nInput:\nnums = \\[1,2,3\\]\nOutput:\n\\[1,3,2\\]\n```cpp\n#include <algorithm>\nvoid nextPermutation(vector<int>& nums) {\nint n = nums.size(), k, l;\nfor (k = n - 2; k >= 0; k--) {\nif (nums[k] < nums[k + 1]) break;\n}\nif (k < 0) {\nreverse(nums.begin(), nums.end());\n} else {\nfor (l = n - 1; l > k; l--) {\nif (nums[l] > nums[k]) break;\n}\nswap(nums[k], nums[l]);\nreverse(nums.begin() + k + 1, nums.end());\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 305
                },
                {
                        "id": "pretrain_cpp_data_5755926",
                        "content": "<filename>Leet-Code/Next-Permutation.cpp\n// A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n//     For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1].\n// The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n//     For example, the next permutation of arr = [1,2,3] is [1,3,2].\n//     Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n//     While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n// Given an array of integers nums, find the next permutation of nums.\n// The replacement must be in place and use only constant extra memory.\n// Example 1:\n// Input: nums = [1,2,3]\n// Output: [1,3,2]\n// Example 2:\n// Input: nums = [3,2,1]\n// Output: [1,2,3]\n// Example 3:\n// Input: nums = [1,1,5]\n// Output: [1,5,1]\nclass Solution\n{\npublic:\nvoid nextPermutation(vector<int> &nums)\n{\nint blp = nums.size() - 2;\nwhile (blp >= 0 &&\nnums[blp] >= nums[blp + 1])\n--blp;\nif (blp == -1)\n{\nstd::reverse(nums.begin(), nums.end());\nreturn;\n}\nint y = std::numeric_limits<int>::max();\nint idx = blp + 1;\nfor (int i = idx; i < nums.size(); ++i)\n{\nif (nums[i] < y && nums[i] > nums[blp])\n{\ny = nums[i];\nidx = i;\n}\n}\nswap(nums[blp], nums[idx]);\nsort(nums.begin() + blp + 1, nums.end());\n}\n};",
                        "max_stars_repo_path": "Leet-Code/Next-Permutation.cpp",
                        "max_stars_repo_name": "aminzayer/CPPApps",
                        "max_stars_count": 2.0,
                        "__cluster__": 305
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_39",
                        "content": "Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.\nThe **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.\n**Example 1:**\n**Input:** candidates = \\[2,3,6,7\\], target = 7\n**Output:** \\[\\[2,2,3\\],\\[7\\]\\]\n**Explanation:**\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n**Example 2:**\n**Input:** candidates = \\[2,3,5\\], target = 8\n**Output:** \\[\\[2,2,2,2\\],\\[2,3,3\\],\\[3,5\\]\\]\n**Example 3:**\n**Input:** candidates = \\[2\\], target = 1\n**Output:** \\[\\]\n**Constraints:**\n*   `1 <= candidates.length <= 30`\n*   `2 <= candidates[i] <= 40`\n*   All elements of `candidates` are **distinct**.\n*   `1 <= target <= 40`\nInput:\ncandidates = \\[2,3,6,7\\], target = 7\nOutput:\n\\[\\[2,2,3\\],\\[7\\]\\]\n```cpp\n#include <vector>\nvoid findCombinations(std::vector<int>& candidates, int target, int startIndex, std::vector<int>& current, std::vector<std::vector<int>>& result) {\nif (target == 0) {\nresult.push_back(current);\nreturn;\n}\nif (startIndex == candidates.size() || target < 0) {\nreturn;\n}\nfindCombinations(candidates, target, startIndex + 1, current, result);\ncurrent.push_back(candidates[startIndex]);\nfindCombinations(candidates, target - candidates[startIndex], startIndex, current, result);\ncurrent.pop_back();\n}\nstd::vector<std::vector<int>> combinationSum(std::vector<int>& candidates, int target) {\nstd::vector<int> current;\nstd::vector<std::vector<int>> result;\nfindCombinations(candidates, target, 0, current, result);\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 310
                },
                {
                        "id": "pretrain_cpp_data_248584",
                        "content": "<reponame>kmykoh97/My-Leetcode\n// Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n// The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n// It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n// Example 1:\n// Input: candidates = [2,3,6,7], target = 7\n// Output: [[2,2,3],[7]]\n// Explanation:\n// 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n// 7 is a candidate, and 7 = 7.\n// These are the only two combinations.\n// Example 2:\n// Input: candidates = [2,3,5], target = 8\n// Output: [[2,2,2,2],[2,3,3],[3,5]]\n// Example 3:\n// Input: candidates = [2], target = 1\n// Output: []\n// Example 4:\n// Input: candidates = [1], target = 1\n// Output: [[1]]\n// Example 5:\n// Input: candidates = [1], target = 2\n// Output: [[1,1]]\n// Constraints:\n// 1 <= candidates.length <= 30\n// 1 <= candidates[i] <= 200\n// All elements of candidates are distinct.\n// 1 <= target <= 500\n// solution: dfs or knapsack\nclass Solution {\npublic:\nvoid helper(vector<int> &candidates, int target, vector<vector<int>> &ans, vector<int> &current, int index) {\nif (target == 0) {\nans.push_back(current);\nreturn;\n}\nif (target < 0 || index >= candidates.size()) {\nreturn;\n}\ncurrent.push_back(candidates[index]);\nhelper(candidates, target - candidates[index], ans, current, index);\ncurrent.pop_back();\nhelper(candidates, target, ans, current, index+1);\n}\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\nvector<vector<int>> ans;\nvector<int> current;\nhelper(candidates, target, ans, current, 0);\nreturn ans;\n}\n};",
                        "max_stars_repo_path": "solutions/combination_sum.cpp",
                        "max_stars_repo_name": "kmykoh97/My-Leetcode",
                        "max_stars_count": 0.0,
                        "__cluster__": 310
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_39",
                        "content": "Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.\nThe **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.\n**Example 1:**\n**Input:** candidates = \\[2,3,6,7\\], target = 7\n**Output:** \\[\\[2,2,3\\],\\[7\\]\\]\n**Explanation:**\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n**Example 2:**\n**Input:** candidates = \\[2,3,5\\], target = 8\n**Output:** \\[\\[2,2,2,2\\],\\[2,3,3\\],\\[3,5\\]\\]\n**Example 3:**\n**Input:** candidates = \\[2\\], target = 1\n**Output:** \\[\\]\n**Constraints:**\n*   `1 <= candidates.length <= 30`\n*   `2 <= candidates[i] <= 40`\n*   All elements of `candidates` are **distinct**.\n*   `1 <= target <= 40`\nInput:\ncandidates = \\[2,3,6,7\\], target = 7\nOutput:\n\\[\\[2,2,3\\],\\[7\\]\\]\n```cpp\n#include <vector>\nvoid findCombinations(std::vector<int>& candidates, int target, int startIndex, std::vector<int>& current, std::vector<std::vector<int>>& result) {\nif (target == 0) {\nresult.push_back(current);\nreturn;\n}\nif (startIndex == candidates.size() || target < 0) {\nreturn;\n}\nfindCombinations(candidates, target, startIndex + 1, current, result);\ncurrent.push_back(candidates[startIndex]);\nfindCombinations(candidates, target - candidates[startIndex], startIndex, current, result);\ncurrent.pop_back();\n}\nstd::vector<std::vector<int>> combinationSum(std::vector<int>& candidates, int target) {\nstd::vector<int> current;\nstd::vector<std::vector<int>> result;\nfindCombinations(candidates, target, 0, current, result);\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 310
                },
                {
                        "id": "pretrain_cpp_data_248584",
                        "content": "<reponame>kmykoh97/My-Leetcode\n// Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n// The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n// It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n// Example 1:\n// Input: candidates = [2,3,6,7], target = 7\n// Output: [[2,2,3],[7]]\n// Explanation:\n// 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n// 7 is a candidate, and 7 = 7.\n// These are the only two combinations.\n// Example 2:\n// Input: candidates = [2,3,5], target = 8\n// Output: [[2,2,2,2],[2,3,3],[3,5]]\n// Example 3:\n// Input: candidates = [2], target = 1\n// Output: []\n// Example 4:\n// Input: candidates = [1], target = 1\n// Output: [[1]]\n// Example 5:\n// Input: candidates = [1], target = 2\n// Output: [[1,1]]\n// Constraints:\n// 1 <= candidates.length <= 30\n// 1 <= candidates[i] <= 200\n// All elements of candidates are distinct.\n// 1 <= target <= 500\n// solution: dfs or knapsack\nclass Solution {\npublic:\nvoid helper(vector<int> &candidates, int target, vector<vector<int>> &ans, vector<int> &current, int index) {\nif (target == 0) {\nans.push_back(current);\nreturn;\n}\nif (target < 0 || index >= candidates.size()) {\nreturn;\n}\ncurrent.push_back(candidates[index]);\nhelper(candidates, target - candidates[index], ans, current, index);\ncurrent.pop_back();\nhelper(candidates, target, ans, current, index+1);\n}\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\nvector<vector<int>> ans;\nvector<int> current;\nhelper(candidates, target, ans, current, 0);\nreturn ans;\n}\n};",
                        "max_stars_repo_path": "solutions/combination_sum.cpp",
                        "max_stars_repo_name": "kmykoh97/My-Leetcode",
                        "max_stars_count": 0.0,
                        "__cluster__": 310
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_253049",
                        "content": "/*\n735. Asteroid Collision\nWe are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).\nEach asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode.\nTwo asteroids moving in the same direction will never meet.\nExample 1:\nInput: asteroids = [5,10,-5]\nOutput: [5,10]\nExplanation: The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.\nExample 2:\nInput: asteroids = [8,-8]\nOutput: []\nExplanation: The 8 and -8 collide exploding each other.\nExample 3:\nInput: asteroids = [10,2,-5]\nOutput: [10]\nExplanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.\nExample 4:\nInput: asteroids = [-2,-1,1,2]\nOutput: [-2,-1,1,2]\nExplanation: The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.\n*/\nclass Solution {\npublic:\nvector<int> asteroidCollision(vector<int>& asteroids) {\nvector<int> v;\nfor(auto i:asteroids)\n{\nif(i<0)\n{\nint n = v.size();\nif(n==0)\n{\nv.push_back(i);\n}\nelse\n{\nif(v.back()<0)\nv.push_back(i);\nelse\n{\nint d=abs(i);\nif(v.back()<=d)\n{\nint f=0;\nwhile(v.back()>0 && v.back()<=d)\n{\nif(v.back()==d)\n{\nv.pop_back();\nf=1;\nbreak;\n}\nv.pop_back();\nif(v.size()==0)\nbreak;\n}\nif(v.size()==0 && f==0)\nv.push_back(i);\nelse if(v.size()!=0 && f==0 )\n{\nif(v.back()<0)\nv.push_back(i);\n}\n}\n}\n}\n}\nelse\nv.push_back(i);\n}\nreturn v;\n}\n};",
                        "max_stars_repo_path": "C++/735. Asteroid Collision.cpp",
                        "max_stars_repo_name": "nizD/LeetCode-Solutions",
                        "max_stars_count": 263.0,
                        "__cluster__": 507
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_735",
                        "content": "We are given an array `asteroids` of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\n**Example 1:**\n**Input:** asteroids = \\[5,10,-5\\]\n**Output:** \\[5,10\\]\n**Explanation:** The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\n**Example 2:**\n**Input:** asteroids = \\[8,-8\\]\n**Output:** \\[\\]\n**Explanation:** The 8 and -8 collide exploding each other.\n**Example 3:**\n**Input:** asteroids = \\[10,2,-5\\]\n**Output:** \\[10\\]\n**Explanation:** The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.\n**Constraints:**\n*   `2 <= asteroids.length <= 104`\n*   `-1000 <= asteroids[i] <= 1000`\n*   `asteroids[i] != 0`\nInput:\nasteroids = \\[5,10,-5\\]\nOutput:\n\\[5,10\\]\n```cpp\n#include <vector>\nusing namespace std;\nvector<int> asteroidCollision(vector<int>& asteroids) {\nvector<int> s;\nfor (int i = 0; i < asteroids.size(); i++) {\nif (asteroids[i] > 0 || s.empty() || s.back() < 0) {\ns.push_back(asteroids[i]);\n} else if (s.back() <= -asteroids[i]) {\nif (s.back() < -asteroids[i]) i--;\ns.pop_back();\n}\n}\nreturn s;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 507
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_124",
                        "content": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\nThe **path sum** of a path is the sum of the node's values in the path.\nGiven the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.\n**Example 1:**\n**Input:** root = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n**Example 2:**\n**Input:** root = \\[-10,9,20,null,null,15,7\\]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[1,2,3\\]\nOutput:\n6\n```cpp\nstruct TreeNode {\nint val;\nTreeNode *left;\nTreeNode *right;\n};\nint helper(TreeNode* root, int& maxSum) {\nif(!root) return 0;\nint left = max(0, helper(root->left, maxSum));\nint right = max(0, helper(root->right, maxSum));\nmaxSum = max(maxSum, left + right + root->val);\nreturn max(left, right) + root->val;\n}\nint maxPathSum(TreeNode* root) {\nint maxSum = INT_MIN;\nhelper(root, maxSum);\nreturn maxSum;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 352
                },
                {
                        "id": "pretrain_cpp_data_1019595",
                        "content": "<reponame>devangi2000/Data-Structures-Algorithms-Handbook<filename>Trees/Binary-Tree-Maximum-Path-Sum-124.cpp<gh_stars>10-100\n// A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence\n// has an edge connecting them. A node can only appear in the sequence at most once. Note that the\n// path does not need to pass through the root.\n// The path sum of a path is the sum of the node's values in the path.\n// Given the root of a binary tree, return the maximum path sum of any path.\n// Example 1:\n// Input: root = [1,2,3]\n// Output: 6\n// Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n// Example 2:\n// Input: root = [-10,9,20,null,null,15,7]\n// Output: 42\n// Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n// Constraints:\n// The number of nodes in the tree is in the range [1, 3 * 104].\n// -1000 <= Node.val <= 1000\nclass Solution {\npublic:\nint solve(TreeNode* root, int &res){\nif(!root)\nreturn 0;\nint l = solve(root->left, res);\nint r = solve(root->right, res);\nint temp = max(max(l, r) + root->val, root->val);\nint temp2 = max(temp, root->val + l + r);\nres = max(temp2, res);\nreturn temp;\n}\nint maxPathSum(TreeNode* root) {\nif(!root) return 0;\nint res = INT_MIN;\nsolve(root, res);\nreturn res;\n}\n};",
                        "max_stars_repo_path": "Trees/Binary-Tree-Maximum-Path-Sum-124.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 352
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_637",
                        "content": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n**Example 2:**\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n\\[3.00000,14.50000,11.00000\\]\n```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct TreeNode {\nint val;\nTreeNode *left;\nTreeNode *right;\nTreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nvector<double> averageOfLevels(TreeNode* root) {\nvector<double> result;\nqueue<TreeNode*> q;\nq.push(root);\nwhile (!q.empty()) {\nlong long sum = 0;\nint count = 0;\nqueue<TreeNode*> temp;\nwhile (!q.empty()) {\nTreeNode* n = q.front();\nq.pop();\nsum += n->val;\ncount++;\nif (n->left) temp.push(n->left);\nif (n->right) temp.push(n->right);\n}\nq = temp;\nresult.push_back(static_cast<double>(sum) / count);\n}\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 31
                },
                {
                        "id": "pretrain_cpp_data_1826742",
                        "content": "//637. Average of Levels in Binary Tree\n/*\nGiven the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\nExample 2:\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n*/\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<double> averageOfLevels(TreeNode* root) {\nif(!root){\nreturn {};\n}\nvector<double> output;\nqueue<TreeNode*> q;\nint n,i;\ndouble sum;\nTreeNode* curr=NULL;\nq.push(root);\nwhile(!q.empty()){\nsum=0;\nn=q.size();\nfor(i=0;i<n;i++){\ncurr=q.front();\nq.pop();\nsum+=curr->val;\nif(curr->left) q.push(curr->left);\nif(curr->right) q.push(curr->right);\n}\noutput.push_back((double)sum/n);\n}\nreturn output;\n}\n};",
                        "max_stars_repo_path": "637_Average_of_Levels _in_Binary_Tree.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 31
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_637",
                        "content": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n**Example 1:**\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return \\[3, 14.5, 11\\].\n**Example 2:**\n**Input:** root = \\[3,9,20,15,7\\]\n**Output:** \\[3.00000,14.50000,11.00000\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`\nInput:\nroot = \\[3,9,20,null,null,15,7\\]\nOutput:\n\\[3.00000,14.50000,11.00000\\]\n```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct TreeNode {\nint val;\nTreeNode *left;\nTreeNode *right;\nTreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nvector<double> averageOfLevels(TreeNode* root) {\nvector<double> result;\nqueue<TreeNode*> q;\nq.push(root);\nwhile (!q.empty()) {\nlong long sum = 0;\nint count = 0;\nqueue<TreeNode*> temp;\nwhile (!q.empty()) {\nTreeNode* n = q.front();\nq.pop();\nsum += n->val;\ncount++;\nif (n->left) temp.push(n->left);\nif (n->right) temp.push(n->right);\n}\nq = temp;\nresult.push_back(static_cast<double>(sum) / count);\n}\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 31
                },
                {
                        "id": "pretrain_cpp_data_1826742",
                        "content": "//637. Average of Levels in Binary Tree\n/*\nGiven the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\nExample 2:\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n*/\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<double> averageOfLevels(TreeNode* root) {\nif(!root){\nreturn {};\n}\nvector<double> output;\nqueue<TreeNode*> q;\nint n,i;\ndouble sum;\nTreeNode* curr=NULL;\nq.push(root);\nwhile(!q.empty()){\nsum=0;\nn=q.size();\nfor(i=0;i<n;i++){\ncurr=q.front();\nq.pop();\nsum+=curr->val;\nif(curr->left) q.push(curr->left);\nif(curr->right) q.push(curr->right);\n}\noutput.push_back((double)sum/n);\n}\nreturn output;\n}\n};",
                        "max_stars_repo_path": "637_Average_of_Levels _in_Binary_Tree.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 31
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_1809762",
                        "content": "<gh_stars>1-10\n/*\nReverse Nodes in k-Group\n========================\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\nExample 1:\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\nExample 2:\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\nExample 3:\nInput: head = [1,2,3,4,5], k = 1\nOutput: [1,2,3,4,5]\nExample 4:\nInput: head = [1], k = 1\nOutput: [1]\nConstraints:\nThe number of nodes in the list is in the range sz.\n1 <= sz <= 5000\n0 <= Node.val <= 1000\n1 <= k <= sz\nFollow-up: Can you solve the problem in O(1) extra memory space?\n*/\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution\n{\npublic:\nListNode *reverseKGroup(ListNode *head, int k)\n{\nif (!head)\nreturn NULL;\nauto temp = head;\nint i = 1;\nwhile (i < k && temp->next)\n{\ntemp = temp->next;\ni++;\n}\nif (i != k)\nreturn head;\nauto subAns = reverseKGroup(temp->next, k);\nauto start = head, end = temp->next;\nauto prev = subAns;\nwhile (start != end)\n{\nauto next = start->next;\nstart->next = prev;\nprev = start;\nstart = next;\n}\nreturn prev;\n}\n};",
                        "max_stars_repo_path": "Leetcode Daily Challenge/July-2021/18. Reverse Nodes in k-Group.cpp",
                        "max_stars_repo_name": "Akshad7829/DataStructures-Algorithms",
                        "max_stars_count": 5.0,
                        "__cluster__": 303
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_25",
                        "content": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return _the modified list_.\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n**Example 1:**\n**Input:** head = \\[1,2,3,4,5\\], k = 2\n**Output:** \\[2,1,4,3,5\\]\n**Example 2:**\n**Input:** head = \\[1,2,3,4,5\\], k = 3\n**Output:** \\[3,2,1,4,5\\]\n**Constraints:**\n*   The number of nodes in the list is `n`.\n*   `1 <= k <= n <= 5000`\n*   `0 <= Node.val <= 1000`\n**Follow-up:** Can you solve the problem in `O(1)` extra memory space?\nInput:\nhead = \\[1,2,3,4,5\\], k = 2\nOutput:\n\\[2,1,4,3,5\\]\n```cpp\nstruct ListNode {\nint val;\nListNode *next;\nListNode() : val(0), next(nullptr) {}\nListNode(int x) : val(x), next(nullptr) {}\nListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nListNode* reverseKGroup(ListNode* head, int k) {\nif (head == nullptr || k == 1) return head;\nint len = 0;\nListNode *cur = head;\nwhile (cur != nullptr) {\nlen++;\ncur = cur->next;\n}\nListNode dummy(0);\ndummy.next = head;\nListNode *prev = &dummy;\ncur = head;\nwhile (len >= k) {\nfor (int i = 1; i < k; i++) {\nListNode *temp = cur->next;\ncur->next = temp->next;\ntemp->next = prev->next;\nprev->next = temp;\n}\nprev = cur;\ncur = cur->next;\nlen -= k;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 303
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_81",
                        "content": "There is an integer array `nums` sorted in non-decreasing order (not necessarily with **distinct** values).\nBefore being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index `5` and become `[4,5,6,6,7,0,1,2,4,4]`.\nGiven the array `nums` **after** the rotation and an integer `target`, return `true` _if_ `target` _is in_ `nums`_, or_ `false` _if it is not in_ `nums`_._\nYou must decrease the overall operation steps as much as possible.\n**Example 1:**\n**Input:** nums = \\[2,5,6,0,0,1,2\\], target = 0\n**Output:** true\n**Example 2:**\n**Input:** nums = \\[2,5,6,0,0,1,2\\], target = 3\n**Output:** false\n**Constraints:**\n*   `1 <= nums.length <= 5000`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is guaranteed to be rotated at some pivot.\n*   `-104 <= target <= 104`\n**Follow up:** This problem is similar to Search in Rotated Sorted Array, but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?\nInput:\nnums = \\[2,5,6,0,0,1,2\\], target = 0\nOutput:\ntrue\n```cpp\nbool search(vector<int>& nums, int target) {\nint left = 0, right = nums.size() - 1;\nwhile (left <= right) {\nint mid = left + (right - left) / 2;\nif (nums[mid] == target) return true;\nif (nums[mid] == nums[left]) {\nleft++;\n} else if (nums[mid] > nums[left]) {\nif (nums[left] <= target && target < nums[mid]) {\nright = mid - 1;\n} else {\nleft = mid + 1;\n}\n} else {\nif (nums[mid] < target && target <= nums[right]) {\nleft = mid + 1;\n} else {\nright = mid - 1;\n}\n}\n}\nreturn false;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 332
                },
                {
                        "id": "pretrain_cpp_data_2613441",
                        "content": "<gh_stars>0\n/**\n* 4.4 \u65cb\u8f6c\u6570\u7ec4\u67e5\u627e\u6570\u5b57\n* 81. Search in Rotated Sorted Array II(Medium)\n*\n* There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\n*\n* Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length)\n* such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed).\n* For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\n*\n* Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\n* You must decrease the overall operation steps as much as possible.\n*\n* Input: nums = [2,5,6,0,0,1,2], target = 0, Output: true\n*\n* Input: nums = [2,5,6,0,0,1,2], target = 3, Output: false\n*\n* Constraints:\n*  * 1 <= nums.length <= 5000\n*  * -10^4 <= nums[i] <= 10^4\n*  * nums is guaranteed to be rotated at some pivot.\n*  * -10^4 <= target <= 10^4\n*\n* Follow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates.\n* Would this affect the runtime complexity? How and why?\n*/\nbool search(vector<int>& nums, int target) {\nint l = 0, r = nums.size() - 1, mid;\nwhile (l <= r) {\nmid = l + (r - l) / 2;\nif (nums[mid] == target) return true;\nif (nums[l] == nums[mid]) { // have no idea about the array, but we can exclude nums[l] because nums[l] == nums[mid]\n++l;\n} else if (nums[mid] <= nums[r]) { // right region is increasing\nif (target > nums[mid] && target <= nums[r]) {\nl = mid + 1;\n} else {\nr = mid - 1;\n}\n} else { // left region is increasing\nif (target < nums[mid] && target >= nums[l]) {\nr = mid - 1;\n} else {\nl = mid + 1;\n}\n}\n}\nreturn false;\n}",
                        "max_stars_repo_path": "Ch04_Binary_Search/081_Search_In_Rotated_Sorted_Array_II.cpp",
                        "max_stars_repo_name": "Frodocz/LeetCode101",
                        "max_stars_count": 0.0,
                        "__cluster__": 332
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_188",
                        "content": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.\nFind the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times.\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n**Example 1:**\n**Input:** k = 2, prices = \\[2,4,1\\]\n**Output:** 2\n**Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n**Example 2:**\n**Input:** k = 2, prices = \\[3,2,6,5,0,3\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n**Constraints:**\n*   `1 <= k <= 100`\n*   `1 <= prices.length <= 1000`\n*   `0 <= prices[i] <= 1000`\nInput:\nk = 2, prices = \\[2,4,1\\]\nOutput:\n2\n```cpp\n#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices) {\nint n = prices.size();\nif (k > n / 2) {\nint max_profit = 0;\nfor (int i = 1; i < n; ++i)\nmax_profit += std::max(prices[i] - prices[i - 1], 0);\nreturn max_profit;\n}\nstd::vector<std::vector<int>> dp(k + 1, std::vector<int>(n, 0));\nfor (int i = 1; i <= k; ++i) {\nint max_diff = -prices[0];\nfor (int j = 1; j < n; ++j) {\ndp[i][j] = std::max(dp[i][j - 1], prices[j] + max_diff);\nmax_diff = std::max(max_diff, dp[i - 1][j] - prices[j]);\n}\n}\nreturn dp[k][n - 1];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 363
                },
                {
                        "id": "pretrain_cpp_data_2675194",
                        "content": "<filename>188_Best_Time_to_Buy_and_Sell_Stock_IV.cpp\n/*\n188. Best Time to Buy and Sell Stock IV\nHard\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\nExample 2:\nInput: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nConstraints:\n0 <= k <= 100\n0 <= prices.length <= 1000\n0 <= prices[i] <= 1000\n*/\nclass Solution {\npublic:\nint maxProfit(int k, vector<int>& prices) {\nint n=prices.size();\nif(k<=0 || n<=1) return 0;\nvector<int> buy(k,INT_MIN),sell(k,0);\nbuy[0]=-prices[0];\nfor(int i=1;i<n;i++){\nfor(int j=0;j<k;j++){\nif(j==0){\nbuy[j]=max(buy[j],-prices[i]);\n}else{\nbuy[j]=max(buy[j],sell[j-1]-prices[i]);\n}\nsell[j]=max(sell[j],buy[j]+prices[i]);\n}\n}\nreturn sell[k-1];\n}\n};",
                        "max_stars_repo_path": "188_Best_Time_to_Buy_and_Sell_Stock_IV.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 363
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_3415056",
                        "content": "/*\n454. 4Sum II\nMedium\nGiven four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n0 <= i, j, k, l < n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\nExample 1:\nInput: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\nOutput: 2\nExplanation:\nThe two tuples are:\n1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\nExample 2:\nInput: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\nOutput: 1\nConstraints:\nn == nums1.length\nn == nums2.length\nn == nums3.length\nn == nums4.length\n1 <= n <= 200\n-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228\n*/\nclass Solution {\npublic:\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\nunordered_map<int,int> abmap;\nfor(auto a:nums1){\nfor(auto b:nums2){\n++abmap[a+b];\n}\n}\nint count=0;\nfor(auto a:nums3){\nfor(auto b:nums4){\nauto it=abmap.find(-1*(a+b));\nif(it!=abmap.end()){\ncount+=it->second;\n}\n}\n}\nreturn count;\n}\n};",
                        "max_stars_repo_path": "454_4Sum_II.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 452
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_454",
                        "content": "Given four integer arrays `nums1`, `nums2`, `nums3`, and `nums4` all of length `n`, return the number of tuples `(i, j, k, l)` such that:\n*   `0 <= i, j, k, l < n`\n*   `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`\n**Example 1:**\n**Input:** nums1 = \\[1,2\\], nums2 = \\[-2,-1\\], nums3 = \\[-1,2\\], nums4 = \\[0,2\\]\n**Output:** 2\n**Explanation:**\nThe two tuples are:\n1. (0, 0, 0, 1) -> nums1\\[0\\] + nums2\\[0\\] + nums3\\[0\\] + nums4\\[1\\] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> nums1\\[1\\] + nums2\\[1\\] + nums3\\[0\\] + nums4\\[0\\] = 2 + (-1) + (-1) + 0 = 0\n**Example 2:**\n**Input:** nums1 = \\[0\\], nums2 = \\[0\\], nums3 = \\[0\\], nums4 = \\[0\\]\n**Output:** 1\n**Constraints:**\n*   `n == nums1.length`\n*   `n == nums2.length`\n*   `n == nums3.length`\n*   `n == nums4.length`\n*   `1 <= n <= 200`\n*   `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`\nInput:\nnums1 = \\[1,2\\], nums2 = \\[-2,-1\\], nums3 = \\[-1,2\\], nums4 = \\[0,2\\]\nOutput:\n2\n```cpp\n#include <unordered_map>\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\nunordered_map<int, int> hashMap;\nint count = 0;\nfor (auto i : nums1) {\nfor (auto j : nums2) {\nhashMap[i + j]++;\n}\n}\nfor (auto k : nums3) {\nfor (auto l : nums4) {\ncount += hashMap[-(k + l)];\n}\n}\nreturn count;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 452
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_5047011",
                        "content": "<filename>Single Linked List/Swap Nodes in Pairs.cpp\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\nExample 1:\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\nExample 2:\nInput: head = []\nOutput: []\nExample 3:\nInput: head = [1]\nOutput: [1]\nConstraints:\nThe number of nodes in the list is in the range [0, 100].\n0 <= Node.val <= 100\nclass Solution {\npublic:\nListNode* swapPairs(ListNode* head) {\nif(head==NULL)\nreturn NULL;\nListNode* temp=head;\nListNode* temp1=temp->next;\nwhile(temp && temp1==NULL)\nreturn head;\nwhile(temp && temp1)\n{\nswap(temp->val,temp1->val);\n//cout<<temp->val<<\" \"<<temp1->val<<endl;\ntemp=temp1->next;\nif(temp1->next)\ntemp1=temp1->next->next;\n}\nreturn head;\n}\n};",
                        "max_stars_repo_path": "Single Linked List/Swap Nodes in Pairs.cpp",
                        "max_stars_repo_name": "rcvenky/Data_Structures_Algo",
                        "max_stars_count": 0.0,
                        "__cluster__": 302
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_24",
                        "content": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n**Example 1:**\n**Input:** head = \\[1,2,3,4\\]\n**Output:** \\[2,1,4,3\\]\n**Example 2:**\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n**Example 3:**\n**Input:** head = \\[1\\]\n**Output:** \\[1\\]\n**Constraints:**\n*   The number of nodes in the list is in the range `[0, 100]`.\n*   `0 <= Node.val <= 100`\nInput:\nhead = \\[1,2,3,4\\]\nOutput:\n\\[2,1,4,3\\]\n```cpp\nListNode* swapPairs(ListNode* head) {\nif (!head || !head->next) return head;\nListNode* second = head->next;\nhead->next = swapPairs(second->next);\nsecond->next = head;\nreturn second;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 302
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_5819368",
                        "content": "<gh_stars>10-100\n// You are given an integer array nums. You are initially positioned at the array's first index,\n// and each element in the array represents your maximum jump length at that position.\n// Return true if you can reach the last index, or false otherwise.\n// Example 1:\n// Input: nums = [2,3,1,1,4]\n// Output: true\n// Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n// Example 2:\n// Input: nums = [3,2,1,0,4]\n// Output: false\n// Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0,\n// which makes it impossible to reach the last index.\n// Constraints:\n// 1 <= nums.length <= 104\n// 0 <= nums[i] <= 105\nclass Solution {\npublic:\nbool canJump(vector<int>& nums) {\nint n = nums.size(), farthest = 0;\nfor(int i = 0; i < nums.size() and i <= farthest; i++){\nfarthest = max(farthest, i + nums[i]);\n}\nreturn farthest >= n-1;\n}\n};",
                        "max_stars_repo_path": "Dynamic Programming/JumpGame55.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 318
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_55",
                        "content": "You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\nReturn `true` _if you can reach the last index, or_ `false` _otherwise_.\n**Example 1:**\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** true\n**Explanation:** Jump 1 step from index 0 to 1, then 3 steps to the last index.\n**Example 2:**\n**Input:** nums = \\[3,2,1,0,4\\]\n**Output:** false\n**Explanation:** You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n**Constraints:**\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 105`\nInput:\nnums = \\[2,3,1,1,4\\]\nOutput:\ntrue\n```cpp\nbool canJump(vector<int>& nums) {\nint maxReach = 0;\nfor (int i = 0; i < nums.size(); ++i) {\nif (i > maxReach) return false;\nmaxReach = max(maxReach, i + nums[i]);\n}\nreturn true;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 318
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_445",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[7,2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,8,0,7\\]\n**Example 2:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[8,0,7\\]\n**Example 3:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\n**Follow up:** Could you solve it without reversing the input lists?\nInput:\nl1 = \\[7,2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,8,0,7\\]\n```cpp\nstruct ListNode {\nint val;\nListNode *next;\nListNode(int x) : val(x), next(nullptr) {}\n};\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nListNode* result = nullptr;\nListNode** current = &result;\nint carry = 0;\nwhile (l1 || l2 || carry) {\nint sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\ncarry = sum / 10;\n*current = new ListNode(sum % 10);\ncurrent = &((*current)->next);\nif (l1) l1 = l1->next;\nif (l2) l2 = l2->next;\n}\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 449
                },
                {
                        "id": "pretrain_cpp_data_381122",
                        "content": "<gh_stars>10-100\n// You are given two non-empty linked lists representing two non-negative integers.\n// The most significant digit comes first and each of their nodes contains a single digit.\n//  Add the two numbers and return the sum as a linked list.\n// You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n// Example 1:\n// Input: l1 = [7,2,4,3], l2 = [5,6,4]\n// Output: [7,8,0,7]\n// Example 2:\n// Input: l1 = [2,4,3], l2 = [5,6,4]\n// Output: [8,0,7]\n// Example 3:\n// Input: l1 = [0], l2 = [0]\n// Output: [0]\n// Constraints:\n// The number of nodes in each linked list is in the range [1, 100].\n// 0 <= Node.val <= 9\n// It is guaranteed that the list represents a number that does not have leading zeros.\n// Follow up: Could you solve it without reversing the input lists?\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nstack<ListNode*> st1, st2;\nwhile(l1){\nst1.push(l1);\nl1 = l1->next;\n}\nwhile(l2){\nst2.push(l2);\nl2 = l2->next;\n}\nint carry = 0;\nListNode* head = nullptr;\nwhile(st1.size() or st2.size() or carry){\nint sum = 0;\nif(!st1.empty()){\nsum += st1.top()->val;\nst1.pop();\n}\nif(!st2.empty()){\nsum += st2.top()->val;\nst2.pop();\n}\nsum += carry;\ncarry = sum / 10;\nListNode* node = new ListNode(sum % 10);\nnode->next = head;\nhead = node;\n}\nreturn head;\n}\n};\n",
                        "max_stars_repo_path": "Linked-Lists/AddTwoNumbers2-445.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 449
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_113",
                        "content": "Given the `root` of a binary tree and an integer `targetSum`, return _all **root-to-leaf** paths where the sum of the node values in the path equals_ `targetSum`_. Each path should be returned as a list of the node **values**, not node references_.\nA **root-to-leaf** path is a path starting from the root and ending at any leaf node. A **leaf** is a node with no children.\n**Example 1:**\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,5,1\\], targetSum = 22\n**Output:** \\[\\[5,4,11,2\\],\\[5,8,4,5\\]\\]\n**Explanation:** There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n**Example 2:**\n**Input:** root = \\[1,2,3\\], targetSum = 5\n**Output:** \\[\\]\n**Example 3:**\n**Input:** root = \\[1,2\\], targetSum = 0\n**Output:** \\[\\]\n**Constraints:**\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`\nInput:\nroot = \\[5,4,8,11,null,13,4,7,2,null,null,5,1\\], targetSum = 22\nOutput:\n\\[\\[5,4,11,2\\],\\[5,8,4,5\\]\\]\n```cpp\nstruct TreeNode {\nint val;\nTreeNode* left;\nTreeNode* right;\nTreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nvoid helper(TreeNode* root, int targetSum, vector<int>& current, vector<vector<int>>& ans) {\nif (!root) return;\ncurrent.push_back(root->val);\nif (!root->left && !root->right && targetSum == root->val) {\nans.push_back(current);\n}\nhelper(root->left, targetSum - root->val, current, ans);\nhelper(root->right, targetSum - root->val, current, ans);\ncurrent.pop_back();\n}\nvector<vector<int>> pathSum(TreeNode* root, int targetSum) {\nvector<vector<int>> ans;\nvector<int> current;\nhelper(root, targetSum, current, ans);\nreturn ans;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 346
                },
                {
                        "id": "pretrain_cpp_data_1945033",
                        "content": "<filename>113_Path_Sum_II.cpp\n/*\n113. Path Sum II\nMedium\nGiven the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.\nA root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: [[5,4,11,2],[5,8,4,5]]\nExplanation: There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\nExample 2:\nInput: root = [1,2,3], targetSum = 5\nOutput: []\nExample 3:\nInput: root = [1,2], targetSum = 0\nOutput: []\nConstraints:\nThe number of nodes in the tree is in the range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n*/\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\nvector<vector<int>> ans;\nvoid helper(TreeNode* root, vector<int> &path,int targetSum){\nif(!root){return;}\nif(!root->left && !root->right && root->val==targetSum){\npath.push_back(root->val);\nans.push_back(path);\npath.pop_back();\nreturn;\n}\npath.push_back(root->val);\nhelper(root->left,path,targetSum-root->val);\nhelper(root->right,path,targetSum-root->val);\npath.pop_back();\n}\npublic:\nvector<vector<int>> pathSum(TreeNode* root, int targetSum) {\nvector<int> path;\nhelper(root,path,targetSum);\nreturn ans;\n}\n};",
                        "max_stars_repo_path": "113_Path_Sum_II.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 346
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```cpp\nint rob(vector<int>& nums) {\nint prev1 = 0, prev2 = 0;\nfor (const auto& num : nums) {\nint tmp = prev1;\nprev1 = max(prev2 + num, prev1);\nprev2 = tmp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "id": "pretrain_cpp_data_1192318",
                        "content": "/*\nProblem - You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically\ncontact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nint rob(vector<int>& nums) {\nint n = nums.size();\nif(n == 0){\nreturn 0;\n}\nif(n == 1){\nreturn nums[0];\n}\nint dp[n];\nfor(int i = 0; i < n; i++){\ndp[i] = nums[i];\n}\ndp[0] = nums[0];\ndp[1] = max(nums[0], nums[1]);\nfor(int i = 2; i < n; i++){\ndp[i] = dp[i] + dp[i-2];\nif(dp[i] < dp[i-1]){\ndp[i] = dp[i-1];\n}\n}\nreturn dp[n-1];\n}\nint main()\n{\nint n;\ncin >> n;\nvector<int>nums(n);\nfor(int i=0;i<n;i++){\ncin>> nums[i];\n}\ncout << rob(nums) << endl;\nreturn 0;\n}",
                        "max_stars_repo_path": "dynamic_programing/C++/HouseRobber.cpp",
                        "max_stars_repo_name": "Utsav1510/al-go-rithms",
                        "max_stars_count": 1253.0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```cpp\nint rob(vector<int>& nums) {\nint prev1 = 0, prev2 = 0;\nfor (const auto& num : nums) {\nint tmp = prev1;\nprev1 = max(prev2 + num, prev1);\nprev2 = tmp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "id": "pretrain_cpp_data_1192318",
                        "content": "/*\nProblem - You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically\ncontact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nint rob(vector<int>& nums) {\nint n = nums.size();\nif(n == 0){\nreturn 0;\n}\nif(n == 1){\nreturn nums[0];\n}\nint dp[n];\nfor(int i = 0; i < n; i++){\ndp[i] = nums[i];\n}\ndp[0] = nums[0];\ndp[1] = max(nums[0], nums[1]);\nfor(int i = 2; i < n; i++){\ndp[i] = dp[i] + dp[i-2];\nif(dp[i] < dp[i-1]){\ndp[i] = dp[i-1];\n}\n}\nreturn dp[n-1];\n}\nint main()\n{\nint n;\ncin >> n;\nvector<int>nums(n);\nfor(int i=0;i<n;i++){\ncin>> nums[i];\n}\ncout << rob(nums) << endl;\nreturn 0;\n}",
                        "max_stars_repo_path": "dynamic_programing/C++/HouseRobber.cpp",
                        "max_stars_repo_name": "Utsav1510/al-go-rithms",
                        "max_stars_count": 1253.0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```cpp\nint rob(vector<int>& nums) {\nint prev1 = 0, prev2 = 0;\nfor (const auto& num : nums) {\nint tmp = prev1;\nprev1 = max(prev2 + num, prev1);\nprev2 = tmp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "id": "pretrain_cpp_data_1192318",
                        "content": "/*\nProblem - You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed,\nthe only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically\ncontact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nint rob(vector<int>& nums) {\nint n = nums.size();\nif(n == 0){\nreturn 0;\n}\nif(n == 1){\nreturn nums[0];\n}\nint dp[n];\nfor(int i = 0; i < n; i++){\ndp[i] = nums[i];\n}\ndp[0] = nums[0];\ndp[1] = max(nums[0], nums[1]);\nfor(int i = 2; i < n; i++){\ndp[i] = dp[i] + dp[i-2];\nif(dp[i] < dp[i-1]){\ndp[i] = dp[i-1];\n}\n}\nreturn dp[n-1];\n}\nint main()\n{\nint n;\ncin >> n;\nvector<int>nums(n);\nfor(int i=0;i<n;i++){\ncin>> nums[i];\n}\ncout << rob(nums) << endl;\nreturn 0;\n}",
                        "max_stars_repo_path": "dynamic_programing/C++/HouseRobber.cpp",
                        "max_stars_repo_name": "Utsav1510/al-go-rithms",
                        "max_stars_count": 1253.0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_2709349",
                        "content": "/*\n213. House Robber II\nMedium\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [1,2,3]\nOutput: 3\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000\n*/\nclass Solution {\npublic:\nint rob(vector<int>& nums) {\nint n=nums.size();\nif(n<2) return n?nums[0]:0;\nreturn max(rob(nums,0,n-2),rob(nums,1,n-1));\n}\nprivate:\nint rob(vector<int>& nums,int l,int r){\nint pre=0,curr=0,temp;\nfor(int i=l;i<=r;i++){\ntemp=max(pre+nums[i],curr);\npre=curr;\ncurr=temp;\n}\nreturn curr;\n}\n};",
                        "max_stars_repo_path": "213_House_Robber_II.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 381
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```cpp\nint rob(vector<int>& nums) {\nif (nums.size() == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.size() - 1; i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.size(); i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 381
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_2781848",
                        "content": "//You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n//\n//Given a list of non-negative integers nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n//\n//\n//\n//Example 1:\n//\n//Input: nums = [2,3,2]\n//Output: 3\n//Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n//Example 2:\n//\n//Input: nums = [1,2,3,1]\n//Output: 4\n//Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n//Total amount you can rob = 1 + 3 = 4.\n//Example 3:\n//\n//Input: nums = [0]\n//Output: 0\nclass Solution {\npublic:\nint rob(vector<int>& nums) {\n}\n};",
                        "max_stars_repo_path": "leetcode_solutions/curated_top_100/dynamic_programming/s_213_House_Robber_II_20201110.cpp",
                        "max_stars_repo_name": "lovms/code_snippets",
                        "max_stars_count": 0.0,
                        "__cluster__": 381
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```cpp\nint rob(vector<int>& nums) {\nif (nums.size() == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.size() - 1; i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.size(); i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 381
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_3559238",
                        "content": "/*\nProblem: Bulb Switcher - II\nThere is a room with n bulbs labeled from 1 to n that all\nare turned on initially, and four buttons on the wall. Each\nof the four buttons has a different functionality where:\nButton 1: Flips the status of all the bulbs.\nButton 2: Flips the status of all the bulbs with even labels (i.e., 2, 4, ...).\nButton 3: Flips the status of all the bulbs with odd labels (i.e., 1, 3, ...).\nButton 4: Flips the status of all the bulbs with a label j = 3k + 1 where k = 0, 1, 2, ... (i.e., 1, 4, 7, 10, ...).\nYou must make exactly presses button presses in total. For each press, you may pick any of the four buttons to press.\nGiven the two integers n and presses, return the number of different possible\nstatuses after performing all presses button presses.\n*/\n// Code\nclass Solution {\npublic:\nint flipLights(int n, int p) {\nif(p == 0) return 1;\nif(n == 1) return 2;\nif(n == 2) return p == 1 ? 3 : 4;\nelse return p == 1 ? 4 : p == 2 ? 7 : 8;\n}\n};\n/*\nInput: n = 2, presses = 1\nOutput: 3\nExplanation: Status can be:\n- [off, off] by pressing button 1\n- [on, off] by pressing button 2\n- [off, on] by pressing button 3\n*/",
                        "max_stars_repo_path": "C-Plus-Plus/other/bulb_switch_II.cpp",
                        "max_stars_repo_name": "yashsahay2014/NeoAlgo",
                        "max_stars_count": 897.0,
                        "__cluster__": 490
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_672",
                        "content": "There is a room with `n` bulbs labeled from `1` to `n` that all are turned on initially, and **four buttons** on the wall. Each of the four buttons has a different functionality where:\n*   **Button 1:** Flips the status of all the bulbs.\n*   **Button 2:** Flips the status of all the bulbs with even labels (i.e., `2, 4, ...`).\n*   **Button 3:** Flips the status of all the bulbs with odd labels (i.e., `1, 3, ...`).\n*   **Button 4:** Flips the status of all the bulbs with a label `j = 3k + 1` where `k = 0, 1, 2, ...` (i.e., `1, 4, 7, 10, ...`).\nYou must make **exactly** `presses` button presses in total. For each press, you may pick **any** of the four buttons to press.\nGiven the two integers `n` and `presses`, return _the number of **different possible statuses** after performing all_ `presses` _button presses_.\n**Example 1:**\n**Input:** n = 1, presses = 1\n**Output:** 2\n**Explanation:** Status can be:\n- \\[off\\] by pressing button 1\n- \\[on\\] by pressing button 2\n**Example 2:**\n**Input:** n = 2, presses = 1\n**Output:** 3\n**Explanation:** Status can be:\n- \\[off, off\\] by pressing button 1\n- \\[on, off\\] by pressing button 2\n- \\[off, on\\] by pressing button 3\n**Example 3:**\n**Input:** n = 3, presses = 1\n**Output:** 4\n**Explanation:** Status can be:\n- \\[off, off, off\\] by pressing button 1\n- \\[off, on, off\\] by pressing button 2\n- \\[on, off, on\\] by pressing button 3\n- \\[off, on, on\\] by pressing button 4\n**Constraints:**\n*   `1 <= n <= 1000`\n*   `0 <= presses <= 1000`\nInput:\nn = 1, presses = 1\nOutput:\n2\n```cpp\n#include <vector>\nint numLightConfiguration(int n, int presses) {\nstd::vector<std::vector<int>> dp(n + 1, std::vector<int>(presses + 1, 0));\ndp[0][0] = 1;\nfor (int i = 0; i <= n; ++i) {\nfor (int j = 1; j <= presses; ++j) {\ndp[i][j] = dp[i][j - 1] * (i + 1) + (i > 0 ? dp[i - 1][j - 1] : 0);\n}\n}\nreturn dp[n][presses];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 490
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```cpp\nstruct ListNode {\nint val;\nListNode *next;\nListNode(int x) : val(x), next(nullptr) {}\n};\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nListNode dummy(0);\nListNode* current = &dummy;\nint carry = 0;\nwhile (l1 || l2 || carry) {\nint sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\ncarry = sum / 10;\ncurrent->next = new ListNode(sum % 10);\ncurrent = current->next;\nif (l1) l1 = l1->next;\nif (l2) l2 = l2->next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 292
                },
                {
                        "id": "pretrain_cpp_data_4336752",
                        "content": "Add Two Numbers\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros\n//Coding\nclass Solution {\npublic:\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nListNode* l3=new ListNode(), *curr=l3;\nint carry=0;\nwhile(l1||l2||carry)\n{\nif(l1!=NULL)\n{\ncarry+=l1->val;\nl1=l1->next;\n}\nif(l2!=NULL)\n{\ncarry+=l2->val;\nl2=l2->next;\n}\ncurr->next=new ListNode(carry%10);\ncarry/=10;\ncurr=curr->next;\n}\nreturn l3->next;\n}\n};",
                        "max_stars_repo_path": "Single Linked List/add two numbers.cpp",
                        "max_stars_repo_name": "rcvenky/Data_Structures_Algo",
                        "max_stars_count": 0.0,
                        "__cluster__": 292
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_16",
                        "content": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.\nReturn _the sum of the three integers_.\nYou may assume that each input would have exactly one solution.\n**Example 1:**\n**Input:** nums = \\[-1,2,1,-4\\], target = 1\n**Output:** 2\n**Explanation:** The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n**Example 2:**\n**Input:** nums = \\[0,0,0\\], target = 1\n**Output:** 0\n**Explanation:** The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n**Constraints:**\n*   `3 <= nums.length <= 500`\n*   `-1000 <= nums[i] <= 1000`\n*   `-104 <= target <= 104`\nInput:\nnums = \\[-1,2,1,-4\\], target = 1\nOutput:\n2\n```cpp\n#include <algorithm>\n#include <vector>\nint threeSumClosest(std::vector<int>& nums, int target) {\nstd::sort(nums.begin(), nums.end());\nint closest = nums[0] + nums[1] + nums[2];\nfor (int i = 0; i < nums.size() - 2; ++i) {\nint left = i + 1;\nint right = nums.size() - 1;\nwhile (left < right) {\nint sum = nums[i] + nums[left] + nums[right];\nif (sum == target) {\nreturn sum;\n}\nif (abs(target - sum) < abs(target - closest)) {\nclosest = sum;\n}\nif (sum < target) {\nleft++;\n} else {\nright--;\n}\n}\n}\nreturn closest;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 297
                },
                {
                        "id": "pretrain_cpp_data_4353199",
                        "content": "// Given an array nums of n integers and an integer target, find three integers in nums such\n// that the sum is closest to target. Return the sum of the three integers. You may assume\n// that each input would have exactly one solution.\n// Example 1:\n// Input: nums = [-1,2,1,-4], target = 1\n// Output: 2\n// Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n// Constraints:\n// 3 <= nums.length <= 10^3\n// -10^3 <= nums[i] <= 10^3\n// -10^4 <= target <= 10^4\nclass Solution {\npublic:\nint threeSumClosest(vector<int>& nums, int target) {\nint n = nums.size();\nif(n < 3) return 0;\nsort(nums.begin(), nums.end());\nint sum = nums[0] + nums[1] + nums[2];\nint closest = sum;\nfor(int i = 0; i < n-2; i++){\nif(i > 0 && nums[i] == nums[i-1]) continue;\nint low = i+1, high = n-1;\nwhile(low < high){\nsum = nums[i] + nums[low] + nums[high];\nif(sum == target){\nreturn sum;\n}\nelse if(sum < target){\nwhile(low < high and nums[low]==nums[low+1]) low++;\nlow++;\n}\nelse if(sum > target){\nwhile(high > low and nums[high] == nums[high-1]) high--;\nhigh--;\n}\nclosest = abs(target - sum) > abs(target - closest) ? closest : sum;\n}\n}\nreturn closest;\n}\n};",
                        "max_stars_repo_path": "Two Pointers/3Sum-Closest-16.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 297
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_283",
                        "content": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.\n**Note** that you must do this in-place without making a copy of the array.\n**Example 1:**\n**Input:** nums = \\[0,1,0,3,12\\]\n**Output:** \\[1,3,12,0,0\\]\n**Example 2:**\n**Input:** nums = \\[0\\]\n**Output:** \\[0\\]\n**Constraints:**\n*   `1 <= nums.length <= 104`\n*   `-231 <= nums[i] <= 231 - 1`\n**Follow up:** Could you minimize the total number of operations done?\nInput:\nnums = \\[0,1,0,3,12\\]\nOutput:\n\\[1,3,12,0,0\\]\n```cpp\nvoid moveZeroes(vector<int>& nums) {\nint index = 0;\nfor (int i = 0; i < nums.size(); i++) {\nif (nums[i] != 0) {\nnums[index++] = nums[i];\n}\n}\nfor (int i = index; i < nums.size(); i++) {\nnums[i] = 0;\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 411
                },
                {
                        "id": "pretrain_cpp_data_461890",
                        "content": "/*\nGiven an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\nExample 1:\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\nInput: nums = [0]\nOutput: [0]\nConstraints:\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1\nFollow up: Could you minimize the total number of operations done?\n*/\n// Two pointers and swap\nclass Solution {\npublic:\nvoid moveZeroes(vector<int>& nums) {\nint zero_idx = 0, n = nums.size();\nwhile( zero_idx < n && nums[zero_idx] )\nzero_idx++;\nfor ( int i = zero_idx; i < n; i++ )\n{\nif ( nums[i] == 0 )\ncontinue;\nswap(nums[zero_idx++], nums[i]);\n}\n}\n};\n// Two pointers and select non-zero to put front\nclass Solution {\npublic:\nvoid moveZeroes(vector<int>& nums) {\nint non_zero = 0, n = nums.size();\nfor ( int i = 0; i < n; i++ )\n{\nif ( nums[i] )\n{\nnums[non_zero++] = nums[i];\n}\n}\nwhile ( non_zero < n )\nnums[non_zero++] = 0;\n}\n};",
                        "max_stars_repo_path": "CLRS/TwoPointers/MoveZeroes.cpp",
                        "max_stars_repo_name": "ComputerProgrammerStorager/DataStructureAlgorithm",
                        "max_stars_count": 0.0,
                        "__cluster__": 411
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_431985",
                        "content": "<gh_stars>1-10\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nclass Solution {\npublic:\nint robRange(vector<int>& nums, int start, int end){\nif(start == end){\nreturn nums[start];\n}\nvector<int> dp(nums.size());\ndp[start] = nums[start];\ndp[start + 1] = max(nums[start], nums[start + 1]);\nfor(int i = start + 2; i <= end; i++){\ndp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n}\nreturn dp[end];\n}\nint rob(vector<int>& nums) {\nif(nums.size() == 0) {\nreturn 0;\n}\nif(nums.size() == 1) {\nreturn nums[0];\n}\nint robFirst = robRange(nums, 0, nums.size() - 2);\nint robSecond = robRange(nums, 1, nums.size() - 1);\nreturn max(robFirst, robSecond);\n}\n};",
                        "max_stars_repo_path": "dynamic programming/213. House Robber II.cpp",
                        "max_stars_repo_name": "Constantine-L01/leetcode",
                        "max_stars_count": 1.0,
                        "__cluster__": 381
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```cpp\nint rob(vector<int>& nums) {\nif (nums.size() == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.size() - 1; i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.size(); i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 381
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_2012930",
                        "content": "// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n// Example 1:\n// Input: [2,3,2]\n// Output: 3\n// Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),\n//              because they are adjacent houses.\n// Example 2:\n// Input: [1,2,3,1]\n// Output: 4\n// Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n//              Total amount you can rob = 1 + 3 = 4.\n// solution: dp, continuation of house robber\nclass Solution {\npublic:\nstatic int rob2(vector<int>& nums) {\nif (nums.size() == 0) return 0;\nif (nums.size() == 1) return nums[0];\nif (nums.size() == 2) return max(nums[0], nums[1]);\nnums[2] += nums[0];\nfor (int i = 3; i < nums.size(); i++) {\nnums[i] += max(nums[i-2], nums[i-3]);\n}\nreturn max(nums[nums.size()-1], nums[nums.size()-2]);\n}\nint rob(vector<int>& nums) {\nif (nums.size() == 0) return 0;\nif (nums.size() == 1) return nums[0];\nvector<int> nums1(nums.begin(), nums.end()-1);\nvector<int> nums2(nums.begin()+1, nums.end());\nreturn max(rob2(nums1), rob2(nums2));\n}\n};",
                        "max_stars_repo_path": "solutions/house_robber_2.cpp",
                        "max_stars_repo_name": "kmykoh97/My-Leetcode",
                        "max_stars_count": 0.0,
                        "__cluster__": 381
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_213",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n**Example 2:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 3:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\nInput:\nnums = \\[2,3,2\\]\nOutput:\n3\n```cpp\nint rob(vector<int>& nums) {\nif (nums.size() == 1) return nums[0];\nint prev = 0, curr = 0;\nfor (int i = 0; i < nums.size() - 1; i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nint res = curr;\nprev = 0;\ncurr = 0;\nfor (int i = 1; i < nums.size(); i++) {\nint temp = max(curr, prev + nums[i]);\nprev = curr;\ncurr = temp;\n}\nreturn max(res, curr);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 381
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_2066280",
                        "content": "/*\nPredict the Winner\nhttps://leetcode.com/problems/predict-the-winner/\nYou are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\nReturn true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.\nExample 1:\nInput: nums = [1,5,2]\nOutput: false\nExplanation: Initially, player 1 can choose between 1 and 2.\nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).\nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5.\nHence, player 1 will never be the winner and you need to return false.\nExample 2:\nInput: nums = [1,5,233,7]\nOutput: true\nExplanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\nConstraints:\n1 <= nums.length <= 20\n0 <= nums[i] <= 107\n*/\nclass Solution {\npublic:\nint go(vector<int>& nums, int s, int e, vector<vector<int>>& dp) {\nif(s == e) return nums[s];\nif(dp[s][e] != -1) return dp[s][e];\nint a = nums[s] - go(nums, s + 1, e, dp);\nint b = nums[e] - go(nums, s, e - 1, dp);\nreturn dp[s][e] = max(a, b);\n}\nbool PredictTheWinner(vector<int>& nums) {\nint n = nums.size();\nvector<vector<int>> dp(n, vector<int>(n, -1));\nreturn go(nums, 0, n - 1, dp) >= 0;\n}\n};",
                        "max_stars_repo_path": "leetcode/problems/medium/486-predict-the-winner.cpp",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_count": 18.0,
                        "__cluster__": 458
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_486",
                        "content": "You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\nReturn `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.\n**Example 1:**\n**Input:** nums = \\[1,5,2\\]\n**Output:** false\n**Explanation:** Initially, player 1 can choose between 1 and 2.\nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).\nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5.\nHence, player 1 will never be the winner and you need to return false.\n**Example 2:**\n**Input:** nums = \\[1,5,233,7\\]\n**Output:** true\n**Explanation:** Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n**Constraints:**\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 107`\nInput:\nnums = \\[1,5,2\\]\nOutput:\nfalse\n```cpp\n#include <vector>\nbool canWin(const std::vector<int>& nums) {\nint n = nums.size();\nstd::vector<std::vector<int>> dp(n, std::vector<int>(n));\nfor (int i = 0; i < n; i++) {\ndp[i][i] = nums[i];\n}\nfor (int len = 1; len < n; len++) {\nfor (int i = 0; i < n - len; i++) {\nint j = i + len;\ndp[i][j] = std::max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n}\n}\nreturn dp[0][n - 1] >= 0;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 458
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_100",
                        "content": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n**Example 1:**\n**Input:** p = \\[1,2,3\\], q = \\[1,2,3\\]\n**Output:** true\n**Example 2:**\n**Input:** p = \\[1,2\\], q = \\[1,null,2\\]\n**Output:** false\n**Example 3:**\n**Input:** p = \\[1,2,1\\], q = \\[1,1,2\\]\n**Output:** false\n**Constraints:**\n*   The number of nodes in both trees is in the range `[0, 100]`.\n*   `-104 <= Node.val <= 104`\nInput:\np = \\[1,2,3\\], q = \\[1,2,3\\]\nOutput:\ntrue\n```cpp\nstruct TreeNode {\nint val;\nTreeNode *left;\nTreeNode *right;\n};\nbool isSameTree(TreeNode* p, TreeNode* q) {\nif (p == nullptr && q == nullptr) {\nreturn true;\n}\nif (p == nullptr || q == nullptr) {\nreturn false;\n}\nif (p->val != q->val) {\nreturn false;\n}\nreturn isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 72
                },
                {
                        "id": "pretrain_cpp_data_2890898",
                        "content": "<gh_stars>10-100\n// Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n// Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n// Example 1:\n// Input: p = [1,2,3], q = [1,2,3]\n// Output: true\n// Example 2:\n// Input: p = [1,2], q = [1,null,2]\n// Output: false\n// Example 3:\n// Input: p = [1,2,1], q = [1,1,2]\n// Output: false\n// Constraints:\n// The number of nodes in both trees is in the range [0, 100].\n// -104 <= Node.val <= 104\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool isSameTree(TreeNode* p, TreeNode* q) {\nif(!p or !q)\nreturn (p == q);\nreturn((p->val == q->val)\n&& isSameTree(p->left, q->left)\n&& isSameTree(p->right, q->right));\n}\n};",
                        "max_stars_repo_path": "Trees/Same-Tree-100.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 72
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_100",
                        "content": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n**Example 1:**\n**Input:** p = \\[1,2,3\\], q = \\[1,2,3\\]\n**Output:** true\n**Example 2:**\n**Input:** p = \\[1,2\\], q = \\[1,null,2\\]\n**Output:** false\n**Example 3:**\n**Input:** p = \\[1,2,1\\], q = \\[1,1,2\\]\n**Output:** false\n**Constraints:**\n*   The number of nodes in both trees is in the range `[0, 100]`.\n*   `-104 <= Node.val <= 104`\nInput:\np = \\[1,2,3\\], q = \\[1,2,3\\]\nOutput:\ntrue\n```cpp\nstruct TreeNode {\nint val;\nTreeNode *left;\nTreeNode *right;\n};\nbool isSameTree(TreeNode* p, TreeNode* q) {\nif (p == nullptr && q == nullptr) {\nreturn true;\n}\nif (p == nullptr || q == nullptr) {\nreturn false;\n}\nif (p->val != q->val) {\nreturn false;\n}\nreturn isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 72
                },
                {
                        "id": "pretrain_cpp_data_2890898",
                        "content": "<gh_stars>10-100\n// Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n// Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n// Example 1:\n// Input: p = [1,2,3], q = [1,2,3]\n// Output: true\n// Example 2:\n// Input: p = [1,2], q = [1,null,2]\n// Output: false\n// Example 3:\n// Input: p = [1,2,1], q = [1,1,2]\n// Output: false\n// Constraints:\n// The number of nodes in both trees is in the range [0, 100].\n// -104 <= Node.val <= 104\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool isSameTree(TreeNode* p, TreeNode* q) {\nif(!p or !q)\nreturn (p == q);\nreturn((p->val == q->val)\n&& isSameTree(p->left, q->left)\n&& isSameTree(p->right, q->right));\n}\n};",
                        "max_stars_repo_path": "Trees/Same-Tree-100.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 72
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_4481698",
                        "content": "<reponame>devangi2000/Data-Structures-Algorithms-Handbook\n// Given a linked list, swap every two adjacent nodes and return its head.\n//   You must solve the problem without modifying the values in the list's\n//   nodes (i.e., only nodes themselves may be changed.)\n// Example 1:\n// Input: head = [1,2,3,4]\n// Output: [2,1,4,3]\n// Example 2:\n// Input: head = []\n// Output: []\n// Example 3:\n// Input: head = [1]\n// Output: [1]\n// Constraints:\n// The number of nodes in the list is in the range [0, 100].\n// 0 <= Node.val <= 100\nclass Solution {\npublic:\nListNode* swapPairs(ListNode* head) {\nif(head == NULL or head->next == NULL) return head;\nListNode* sentinel = new ListNode(0, head);\nListNode* curr = sentinel;\nwhile(curr->next and curr->next->next){\nListNode *a = curr->next;\nListNode *b = curr->next->next;\na->next = b->next;\ncurr->next = b;\ncurr->next->next = a;\ncurr = curr->next->next;\n}\nreturn sentinel->next;\n}\n};",
                        "max_stars_repo_path": "Linked-Lists/Swap-Nodes-in-Pairs-24.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 302
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_24",
                        "content": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n**Example 1:**\n**Input:** head = \\[1,2,3,4\\]\n**Output:** \\[2,1,4,3\\]\n**Example 2:**\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n**Example 3:**\n**Input:** head = \\[1\\]\n**Output:** \\[1\\]\n**Constraints:**\n*   The number of nodes in the list is in the range `[0, 100]`.\n*   `0 <= Node.val <= 100`\nInput:\nhead = \\[1,2,3,4\\]\nOutput:\n\\[2,1,4,3\\]\n```cpp\nListNode* swapPairs(ListNode* head) {\nif (!head || !head->next) return head;\nListNode* second = head->next;\nhead->next = swapPairs(second->next);\nsecond->next = head;\nreturn second;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 302
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_734",
                        "content": "We can represent a sentence as an array of words, for example, the sentence `\"I am happy with leetcode \"` can be represented as `arr = [ \"I \", \"am \",happy \", \"with \", \"leetcode \"]`.\nGiven two sentences `sentence1` and `sentence2` each represented as a string array and given an array of string pairs `similarPairs` where `similarPairs[i] = [xi, yi]` indicates that the two words `xi` and `yi` are similar.\nReturn _`true` if `sentence1` and `sentence2` are similar, or `false` if they are not similar_.\nTwo sentences are similar if:\n*   They have **the same length** (i.e., the same number of words)\n*   `sentence1[i]` and `sentence2[i]` are similar.\nNotice that a word is always similar to itself, also notice that the similarity relation is not transitive. For example, if the words `a` and `b` are similar, and the words `b` and `c` are similar, `a` and `c` are **not necessarily similar**.\n**Example 1:**\n**Input:** sentence1 = \\[ \"great \", \"acting \", \"skills \"\\], sentence2 = \\[ \"fine \", \"drama \", \"talent \"\\], similarPairs = \\[\\[ \"great \", \"fine \"\\],\\[ \"drama \", \"acting \"\\],\\[ \"skills \", \"talent \"\\]\\]\n**Output:** true\n**Explanation:** The two sentences have the same length and each word i of sentence1 is also similar to the corresponding word in sentence2.\n**Example 2:**\n**Input:** sentence1 = \\[ \"great \"\\], sentence2 = \\[ \"great \"\\], similarPairs = \\[\\]\n**Output:** true\n**Explanation:** A word is similar to itself.\n**Example 3:**\n**Input:** sentence1 = \\[ \"great \"\\], sentence2 = \\[ \"doubleplus \", \"good \"\\], similarPairs = \\[\\[ \"great \", \"doubleplus \"\\]\\]\n**Output:** false\n**Explanation:** As they don't have the same length, we return false.\n**Constraints:**\n*   `1 <= sentence1.length, sentence2.length <= 1000`\n*   `1 <= sentence1[i].length, sentence2[i].length <= 20`\n*   `sentence1[i]` and `sentence2[i]` consist of English letters.\n*   `0 <= similarPairs.length <= 1000`\n*   `similarPairs[i].length == 2`\n*   `1 <= xi.length, yi.length <= 20`\n*   `xi` and `yi` consist of lower-case and upper-case English letters.\n*   All the pairs `(xi, yi)` are **distinct**.\nInput:\nsentence1 = \\[ \"great \", \"acting \", \"skills \"\\], sentence2 = \\[ \"fine \", \"drama \", \"talent \"\\], similarPairs = \\[\\[ \"great \", \"fine \"\\],\\[ \"drama \", \"acting \"\\],\\[ \"skills \", \"talent \"\\]\\]\nOutput:\ntrue\n```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\nbool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) {\nif (sentence1.size() != sentence2.size()) return false;\nunordered_map<string, unordered_set<string>> similarityMap;\nfor (const auto& pair : similarPairs) {\nsimilarityMap[pair[0]].insert(pair[1]);\nsimilarityMap[pair[1]].insert(pair[0]);\n}\nfor (int i = 0; i < sentence1.size(); ++i) {\nif (sentence1[i] != sentence2[i] && !similarityMap[sentence1[i]].count(sentence2[i]))\nreturn false;\n}\nreturn true;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 506
                },
                {
                        "id": "pretrain_cpp_data_1326423",
                        "content": "/*\nSentence Similarity\nhttps://leetcode.com/problems/sentence-similarity/\nWe can represent a sentence as an array of words, for example, the sentence \"I am happy with leetcode\" can be represented as arr = [\"I\",\"am\",happy\",\"with\",\"leetcode\"].\nGiven two sentences sentence1 and sentence2 each represented as a string array and given an array of string pairs similarPairs where similarPairs[i] = [xi, yi] indicates that the two words xi and yi are similar.\nReturn true if sentence1 and sentence2 are similar, or false if they are not similar.\nTwo sentences are similar if:\nThey have the same length (i.e., the same number of words)\nsentence1[i] and sentence2[i] are similar.\nNotice that a word is always similar to itself, also notice that the similarity relation is not transitive. For example, if the words a and b are similar, and the words b and c are similar, a and c are not necessarily similar.\nExample 1:\nInput: sentence1 = [\"great\",\"acting\",\"skills\"], sentence2 = [\"fine\",\"drama\",\"talent\"], similarPairs = [[\"great\",\"fine\"],[\"drama\",\"acting\"],[\"skills\",\"talent\"]]\nOutput: true\nExplanation: The two sentences have the same length and each word i of sentence1 is also similar to the corresponding word in sentence2.\nExample 2:\nInput: sentence1 = [\"great\"], sentence2 = [\"great\"], similarPairs = []\nOutput: true\nExplanation: A word is similar to itself.\nExample 3:\nInput: sentence1 = [\"great\"], sentence2 = [\"doubleplus\",\"good\"], similarPairs = [[\"great\",\"doubleplus\"]]\nOutput: false\nExplanation: As they don't have the same length, we return false.\nConstraints:\n1 <= sentence1.length, sentence2.length <= 1000\n1 <= sentence1[i].length, sentence2[i].length <= 20\nsentence1[i] and sentence2[i] consist of English letters.\n0 <= similarPairs.length <= 1000\nsimilarPairs[i].length == 2\n1 <= xi.length, yi.length <= 20\nxi and yi consist of lower-case and upper-case English letters.\nAll the pairs (xi, yi) are distinct.\n*/\nclass Solution {\npublic:\nbool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) {\nif(sentence1.size() != sentence2.size()) return false;\nunordered_map<string, unordered_set<string>> m;\nfor(auto x: similarPairs){\nm[x[0]].insert(x[1]);\nm[x[1]].insert(x[0]);\n}\nfor(int i = 0; i < sentence1.size(); i++) {\nif(sentence1[i] != sentence2[i] && m[sentence1[i]].count(sentence2[i]) == 0) {\nreturn false;\n}\n}\nreturn true;\n}\n};",
                        "max_stars_repo_path": "leetcode/problems/easy/734-sentence-similarity.cpp",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_count": 18.0,
                        "__cluster__": 506
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_268",
                        "content": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._\n**Example 1:**\n**Input:** nums = \\[3,0,1\\]\n**Output:** 2\n**Explanation:** n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums.\n**Example 2:**\n**Input:** nums = \\[0,1\\]\n**Output:** 2\n**Explanation:** n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums.\n**Example 3:**\n**Input:** nums = \\[9,6,4,2,3,5,7,0,1\\]\n**Output:** 8\n**Explanation:** n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums.\n**Constraints:**\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `0 <= nums[i] <= n`\n*   All the numbers of `nums` are **unique**.\n**Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?\nInput:\nnums = \\[3,0,1\\]\nOutput:\n2\n```cpp\nint missingNumber(vector<int>& nums) {\nint n = nums.size();\nint expected_sum = (n * (n + 1)) / 2;\nint actual_sum = 0;\nfor (int num : nums) {\nactual_sum += num;\n}\nreturn expected_sum - actual_sum;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 406
                },
                {
                        "id": "pretrain_cpp_data_2993705",
                        "content": "<filename>Leetcode Top Interview Questions/solutions/Missing Number.cpp<gh_stars>1-10\n/*\nMissing Number\n==============\nGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nFollow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?\nExample 1:\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\nExample 2:\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\nExample 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\nExample 4:\nInput: nums = [0]\nOutput: 1\nExplanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.\nConstraints:\nn == nums.length\n1 <= n <= 104\n0 <= nums[i] <= n\nAll the numbers of nums are unique.\n*/\nclass Solution\n{\npublic:\nint missingNumber(vector<int> &nums)\n{\nint ans = 0;\nfor (int i = 1; i <= nums.size(); ++i)\nans = ans ^ i ^ nums[i - 1];\nreturn ans;\n}\n};",
                        "max_stars_repo_path": "Leetcode Top Interview Questions/solutions/Missing Number.cpp",
                        "max_stars_repo_name": "Akshad7829/DataStructures-Algorithms",
                        "max_stars_count": 5.0,
                        "__cluster__": 406
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_268",
                        "content": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._\n**Example 1:**\n**Input:** nums = \\[3,0,1\\]\n**Output:** 2\n**Explanation:** n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums.\n**Example 2:**\n**Input:** nums = \\[0,1\\]\n**Output:** 2\n**Explanation:** n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums.\n**Example 3:**\n**Input:** nums = \\[9,6,4,2,3,5,7,0,1\\]\n**Output:** 8\n**Explanation:** n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums.\n**Constraints:**\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `0 <= nums[i] <= n`\n*   All the numbers of `nums` are **unique**.\n**Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?\nInput:\nnums = \\[3,0,1\\]\nOutput:\n2\n```cpp\nint missingNumber(vector<int>& nums) {\nint n = nums.size();\nint expected_sum = (n * (n + 1)) / 2;\nint actual_sum = 0;\nfor (int num : nums) {\nactual_sum += num;\n}\nreturn expected_sum - actual_sum;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 406
                },
                {
                        "id": "pretrain_cpp_data_2993705",
                        "content": "<filename>Leetcode Top Interview Questions/solutions/Missing Number.cpp<gh_stars>1-10\n/*\nMissing Number\n==============\nGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nFollow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?\nExample 1:\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\nExample 2:\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\nExample 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\nExample 4:\nInput: nums = [0]\nOutput: 1\nExplanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.\nConstraints:\nn == nums.length\n1 <= n <= 104\n0 <= nums[i] <= n\nAll the numbers of nums are unique.\n*/\nclass Solution\n{\npublic:\nint missingNumber(vector<int> &nums)\n{\nint ans = 0;\nfor (int i = 1; i <= nums.size(); ++i)\nans = ans ^ i ^ nums[i - 1];\nreturn ans;\n}\n};",
                        "max_stars_repo_path": "Leetcode Top Interview Questions/solutions/Missing Number.cpp",
                        "max_stars_repo_name": "Akshad7829/DataStructures-Algorithms",
                        "max_stars_count": 5.0,
                        "__cluster__": 406
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_3708245",
                        "content": "<filename>714_Best_Time_to_Buy_and_Sell_Stock_with_Transaction_Fee.cpp<gh_stars>0\n/*\n714. Best Time to Buy and Sell Stock with Transaction Fee\nMedium\nYou are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [1,3,2,8,4,9], fee = 2\nOutput: 8\nExplanation: The maximum profit can be achieved by:\n- Buying at prices[0] = 1\n- Selling at prices[3] = 8\n- Buying at prices[4] = 4\n- Selling at prices[5] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\nExample 2:\nInput: prices = [1,3,7,5,10,3], fee = 3\nOutput: 6\nConstraints:\n1 <= prices.length <= 5 * 104\n1 <= prices[i] < 5 * 104\n0 <= fee < 5 * 104\n*/\nclass Solution {\npublic:\nint maxProfit(vector<int>& prices, int fee) {\nint sell=0,buy=-prices[0];\nfor(int i=1;i<prices.size();i++){\nsell=max(sell,buy+prices[i]-fee);\nbuy=max(buy,sell-prices[i]);\n}\nreturn sell;\n}\n};",
                        "max_stars_repo_path": "714_Best_Time_to_Buy_and_Sell_Stock_with_Transaction_Fee.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 500
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_714",
                        "content": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n**Example 1:**\n**Input:** prices = \\[1,3,2,8,4,9\\], fee = 2\n**Output:** 8\n**Explanation:** The maximum profit can be achieved by:\n- Buying at prices\\[0\\] = 1\n- Selling at prices\\[3\\] = 8\n- Buying at prices\\[4\\] = 4\n- Selling at prices\\[5\\] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n**Example 2:**\n**Input:** prices = \\[1,3,7,5,10,3\\], fee = 3\n**Output:** 6\n**Constraints:**\n*   `1 <= prices.length <= 5 * 104`\n*   `1 <= prices[i] < 5 * 104`\n*   `0 <= fee < 5 * 104`\nInput:\nprices = \\[1,3,2,8,4,9\\], fee = 2\nOutput:\n8\n```cpp\nint maxProfit(vector<int>& prices, int fee) {\nint cash = 0, hold = -prices[0];\nfor (int price : prices) {\nint temp = cash;\ncash = max(cash, hold + price - fee);\nhold = max(hold, temp - price);\n}\nreturn cash;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 500
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_684",
                        "content": "In this problem, a tree is an **undirected graph** that is connected and has no cycles.\nYou are given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added. The added edge has two **different** vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.\nReturn _an edge that can be removed so that the resulting graph is a tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the input.\n**Example 1:**\n**Input:** edges = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** \\[2,3\\]\n**Example 2:**\n**Input:** edges = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,4\\],\\[1,5\\]\\]\n**Output:** \\[1,4\\]\n**Constraints:**\n*   `n == edges.length`\n*   `3 <= n <= 1000`\n*   `edges[i].length == 2`\n*   `1 <= ai < bi <= edges.length`\n*   `ai != bi`\n*   There are no repeated edges.\n*   The given graph is connected.\nInput:\nedges = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\nOutput:\n\\[2,3\\]\n```cpp\n#include <vector>\nusing namespace std;\nvector<int> findRedundantConnection(vector<vector<int>>& edges) {\nvector<int> parent(edges.size() + 1);\nfor (int i = 1; i <= edges.size(); ++i) {\nparent[i] = i;\n}\nfor (const auto& edge : edges) {\nint root1 = find(parent, edge[0]);\nint root2 = find(parent, edge[1]);\nif (root1 == root2) {\nreturn edge;\n}\nparent[root1] = root2;\n}\nreturn {};\n}\nint find(vector<int>& parent, int x) {\nif (parent[x] != x) {\nparent[x] = find(parent, parent[x]);\n}\nreturn parent[x];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 225
                },
                {
                        "id": "pretrain_cpp_data_5387093",
                        "content": "<gh_stars>1-10\n/*\nRedundant Connection\n====================\nIn this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\nExample 1:\nInput: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\nExample 2:\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\nOutput: [1,4]\nConstraints:\nn == edges.length\n3 <= n <= 1000\nedges[i].length == 2\n1 <= ai < bi <= edges.length\nai != bi\nThere are no repeated edges.\nThe given graph is connected.\n*/\nclass DSU\n{\npublic:\nvector<int> parent, rank;\nDSU(int n)\n{\nparent = vector<int>(n + 1);\nrank = vector<int>(n + 1);\nfor (int i = 0; i <= n; ++i)\nparent[i] = i;\n}\nint find(int a)\n{\nif (parent[a] == a)\nreturn a;\nreturn parent[a] = find(parent[a]);\n}\nbool join(int a, int b)\n{\na = find(a), b = find(b);\nif (a == b)\nreturn false;\nif (rank[a] < rank[b])\nparent[a] = b;\nelse if (rank[b] < rank[a])\nparent[b] = a;\nelse\n{\nrank[a] += 1;\nparent[b] = a;\n}\nreturn true;\n}\n};\nclass Solution\n{\npublic:\nvector<int> findRedundantConnection(vector<vector<int>> &edges)\n{\nDSU obj(edges.size());\nvector<int> ans;\nfor (auto &e : edges)\n{\nif (!obj.join(e[0], e[1]))\nans = {e[0], e[1]};\n}\nreturn ans;\n}\n};",
                        "max_stars_repo_path": "Leetcode Daily Challenge/June-2021/25. Redundant Connection.cpp",
                        "max_stars_repo_name": "Akshad7829/DataStructures-Algorithms",
                        "max_stars_count": 5.0,
                        "__cluster__": 225
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_684",
                        "content": "In this problem, a tree is an **undirected graph** that is connected and has no cycles.\nYou are given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added. The added edge has two **different** vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.\nReturn _an edge that can be removed so that the resulting graph is a tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the input.\n**Example 1:**\n**Input:** edges = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** \\[2,3\\]\n**Example 2:**\n**Input:** edges = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,4\\],\\[1,5\\]\\]\n**Output:** \\[1,4\\]\n**Constraints:**\n*   `n == edges.length`\n*   `3 <= n <= 1000`\n*   `edges[i].length == 2`\n*   `1 <= ai < bi <= edges.length`\n*   `ai != bi`\n*   There are no repeated edges.\n*   The given graph is connected.\nInput:\nedges = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\nOutput:\n\\[2,3\\]\n```cpp\n#include <vector>\nusing namespace std;\nvector<int> findRedundantConnection(vector<vector<int>>& edges) {\nvector<int> parent(edges.size() + 1);\nfor (int i = 1; i <= edges.size(); ++i) {\nparent[i] = i;\n}\nfor (const auto& edge : edges) {\nint root1 = find(parent, edge[0]);\nint root2 = find(parent, edge[1]);\nif (root1 == root2) {\nreturn edge;\n}\nparent[root1] = root2;\n}\nreturn {};\n}\nint find(vector<int>& parent, int x) {\nif (parent[x] != x) {\nparent[x] = find(parent, parent[x]);\n}\nreturn parent[x];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 225
                },
                {
                        "id": "pretrain_cpp_data_5387093",
                        "content": "<gh_stars>1-10\n/*\nRedundant Connection\n====================\nIn this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\nExample 1:\nInput: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\nExample 2:\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\nOutput: [1,4]\nConstraints:\nn == edges.length\n3 <= n <= 1000\nedges[i].length == 2\n1 <= ai < bi <= edges.length\nai != bi\nThere are no repeated edges.\nThe given graph is connected.\n*/\nclass DSU\n{\npublic:\nvector<int> parent, rank;\nDSU(int n)\n{\nparent = vector<int>(n + 1);\nrank = vector<int>(n + 1);\nfor (int i = 0; i <= n; ++i)\nparent[i] = i;\n}\nint find(int a)\n{\nif (parent[a] == a)\nreturn a;\nreturn parent[a] = find(parent[a]);\n}\nbool join(int a, int b)\n{\na = find(a), b = find(b);\nif (a == b)\nreturn false;\nif (rank[a] < rank[b])\nparent[a] = b;\nelse if (rank[b] < rank[a])\nparent[b] = a;\nelse\n{\nrank[a] += 1;\nparent[b] = a;\n}\nreturn true;\n}\n};\nclass Solution\n{\npublic:\nvector<int> findRedundantConnection(vector<vector<int>> &edges)\n{\nDSU obj(edges.size());\nvector<int> ans;\nfor (auto &e : edges)\n{\nif (!obj.join(e[0], e[1]))\nans = {e[0], e[1]};\n}\nreturn ans;\n}\n};",
                        "max_stars_repo_path": "Leetcode Daily Challenge/June-2021/25. Redundant Connection.cpp",
                        "max_stars_repo_name": "Akshad7829/DataStructures-Algorithms",
                        "max_stars_count": 5.0,
                        "__cluster__": 225
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_124",
                        "content": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\nThe **path sum** of a path is the sum of the node's values in the path.\nGiven the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.\n**Example 1:**\n**Input:** root = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n**Example 2:**\n**Input:** root = \\[-10,9,20,null,null,15,7\\]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n**Constraints:**\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-1000 <= Node.val <= 1000`\nInput:\nroot = \\[1,2,3\\]\nOutput:\n6\n```cpp\nstruct TreeNode {\nint val;\nTreeNode *left;\nTreeNode *right;\n};\nint helper(TreeNode* root, int& maxSum) {\nif(!root) return 0;\nint left = max(0, helper(root->left, maxSum));\nint right = max(0, helper(root->right, maxSum));\nmaxSum = max(maxSum, left + right + root->val);\nreturn max(left, right) + root->val;\n}\nint maxPathSum(TreeNode* root) {\nint maxSum = INT_MIN;\nhelper(root, maxSum);\nreturn maxSum;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 352
                },
                {
                        "id": "pretrain_cpp_data_5339225",
                        "content": "<filename>124_Binary_Tree_Maximum_Path_Sum.cpp<gh_stars>0\n/*\n124. Binary Tree Maximum Path Sum\nHard\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any path.\nExample 1:\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\nExample 2:\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\nConstraints:\nThe number of nodes in the tree is in the range [1, 3 * 104].\n-1000 <= Node.val <= 1000\n*/\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\nint mx=INT_MIN;\nint helper(TreeNode* root){\nif(!root){\nreturn 0;\n}\nint l=helper(root->left);\nint r=helper(root->right);\nint temp=max(max(l,r)+root->val,root->val);\nmx=max(mx,max(temp,l+r+root->val));\nreturn temp;\n}\npublic:\nint maxPathSum(TreeNode* root) {\nhelper(root);\nreturn mx;\n}\n};",
                        "max_stars_repo_path": "124_Binary_Tree_Maximum_Path_Sum.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 352
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_1406",
                        "content": "Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\nAssume Alice and Bob **play optimally**.\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.\n**Example 1:**\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n**Example 2:**\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n**Example 3:**\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n**Constraints:**\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`\nInput:\nvalues = \\[1,2,3,7\\]\nOutput:\n\"Bob \"\n```cpp\n#include <vector>\n#include <string>\nusing namespace std;\nstring stoneGameIII(vector<int>& stoneValue) {\nint n = stoneValue.size();\nvector<int> dp(n + 1, INT_MIN);\ndp[n] = 0;\nfor (int i = n - 1; i >= 0; --i) {\nint curr = 0;\nfor (int j = 0; j < 3 && i + j < n; ++j) {\ncurr += stoneValue[i + j];\ndp[i] = max(dp[i], curr - dp[i + j + 1]);\n}\n}\nreturn dp[0] == 0 ? \"Tie \" : dp[0] > 0 ? \"Alice \" : \"Bob \";\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 254
                },
                {
                        "id": "pretrain_cpp_data_1444993",
                        "content": "<gh_stars>10-100\n/*\nStone Game III\nhttps://leetcode.com/problems/stone-game-iii/\nAlice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2 or 3 stones from the first remaining stones in the row.\nThe score of each player is the sum of values of the stones taken. The score of each player is 0 initially.\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\nAssume Alice and Bob play optimally.\nReturn \"Alice\" if Alice will win, \"Bob\" if Bob will win or \"Tie\" if they end the game with the same score.\nExample 1:\nInput: values = [1,2,3,7]\nOutput: \"Bob\"\nExplanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\nExample 2:\nInput: values = [1,2,3,-9]\nOutput: \"Alice\"\nExplanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. The next move Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. The next move Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\nExample 3:\nInput: values = [1,2,3,6]\nOutput: \"Tie\"\nExplanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\nExample 4:\nInput: values = [1,2,3,-1,-2,-3,7]\nOutput: \"Alice\"\nExample 5:\nInput: values = [-1,-2,-3]\nOutput: \"Tie\"\nConstraints:\n1 <= values.length <= 50000\n-1000 <= values[i] <= 1000\n*/\nclass Solution {\npublic:\nint dp[50001] = { [0 ... 50000] = INT_MIN };\nint dfs(vector<int>& stoneValue, int p) {\nif(p >= stoneValue.size()) return 0;\nif(dp[p] == INT_MIN) {\nint sum = 0;\nfor(int i = 0; i < 3 && p + i < stoneValue.size(); i++) {\nsum += stoneValue[p + i];\ndp[p] = max(dp[p], sum - dfs(stoneValue, p + i + 1));\n}\n}\nreturn dp[p];\n}\nstring stoneGameIII(vector<int>& stoneValue) {\nint ans = dfs(stoneValue, 0);\nreturn ans == 0 ? \"Tie\" : ans < 0 ? \"Bob\" : \"Alice\";\n}\n};",
                        "max_stars_repo_path": "leetcode/problems/hard/1406-stone-game-iii.cpp",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_count": 18.0,
                        "__cluster__": 254
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_1406",
                        "content": "Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\nAssume Alice and Bob **play optimally**.\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.\n**Example 1:**\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n**Example 2:**\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n**Example 3:**\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n**Constraints:**\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`\nInput:\nvalues = \\[1,2,3,7\\]\nOutput:\n\"Bob \"\n```cpp\n#include <vector>\n#include <string>\nusing namespace std;\nstring stoneGameIII(vector<int>& stoneValue) {\nint n = stoneValue.size();\nvector<int> dp(n + 1, INT_MIN);\ndp[n] = 0;\nfor (int i = n - 1; i >= 0; --i) {\nint curr = 0;\nfor (int j = 0; j < 3 && i + j < n; ++j) {\ncurr += stoneValue[i + j];\ndp[i] = max(dp[i], curr - dp[i + j + 1]);\n}\n}\nreturn dp[0] == 0 ? \"Tie \" : dp[0] > 0 ? \"Alice \" : \"Bob \";\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 254
                },
                {
                        "id": "pretrain_cpp_data_1444993",
                        "content": "<gh_stars>10-100\n/*\nStone Game III\nhttps://leetcode.com/problems/stone-game-iii/\nAlice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2 or 3 stones from the first remaining stones in the row.\nThe score of each player is the sum of values of the stones taken. The score of each player is 0 initially.\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\nAssume Alice and Bob play optimally.\nReturn \"Alice\" if Alice will win, \"Bob\" if Bob will win or \"Tie\" if they end the game with the same score.\nExample 1:\nInput: values = [1,2,3,7]\nOutput: \"Bob\"\nExplanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\nExample 2:\nInput: values = [1,2,3,-9]\nOutput: \"Alice\"\nExplanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. The next move Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. The next move Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\nExample 3:\nInput: values = [1,2,3,6]\nOutput: \"Tie\"\nExplanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\nExample 4:\nInput: values = [1,2,3,-1,-2,-3,7]\nOutput: \"Alice\"\nExample 5:\nInput: values = [-1,-2,-3]\nOutput: \"Tie\"\nConstraints:\n1 <= values.length <= 50000\n-1000 <= values[i] <= 1000\n*/\nclass Solution {\npublic:\nint dp[50001] = { [0 ... 50000] = INT_MIN };\nint dfs(vector<int>& stoneValue, int p) {\nif(p >= stoneValue.size()) return 0;\nif(dp[p] == INT_MIN) {\nint sum = 0;\nfor(int i = 0; i < 3 && p + i < stoneValue.size(); i++) {\nsum += stoneValue[p + i];\ndp[p] = max(dp[p], sum - dfs(stoneValue, p + i + 1));\n}\n}\nreturn dp[p];\n}\nstring stoneGameIII(vector<int>& stoneValue) {\nint ans = dfs(stoneValue, 0);\nreturn ans == 0 ? \"Tie\" : ans < 0 ? \"Bob\" : \"Alice\";\n}\n};",
                        "max_stars_repo_path": "leetcode/problems/hard/1406-stone-game-iii.cpp",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_count": 18.0,
                        "__cluster__": 254
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_1406",
                        "content": "Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\nAssume Alice and Bob **play optimally**.\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.\n**Example 1:**\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n**Example 2:**\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n**Example 3:**\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n**Constraints:**\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`\nInput:\nvalues = \\[1,2,3,7\\]\nOutput:\n\"Bob \"\n```cpp\n#include <vector>\n#include <string>\nusing namespace std;\nstring stoneGameIII(vector<int>& stoneValue) {\nint n = stoneValue.size();\nvector<int> dp(n + 1, INT_MIN);\ndp[n] = 0;\nfor (int i = n - 1; i >= 0; --i) {\nint curr = 0;\nfor (int j = 0; j < 3 && i + j < n; ++j) {\ncurr += stoneValue[i + j];\ndp[i] = max(dp[i], curr - dp[i + j + 1]);\n}\n}\nreturn dp[0] == 0 ? \"Tie \" : dp[0] > 0 ? \"Alice \" : \"Bob \";\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 254
                },
                {
                        "id": "pretrain_cpp_data_1444993",
                        "content": "<gh_stars>10-100\n/*\nStone Game III\nhttps://leetcode.com/problems/stone-game-iii/\nAlice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2 or 3 stones from the first remaining stones in the row.\nThe score of each player is the sum of values of the stones taken. The score of each player is 0 initially.\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\nAssume Alice and Bob play optimally.\nReturn \"Alice\" if Alice will win, \"Bob\" if Bob will win or \"Tie\" if they end the game with the same score.\nExample 1:\nInput: values = [1,2,3,7]\nOutput: \"Bob\"\nExplanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\nExample 2:\nInput: values = [1,2,3,-9]\nOutput: \"Alice\"\nExplanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. The next move Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. The next move Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\nExample 3:\nInput: values = [1,2,3,6]\nOutput: \"Tie\"\nExplanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\nExample 4:\nInput: values = [1,2,3,-1,-2,-3,7]\nOutput: \"Alice\"\nExample 5:\nInput: values = [-1,-2,-3]\nOutput: \"Tie\"\nConstraints:\n1 <= values.length <= 50000\n-1000 <= values[i] <= 1000\n*/\nclass Solution {\npublic:\nint dp[50001] = { [0 ... 50000] = INT_MIN };\nint dfs(vector<int>& stoneValue, int p) {\nif(p >= stoneValue.size()) return 0;\nif(dp[p] == INT_MIN) {\nint sum = 0;\nfor(int i = 0; i < 3 && p + i < stoneValue.size(); i++) {\nsum += stoneValue[p + i];\ndp[p] = max(dp[p], sum - dfs(stoneValue, p + i + 1));\n}\n}\nreturn dp[p];\n}\nstring stoneGameIII(vector<int>& stoneValue) {\nint ans = dfs(stoneValue, 0);\nreturn ans == 0 ? \"Tie\" : ans < 0 ? \"Bob\" : \"Alice\";\n}\n};",
                        "max_stars_repo_path": "leetcode/problems/hard/1406-stone-game-iii.cpp",
                        "max_stars_repo_name": "wingkwong/competitive-programming",
                        "max_stars_count": 18.0,
                        "__cluster__": 254
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```cpp\nstruct ListNode {\nint val;\nListNode *next;\nListNode(int x) : val(x), next(nullptr) {}\n};\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nListNode dummy(0);\nListNode* current = &dummy;\nint carry = 0;\nwhile (l1 || l2 || carry) {\nint sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\ncarry = sum / 10;\ncurrent->next = new ListNode(sum % 10);\ncurrent = current->next;\nif (l1) l1 = l1->next;\nif (l2) l2 = l2->next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 292
                },
                {
                        "id": "pretrain_cpp_data_6251088",
                        "content": "<reponame>kmykoh97/My-Leetcode\n// You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n// You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n// Example 1:\n// Input: l1 = [2,4,3], l2 = [5,6,4]\n// Output: [7,0,8]\n// Explanation: 342 + 465 = 807.\n// Example 2:\n// Input: l1 = [0], l2 = [0]\n// Output: [0]\n// Example 3:\n// Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n// Output: [8,9,9,9,0,0,0,1]\n// Constraints:\n// The number of nodes in each linked list is in the range [1, 100].\n// 0 <= Node.val <= 9\n// It is guaranteed that the list represents a number that does not have leading zeros.\n// solution: linked list\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nint val = 0, carry = 0;\nListNode* dummy = new ListNode(-1);\nListNode* last = dummy;\nwhile (l1 && l2) {\nval = l1->val + l2->val + carry;\nListNode* node = new ListNode(val%10);\nlast->next = node;\nlast = last->next;\ncarry = val/10;\nl1 = l1->next;\nl2 = l2->next;\n}\nListNode* iter = l1 == nullptr ? l2 : l1;\nwhile (iter) {\nval = carry + iter->val;\nListNode* node = new ListNode(val%10);\ncarry = val/10;\nlast->next = node;\nlast = last->next;\niter = iter->next;\n}\nif (carry) last->next = new ListNode(carry);\nreturn dummy->next;\n}\n};",
                        "max_stars_repo_path": "solutions/add_two_numbers.cpp",
                        "max_stars_repo_name": "kmykoh97/My-Leetcode",
                        "max_stars_count": 0.0,
                        "__cluster__": 292
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_733",
                        "content": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\nReturn _the modified image after performing the flood fill_.\n**Example 1:**\n**Input:** image = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n**Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n**Example 2:**\n**Input:** image = \\[\\[0,0,0\\],\\[0,0,0\\]\\], sr = 0, sc = 0, color = 0\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:** The starting pixel is already colored 0, so no changes are made to the image.\n**Constraints:**\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= image[i][j], color < 216`\n*   `0 <= sr < m`\n*   `0 <= sc < n`\nInput:\nimage = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\nOutput:\n\\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n```cpp\n#include<vector>\nusing namespace std;\nvoid fill(vector<vector<int>>& image, int sr, int sc, int newColor, int startColor) {\nif (sr < 0 || sc < 0 || sr >= image.size() || sc >= image[0].size() || image[sr][sc] != startColor || image[sr][sc] == newColor) return;\nimage[sr][sc] = newColor;\nfill(image, sr - 1, sc, newColor, startColor);\nfill(image, sr + 1, sc, newColor, startColor);\nfill(image, sr, sc - 1, newColor, startColor);\nfill(image, sr, sc + 1, newColor, startColor);\n}\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\nint startColor = image[sr][sc];\nfill(image, sr, sc, newColor, startColor);\nreturn image;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 97
                },
                {
                        "id": "pretrain_cpp_data_6264053",
                        "content": "<filename>Graphs/Flood-Fill-733.cpp\n// An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\n// You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].\n// To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel,\n// plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor.\n// Return the modified image after performing the flood fill.\n// Example 1:\n// Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2\n// Output: [[2,2,2],[2,2,0],[2,0,1]]\n// Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels\n// connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\n// Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n// Example 2:\n// Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2\n// Output: [[2,2,2],[2,2,2]]\nclass Solution {\npublic:\nvoid fill(vector<vector<int>>& image, int sr, int sc, int newColor, int color){\nif(sr<0 || sr>=image.size() || sc<0 || sc>=image[0].size() || color!=image[sr][sc]) return;\nimage[sr][sc] = newColor;\nfill(image, sr-1, sc, newColor, color);\nfill(image, sr+1, sc, newColor, color);\nfill(image, sr, sc-1, newColor, color);\nfill(image, sr, sc+1, newColor, color);\n}\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\nif(image[sr][sc]==newColor) return image;\nfill(image, sr, sc, newColor, image[sr][sc]);\nreturn image;\n}\n};",
                        "max_stars_repo_path": "Graphs/Flood-Fill-733.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 97
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_733",
                        "content": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\nReturn _the modified image after performing the flood fill_.\n**Example 1:**\n**Input:** image = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n**Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n**Example 2:**\n**Input:** image = \\[\\[0,0,0\\],\\[0,0,0\\]\\], sr = 0, sc = 0, color = 0\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:** The starting pixel is already colored 0, so no changes are made to the image.\n**Constraints:**\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= image[i][j], color < 216`\n*   `0 <= sr < m`\n*   `0 <= sc < n`\nInput:\nimage = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\nOutput:\n\\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n```cpp\n#include<vector>\nusing namespace std;\nvoid fill(vector<vector<int>>& image, int sr, int sc, int newColor, int startColor) {\nif (sr < 0 || sc < 0 || sr >= image.size() || sc >= image[0].size() || image[sr][sc] != startColor || image[sr][sc] == newColor) return;\nimage[sr][sc] = newColor;\nfill(image, sr - 1, sc, newColor, startColor);\nfill(image, sr + 1, sc, newColor, startColor);\nfill(image, sr, sc - 1, newColor, startColor);\nfill(image, sr, sc + 1, newColor, startColor);\n}\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\nint startColor = image[sr][sc];\nfill(image, sr, sc, newColor, startColor);\nreturn image;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 97
                },
                {
                        "id": "pretrain_cpp_data_6264053",
                        "content": "<filename>Graphs/Flood-Fill-733.cpp\n// An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\n// You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].\n// To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel,\n// plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor.\n// Return the modified image after performing the flood fill.\n// Example 1:\n// Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2\n// Output: [[2,2,2],[2,2,0],[2,0,1]]\n// Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels\n// connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\n// Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n// Example 2:\n// Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2\n// Output: [[2,2,2],[2,2,2]]\nclass Solution {\npublic:\nvoid fill(vector<vector<int>>& image, int sr, int sc, int newColor, int color){\nif(sr<0 || sr>=image.size() || sc<0 || sc>=image[0].size() || color!=image[sr][sc]) return;\nimage[sr][sc] = newColor;\nfill(image, sr-1, sc, newColor, color);\nfill(image, sr+1, sc, newColor, color);\nfill(image, sr, sc-1, newColor, color);\nfill(image, sr, sc+1, newColor, color);\n}\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\nif(image[sr][sc]==newColor) return image;\nfill(image, sr, sc, newColor, image[sr][sc]);\nreturn image;\n}\n};",
                        "max_stars_repo_path": "Graphs/Flood-Fill-733.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 97
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_733",
                        "content": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\nReturn _the modified image after performing the flood fill_.\n**Example 1:**\n**Input:** image = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n**Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n**Example 2:**\n**Input:** image = \\[\\[0,0,0\\],\\[0,0,0\\]\\], sr = 0, sc = 0, color = 0\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:** The starting pixel is already colored 0, so no changes are made to the image.\n**Constraints:**\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= image[i][j], color < 216`\n*   `0 <= sr < m`\n*   `0 <= sc < n`\nInput:\nimage = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\nOutput:\n\\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n```cpp\n#include<vector>\nusing namespace std;\nvoid fill(vector<vector<int>>& image, int sr, int sc, int newColor, int startColor) {\nif (sr < 0 || sc < 0 || sr >= image.size() || sc >= image[0].size() || image[sr][sc] != startColor || image[sr][sc] == newColor) return;\nimage[sr][sc] = newColor;\nfill(image, sr - 1, sc, newColor, startColor);\nfill(image, sr + 1, sc, newColor, startColor);\nfill(image, sr, sc - 1, newColor, startColor);\nfill(image, sr, sc + 1, newColor, startColor);\n}\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\nint startColor = image[sr][sc];\nfill(image, sr, sc, newColor, startColor);\nreturn image;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 97
                },
                {
                        "id": "pretrain_cpp_data_6264053",
                        "content": "<filename>Graphs/Flood-Fill-733.cpp\n// An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\n// You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].\n// To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel,\n// plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor.\n// Return the modified image after performing the flood fill.\n// Example 1:\n// Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2\n// Output: [[2,2,2],[2,2,0],[2,0,1]]\n// Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels\n// connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\n// Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n// Example 2:\n// Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2\n// Output: [[2,2,2],[2,2,2]]\nclass Solution {\npublic:\nvoid fill(vector<vector<int>>& image, int sr, int sc, int newColor, int color){\nif(sr<0 || sr>=image.size() || sc<0 || sc>=image[0].size() || color!=image[sr][sc]) return;\nimage[sr][sc] = newColor;\nfill(image, sr-1, sc, newColor, color);\nfill(image, sr+1, sc, newColor, color);\nfill(image, sr, sc-1, newColor, color);\nfill(image, sr, sc+1, newColor, color);\n}\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\nif(image[sr][sc]==newColor) return image;\nfill(image, sr, sc, newColor, image[sr][sc]);\nreturn image;\n}\n};",
                        "max_stars_repo_path": "Graphs/Flood-Fill-733.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 97
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_1506260",
                        "content": "/*\nAdd Two Numbers\n===============\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n*/\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution\n{\npublic:\nListNode *addTwoNumbers(ListNode *l1, ListNode *l2)\n{\nListNode *dummy = new ListNode(-1);\nauto temp = dummy;\nint carry = 0;\nwhile (l1 || l2 || carry)\n{\nint n1 = l1 ? l1->val : 0;\nint n2 = l2 ? l2->val : 0;\nint sum = n1 + n2 + carry;\ncarry = sum / 10;\nsum = sum % 10;\nListNode *newNode = new ListNode(sum);\ntemp->next = newNode;\ntemp = temp->next;\nif (l1)\nl1 = l1->next;\nif (l2)\nl2 = l2->next;\n}\nreturn dummy->next;\n}\n};",
                        "max_stars_repo_path": "Leetcode Top Interview Questions/solutions/Add Two Numbers.cpp",
                        "max_stars_repo_name": "Akshad7829/DataStructures-Algorithms",
                        "max_stars_count": 5.0,
                        "__cluster__": 292
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_2",
                        "content": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n**Example 1:**\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n**Example 2:**\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n**Example 3:**\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n**Constraints:**\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.\nInput:\nl1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\nOutput:\n\\[7,0,8\\]\n```cpp\nstruct ListNode {\nint val;\nListNode *next;\nListNode(int x) : val(x), next(nullptr) {}\n};\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nListNode dummy(0);\nListNode* current = &dummy;\nint carry = 0;\nwhile (l1 || l2 || carry) {\nint sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\ncarry = sum / 10;\ncurrent->next = new ListNode(sum % 10);\ncurrent = current->next;\nif (l1) l1 = l1->next;\nif (l2) l2 = l2->next;\n}\nreturn dummy.next;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 292
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_2316486",
                        "content": "<gh_stars>1-10\n/*\nYou are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16\nExplanation: The perimeter is the 16 yellow stripes in the image above.\nExample 2:\nInput: grid = [[1]]\nOutput: 4\nExample 3:\nInput: grid = [[1,0]]\nOutput: 4\nConstraints:\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 100\ngrid[i][j] is 0 or 1.\nThere is exactly one island in grid.\n*/\nclass Solution {\npublic:\nint islandPerimeter(vector<vector<int>>& grid) {\nint ans = 0;\nconst int dirx[] = {0, 0, -1, 1}, diry[] = {-1, 1, 0, 0};\nfor (int i = 0; i < grid.size(); ++i) {\nfor (int j = 0; j < grid[0].size(); ++j) {\nif (grid[i][j]) {\nint cnt = 0;\nfor (int k = 0; k < 4; ++k) {\nint x = i+dirx[k], y = j+diry[k];\nif (x >= 0 && x < grid.size() &&\ny >= 0 && y < grid[0].size() &&\ngrid[x][y])\n++cnt;\n}\nans += 4-cnt;\n}\n}\n}\nreturn ans;\n}\n};",
                        "max_stars_repo_path": "Leetcode Daily Challenge/October-2021/4. Island Perimeter.cpp",
                        "max_stars_repo_name": "Akshad7829/DataStructures-Algorithms",
                        "max_stars_count": 1.0,
                        "__cluster__": 454
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_463",
                        "content": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n**Example 1:**\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n**Example 2:**\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n**Example 3:**\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4\n**Constraints:**\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.\nInput:\ngrid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\nOutput:\n16\n```cpp\nint islandPerimeter(vector<vector<int>>& grid) {\nint perimeter = 0;\nfor (int row = 0; row < grid.size(); row++) {\nfor (int col = 0; col < grid[row].size(); col++) {\nif (grid[row][col] == 1) {\nperimeter += 4;\nif (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\nif (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n}\n}\n}\nreturn perimeter;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 454
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_3155132",
                        "content": "<filename>Arrays/LongestContinuousIncreasingSubsequence674.cpp\nGiven an unsorted array of integers nums, return the length of the longest continuous increasing subsequence\n//  (i.e. subarray). The subsequence must be strictly increasing.\n// A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is\n//  [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].\n// Example 1:\n// Input: nums = [1,3,5,4,7]\n// Output: 3\n// Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.\n// Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n// 4.\n// Example 2:\n// Input: nums = [2,2,2,2,2]\n// Output: 1\n// Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly\n// increasing.\n//  Constraints:\n// 1 <= nums.length <= 104\n// -109 <= nums[i] <= 109\nclass Solution {\npublic:\nint findLengthOfLCIS(vector<int>& nums) {\nint count = 1, maxi = INT_MIN, n = nums.size();\nif(n < 2) return n;\nfor(int i = 1; i < n; i++){\nif(nums[i-1] < nums[i]){\ncount++;\n}\nelse count = 1;\nmaxi = max(maxi, count);\n}\nreturn maxi;\n}\n};",
                        "max_stars_repo_path": "Arrays/LongestContinuousIncreasingSubsequence674.cpp",
                        "max_stars_repo_name": "devangi2000/Data-Structures-Algorithms-Handbook",
                        "max_stars_count": 38.0,
                        "__cluster__": 492
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_674",
                        "content": "Given an unsorted array of integers `nums`, return _the length of the longest **continuous increasing subsequence** (i.e. subarray)_. The subsequence must be **strictly** increasing.\nA **continuous increasing subsequence** is defined by two indices `l` and `r` (`l < r`) such that it is `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` and for each `l <= i < r`, `nums[i] < nums[i + 1]`.\n**Example 1:**\n**Input:** nums = \\[1,3,5,4,7\\]\n**Output:** 3\n**Explanation:** The longest continuous increasing subsequence is \\[1,3,5\\] with length 3.\nEven though \\[1,3,5,7\\] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4.\n**Example 2:**\n**Input:** nums = \\[2,2,2,2,2\\]\n**Output:** 1\n**Explanation:** The longest continuous increasing subsequence is \\[2\\] with length 1. Note that it must be strictly\nincreasing.\n**Constraints:**\n*   `1 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\nInput:\nnums = \\[1,3,5,4,7\\]\nOutput:\n3\n```cpp\nint findLengthOfLCIS(vector<int>& nums) {\nif (nums.empty()) return 0;\nint result = 1, current = 1;\nfor (int i = 1; i < nums.size(); ++i) {\ncurrent = nums[i] > nums[i - 1] ? current + 1 : 1;\nresult = max(result, current);\n}\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 492
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_3122985",
                        "content": "// 64 minimum path sum\n// Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\n// Note: You can only move either down or right at any point in time.\n// Example:\n// Input:\n// [\n// \u00a0 [1,3,1],\n//   [1,5,1],\n//   [4,2,1]\n// ]\n// Output: 7\n// Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n// \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09\n// \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/minimum-path-sum\n// \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002\n#include<vector>\nusing namespace std;\nclass Solution {\npublic:\nint minPathSum(vector<vector<int>>& grid) {\nint m = grid.size();\nint n = grid[0].size();\nfor(int i = 0; i < m; i++){\nfor(int j = 0; j < n; j++){\nif(i == 0 && j == 0){\ncontinue;\n}\nelse if(i == 0 && j != 0){\ngrid[i][j] += grid[i][j-1];\n}\nelse if(i != 0 && j == 0){\ngrid[i][j] += grid[i-1][j];\n}\nelse{\ngrid[i][j] += min(grid[i-1][j], grid[i][j-1]);\n}\n}\n}\nreturn grid[m-1][n-1];\n}\n};",
                        "max_stars_repo_path": "dynamic_programing/minimum_path_sum.cpp",
                        "max_stars_repo_name": "zm66260/Data_Structure_and_Algorithms",
                        "max_stars_count": 0.0,
                        "__cluster__": 323
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_64",
                        "content": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n**Note:** You can only move either down or right at any point in time.\n**Example 1:**\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n**Example 2:**\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n**Constraints:**\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`\nInput:\ngrid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\nOutput:\n7\n```cpp\nint minPathSum(vector<vector<int>>& grid) {\nint m = grid.size(), n = grid[0].size();\nfor(int i = 1; i < m; i++)\ngrid[i][0] += grid[i - 1][0];\nfor(int i = 1; i < n; i++)\ngrid[0][i] += grid[0][i - 1];\nfor(int i = 1; i < m; i++){\nfor(int j = 1; j < n; j++){\ngrid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n}\n}\nreturn grid[m - 1][n - 1];\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 323
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_4780071",
                        "content": "/*\nYou are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\nExample 2:\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\nConstraints:\n1 <= nums.length <= 104\n0 <= nums[i] <= 105\n*/\nclass Solution\n{\npublic:\nbool canJump(vector<int> &a)\n{\nint reach = 0, i = 0;\nfor (i = 0; i <= reach; i++)\n{\nreach = max(i + a[i], reach);\nif (reach >= a.size() - 1)\nreturn true;\n}\nreturn false;\n}\n};",
                        "max_stars_repo_path": "Leetcode/C++/55 jump game.cpp",
                        "max_stars_repo_name": "iamhardikat11/Daily-Coding-DS-ALGO-Practice",
                        "max_stars_count": 289.0,
                        "__cluster__": 318
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_55",
                        "content": "You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\nReturn `true` _if you can reach the last index, or_ `false` _otherwise_.\n**Example 1:**\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** true\n**Explanation:** Jump 1 step from index 0 to 1, then 3 steps to the last index.\n**Example 2:**\n**Input:** nums = \\[3,2,1,0,4\\]\n**Output:** false\n**Explanation:** You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n**Constraints:**\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 105`\nInput:\nnums = \\[2,3,1,1,4\\]\nOutput:\ntrue\n```cpp\nbool canJump(vector<int>& nums) {\nint maxReach = 0;\nfor (int i = 0; i < nums.size(); ++i) {\nif (i > maxReach) return false;\nmaxReach = max(maxReach, i + nums[i]);\n}\nreturn true;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 318
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_31",
                        "content": "A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.\n*   For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]`.\nThe **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n*   For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.\n*   Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.\n*   While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.\nGiven an array of integers `nums`, _find the next permutation of_ `nums`.\nThe replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory.\n**Example 1:**\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[1,3,2\\]\n**Example 2:**\n**Input:** nums = \\[3,2,1\\]\n**Output:** \\[1,2,3\\]\n**Example 3:**\n**Input:** nums = \\[1,1,5\\]\n**Output:** \\[1,5,1\\]\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 100`\nInput:\nnums = \\[1,2,3\\]\nOutput:\n\\[1,3,2\\]\n```cpp\n#include <algorithm>\nvoid nextPermutation(vector<int>& nums) {\nint n = nums.size(), k, l;\nfor (k = n - 2; k >= 0; k--) {\nif (nums[k] < nums[k + 1]) break;\n}\nif (k < 0) {\nreverse(nums.begin(), nums.end());\n} else {\nfor (l = n - 1; l > k; l--) {\nif (nums[l] > nums[k]) break;\n}\nswap(nums[k], nums[l]);\nreverse(nums.begin() + k + 1, nums.end());\n}\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 305
                },
                {
                        "id": "pretrain_cpp_data_4730970",
                        "content": "<gh_stars>0\n// Leetcode\n// 31. Next Permutation\n// https://leetcode.com/problems/next-permutation/\n/*\nA permutation of an array of integers is an arrangement of its members into a sequence or linear order.\nFor example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n> For example, the next permutation of arr = [1,2,3] is [1,3,2].\n> Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n> While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\nExample 1:\nInput: nums = [1,2,3]\nOutput: [1,3,2]\nExample 2:\nInput: nums = [3,2,1]\nOutput: [1,2,3]\nExample 3:\nInput: nums = [1,1,5]\nOutput: [1,5,1]\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n*/\nclass Solution {\npublic:\nvoid nextPermutation(vector<int>& nums) {\nnext_permutation(nums.begin(),nums.end());\n}\n};",
                        "max_stars_repo_path": "Permutations & combinations/Next Permutation.cpp",
                        "max_stars_repo_name": "BhavinRaichura/algo",
                        "max_stars_count": 0.0,
                        "__cluster__": 305
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```cpp\nint rob(vector<int>& nums) {\nint prev1 = 0, prev2 = 0;\nfor (const auto& num : nums) {\nint tmp = prev1;\nprev1 = max(prev2 + num, prev1);\nprev2 = tmp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "id": "pretrain_cpp_data_6317430",
                        "content": "// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n// Example 1:\n// Input: [1,2,3,1]\n// Output: 4\n// Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n//              Total amount you can rob = 1 + 3 = 4.\n// Example 2:\n// Input: [2,7,9,3,1]\n// Output: 12\n// Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n//              Total amount you can rob = 2 + 9 + 1 = 12.\n// solution: dp\nclass Solution {\npublic:\nint rob(vector<int>& nums) {\nif (nums.size() == 0) return 0;\nif (nums.size() == 1) return nums[0];\nif (nums.size() == 2) return max(nums[0], nums[1]);\nnums[2] += nums[0];\nfor (int i = 3; i < nums.size(); i++) {\nnums[i] += max(nums[i-2], nums[i-3]);\n}\nreturn max(nums[nums.size()-1], nums[nums.size()-2]);\n}\n};",
                        "max_stars_repo_path": "solutions/house_robber.cpp",
                        "max_stars_repo_name": "kmykoh97/My-Leetcode",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```cpp\nint rob(vector<int>& nums) {\nint prev1 = 0, prev2 = 0;\nfor (const auto& num : nums) {\nint tmp = prev1;\nprev1 = max(prev2 + num, prev1);\nprev2 = tmp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "id": "pretrain_cpp_data_6317430",
                        "content": "// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n// Example 1:\n// Input: [1,2,3,1]\n// Output: 4\n// Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n//              Total amount you can rob = 1 + 3 = 4.\n// Example 2:\n// Input: [2,7,9,3,1]\n// Output: 12\n// Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n//              Total amount you can rob = 2 + 9 + 1 = 12.\n// solution: dp\nclass Solution {\npublic:\nint rob(vector<int>& nums) {\nif (nums.size() == 0) return 0;\nif (nums.size() == 1) return nums[0];\nif (nums.size() == 2) return max(nums[0], nums[1]);\nnums[2] += nums[0];\nfor (int i = 3; i < nums.size(); i++) {\nnums[i] += max(nums[i-2], nums[i-3]);\n}\nreturn max(nums[nums.size()-1], nums[nums.size()-2]);\n}\n};",
                        "max_stars_repo_path": "solutions/house_robber.cpp",
                        "max_stars_repo_name": "kmykoh97/My-Leetcode",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_198",
                        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n**Example 1:**\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n**Example 2:**\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n**Constraints:**\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`\nInput:\nnums = \\[1,2,3,1\\]\nOutput:\n4\n```cpp\nint rob(vector<int>& nums) {\nint prev1 = 0, prev2 = 0;\nfor (const auto& num : nums) {\nint tmp = prev1;\nprev1 = max(prev2 + num, prev1);\nprev2 = tmp;\n}\nreturn prev1;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "id": "pretrain_cpp_data_6317430",
                        "content": "// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n// Example 1:\n// Input: [1,2,3,1]\n// Output: 4\n// Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n//              Total amount you can rob = 1 + 3 = 4.\n// Example 2:\n// Input: [2,7,9,3,1]\n// Output: 12\n// Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n//              Total amount you can rob = 2 + 9 + 1 = 12.\n// solution: dp\nclass Solution {\npublic:\nint rob(vector<int>& nums) {\nif (nums.size() == 0) return 0;\nif (nums.size() == 1) return nums[0];\nif (nums.size() == 2) return max(nums[0], nums[1]);\nnums[2] += nums[0];\nfor (int i = 3; i < nums.size(); i++) {\nnums[i] += max(nums[i-2], nums[i-3]);\n}\nreturn max(nums[nums.size()-1], nums[nums.size()-2]);\n}\n};",
                        "max_stars_repo_path": "solutions/house_robber.cpp",
                        "max_stars_repo_name": "kmykoh97/My-Leetcode",
                        "max_stars_count": 0.0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_6324137",
                        "content": "<reponame>AvadheshChamola/LeetCode\n/*\n310. Minimum Height Trees\nMedium\nA tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\nGiven a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).\nReturn a list of all MHTs' root labels. You can return the answer in any order.\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\nExample 1:\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]\nOutput: [1]\nExplanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\nExample 2:\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\nOutput: [3,4]\nExample 3:\nInput: n = 1, edges = []\nOutput: [0]\nExample 4:\nInput: n = 2, edges = [[0,1]]\nOutput: [0,1]\nConstraints:\n1 <= n <= 2 * 104\nedges.length == n - 1\n0 <= ai, bi < n\nai != bi\nAll the pairs (ai, bi) are distinct.\nThe given input is guaranteed to be a tree and there will be no repeated edges.\n*/\nclass Solution {\npublic:\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\nif(n==1) return {0};\nvector<vector<int>> adj(n);\nvector<int> indegree(n,0);\nint u,v,size;\nfor(auto e:edges){\nu=e[0];\nv=e[1];\nadj[u].push_back(v);\nadj[v].push_back(u);\nindegree[u]++;\nindegree[v]++;\n}\nqueue<int> q;\nvector<int> res;\nfor(int i=0;i<n;i++) if(indegree[i]==1) q.push(i);\nwhile(!q.empty()){\nres.clear();\nsize=q.size();\nfor(int i=0;i<size;i++){\nu=q.front();\nq.pop();\nres.push_back(u);\nfor(auto v:adj[u]){\nindegree[v]--;\nif(indegree[v]==1) q.push(v);\n}\n}\n}\nreturn res;\n}\n};",
                        "max_stars_repo_path": "310_Minimum_Height_Trees.cpp",
                        "max_stars_repo_name": "AvadheshChamola/LeetCode",
                        "max_stars_count": 0.0,
                        "__cluster__": 422
                },
                {
                        "id": "test_codeeditorbench_switch_plus_cpp_data_310",
                        "content": "A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).\nReturn _a list of all **MHTs'** root labels_. You can return the answer in **any order**.\nThe **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n**Example 1:**\n**Input:** n = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[1\\]\n**Explanation:** As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n**Example 2:**\n**Input:** n = 6, edges = \\[\\[3,0\\],\\[3,1\\],\\[3,2\\],\\[3,4\\],\\[5,4\\]\\]\n**Output:** \\[3,4\\]\n**Constraints:**\n*   `1 <= n <= 2 * 104`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs `(ai, bi)` are distinct.\n*   The given input is **guaranteed** to be a tree and there will be **no repeated** edges.\nInput:\nn = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]\nOutput:\n\\[1\\]\n```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\nif (n == 1) return {0};\nvector<int> degrees(n, 0);\nvector<vector<int>> adjList(n);\nfor (const auto &edge : edges) {\nadjList[edge[0]].push_back(edge[1]);\nadjList[edge[1]].push_back(edge[0]);\ndegrees[edge[0]]++;\ndegrees[edge[1]]++;\n}\nqueue<int> q;\nfor (int i = 0; i < n; ++i) {\nif (degrees[i] == 1) q.push(i);\n}\nwhile (n > 2) {\nint leaves_size = q.size();\nn -= leaves_size;\nfor (int i = 0; i < leaves_size; i++) {\nint leaf = q.front(); q.pop();\nfor (int neighbor : adjList[leaf]) {\nif (--degrees[neighbor] == 1) q.push(neighbor);\n}\n}\n}\nvector<int> result;\nwhile (!q.empty()) {\nresult.push_back(q.front());\nq.pop();\n}\nreturn result;\n}\n```",
                        "max_stars_repo_path": "NA",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0.0,
                        "__cluster__": 422
                },
                {
                        "real_dup": "2"
                }
        ]
]