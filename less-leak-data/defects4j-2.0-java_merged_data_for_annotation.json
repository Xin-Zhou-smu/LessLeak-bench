[
        {
                "data_len": 2
        },
        [
                {
                        "id": "pretrain_java_data_5289659",
                        "content": "<filename>src/main/java/net/emaze/dysfunctional/equality/EqualsBuilder.java\npackage net.emaze.dysfunctional.equality;\nimport java.util.Arrays;\npublic class EqualsBuilder {\nprivate boolean isEquals = true;\npublic EqualsBuilder appendSuper(boolean superEquals) {\nif (!isEquals) {\nreturn this;\n}\nisEquals = superEquals;\nreturn this;\n}\npublic EqualsBuilder append(Object lhs, Object rhs) {\nif (!isEquals) {\nreturn this;\n}\nif (lhs == rhs) {\nreturn this;\n}\nif (lhs == null || rhs == null) {\nisEquals = false;\nreturn this;\n}\nClass lhsClass = lhs.getClass();\nif (!lhsClass.isArray()) {\nif (lhs instanceof java.math.BigDecimal) {\nisEquals = (((java.math.BigDecimal)lhs).compareTo((java.math.BigDecimal)rhs) == 0);\n} else {\n// The simple case, not an array, just test the element\nisEquals = lhs.equals(rhs);\n}\n} else if (lhs.getClass() != rhs.getClass()) {\n// Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\nthis.isEquals = false;\n}\n// 'Switch' on type of array, to dispatch to the correct handler\n// This handles multi dimensional arrays of the same depth\nelse if (lhs instanceof long[]) {\nappend((long[]) lhs, (long[]) rhs);\n} else if (lhs instanceof int[]) {\nappend((int[]) lhs, (int[]) rhs);\n} else if (lhs instanceof short[]) {\nappend((short[]) lhs, (short[]) rhs);\n} else if (lhs instanceof char[]) {\nappend((char[]) lhs, (char[]) rhs);\n} else if (lhs instanceof byte[]) {\nappend((byte[]) lhs, (byte[]) rhs);\n} else if (lhs instanceof double[]) {\nappend((double[]) lhs, (double[]) rhs);\n} else if (lhs instanceof float[]) {\nappend((float[]) lhs, (float[]) rhs);\n} else if (lhs instanceof boolean[]) {\nappend((boolean[]) lhs, (boolean[]) rhs);\n} else {\n// Not an array of primitives\nappend((Object[]) lhs, (Object[]) rhs);\n}\nreturn this;\n}\npublic EqualsBuilder append(long lhs, long rhs) {\nif (!isEquals) {\nreturn this;\n}\nisEquals = (lhs == rhs);\nreturn this;\n}\npublic EqualsBuilder append(int lhs, int rhs) {\nif (!isEquals) {\nreturn this;\n}\nisEquals = (lhs == rhs);\nreturn this;\n}\npublic EqualsBuilder append(short lhs, short rhs) {\nif (!isEquals) {\nreturn this;\n}\nisEquals = (lhs == rhs);\nreturn this;\n}\npublic EqualsBuilder append(char lhs, char rhs) {\nif (!isEquals) {\nreturn this;\n}\nisEquals = (lhs == rhs);\nreturn this;\n}\npublic EqualsBuilder append(byte lhs, byte rhs) {\nif (!isEquals) {\nreturn this;\n}\nisEquals = (lhs == rhs);\nreturn this;\n}\npublic EqualsBuilder append(double lhs, double rhs) {\nif (!isEquals) {\nreturn this;\n}\nreturn append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n}\npublic EqualsBuilder append(float lhs, float rhs) {\nif (!isEquals) {\nreturn this;\n}\nreturn append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n}\npublic EqualsBuilder append(boolean lhs, boolean rhs) {\nif (!isEquals) {\nreturn this;\n}\nisEquals = (lhs == rhs);\nreturn this;\n}\npublic EqualsBuilder append(Object[] lhs, Object[] rhs) {\nif (!isEquals) {\nreturn this;\n}\nthis.isEquals = Arrays.equals(lhs, rhs);\nreturn this;\n}\npublic EqualsBuilder append(long[] lhs, long[] rhs) {\nif (!isEquals) {\nreturn this;\n}\nthis.isEquals = Arrays.equals(lhs, rhs);\nreturn this;\n}\npublic EqualsBuilder append(int[] lhs, int[] rhs) {\nif (!isEquals) {\nreturn this;\n}\nthis.isEquals = Arrays.equals(lhs, rhs);\nreturn this;\n}\npublic EqualsBuilder append(short[] lhs, short[] rhs) {\nif (!isEquals) {\nreturn this;\n}\nthis.isEquals = Arrays.equals(lhs, rhs);\nreturn this;\n}\npublic EqualsBuilder append(char[] lhs, char[] rhs) {\nif (!isEquals) {\nreturn this;\n}\nthis.isEquals = Arrays.equals(lhs, rhs);\nreturn this;\n}\npublic EqualsBuilder append(byte[] lhs, byte[] rhs) {\nif (!isEquals) {\nreturn this;\n}\nthis.isEquals = Arrays.equals(lhs, rhs);\nreturn this;\n}\npublic EqualsBuilder append(double[] lhs, double[] rhs) {\nif (!isEquals) {\nreturn this;\n}\nthis.isEquals = Arrays.equals(lhs, rhs);\nreturn this;\n}\npublic EqualsBuilder append(float[] lhs, float[] rhs) {\nif (!isEquals) {\nreturn this;\n}\nthis.isEquals = Arrays.equals(lhs, rhs);\nreturn this;\n}\npublic EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\nif (!isEquals) {\nreturn this;\n}\nthis.isEquals = Arrays.equals(lhs, rhs);\nreturn this;\n}\npublic boolean isEquals() {\nreturn this.isEquals;\n}\n}\n",
                        "max_stars_repo_path": "src/main/java/net/emaze/dysfunctional/equality/EqualsBuilder.java",
                        "max_stars_repo_name": "EdMcBane/emaze-dysfunctional",
                        "max_stars_count": 1,
                        "__cluster__": 364
                },
                {
                        "id": "test_Lang-48",
                        "content": "public EqualsBuilder append(Object lhs, Object rhs) {\nif (isEquals == false) {\nreturn this;\n}\nif (lhs == rhs) {\nreturn this;\n}\nif (lhs == null || rhs == null) {\nthis.setEquals(false);\nreturn this;\n}\nClass lhsClass = lhs.getClass();\nif (!lhsClass.isArray()) {\n// The simple case, not an array, just test the element\nisEquals = lhs.equals(rhs);\n} else if (lhs.getClass() != rhs.getClass()) {\n// Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\nthis.setEquals(false);\n}\n// 'Switch' on type of array, to dispatch to the correct handler\n// This handles multi dimensional arrays of the same depth\nelse if (lhs instanceof long[]) {\nappend((long[]) lhs, (long[]) rhs);\n} else if (lhs instanceof int[]) {\nappend((int[]) lhs, (int[]) rhs);\n} else if (lhs instanceof short[]) {\nappend((short[]) lhs, (short[]) rhs);\n} else if (lhs instanceof char[]) {\nappend((char[]) lhs, (char[]) rhs);\n} else if (lhs instanceof byte[]) {\nappend((byte[]) lhs, (byte[]) rhs);\n} else if (lhs instanceof double[]) {\nappend((double[]) lhs, (double[]) rhs);\n} else if (lhs instanceof float[]) {\nappend((float[]) lhs, (float[]) rhs);\n} else if (lhs instanceof boolean[]) {\nappend((boolean[]) lhs, (boolean[]) rhs);\n} else {\n// Not an array of primitives\nappend((Object[]) lhs, (Object[]) rhs);\n}\nreturn this;\n}\npublic EqualsBuilder append(Object lhs, Object rhs) {\nif (isEquals == false) {\nreturn this;\n}\nif (lhs == rhs) {\nreturn this;\n}\nif (lhs == null || rhs == null) {\nthis.setEquals(false);\nreturn this;\n}\nClass lhsClass = lhs.getClass();\nif (!lhsClass.isArray()) {\nif (lhs instanceof java.math.BigDecimal) {\nisEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);\n} else {\n// The simple case, not an array, just test the element\nisEquals = lhs.equals(rhs);\n}\n} else if (lhs.getClass() != rhs.getClass()) {\n// Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\nthis.setEquals(false);\n}\n// 'Switch' on type of array, to dispatch to the correct handler\n// This handles multi dimensional arrays of the same depth\nelse if (lhs instanceof long[]) {\nappend((long[]) lhs, (long[]) rhs);\n} else if (lhs instanceof int[]) {\nappend((int[]) lhs, (int[]) rhs);\n} else if (lhs instanceof short[]) {\nappend((short[]) lhs, (short[]) rhs);\n} else if (lhs instanceof char[]) {\nappend((char[]) lhs, (char[]) rhs);\n} else if (lhs instanceof byte[]) {\nappend((byte[]) lhs, (byte[]) rhs);\n} else if (lhs instanceof double[]) {\nappend((double[]) lhs, (double[]) rhs);\n} else if (lhs instanceof float[]) {\nappend((float[]) lhs, (float[]) rhs);\n} else if (lhs instanceof boolean[]) {\nappend((boolean[]) lhs, (boolean[]) rhs);\n} else {\n// Not an array of primitives\nappend((Object[]) lhs, (Object[]) rhs);\n}\nreturn this;\n}",
                        "max_stars_repo_path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 364
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_java_data_11704612",
                        "content": "package kr.dogfoot.hwplib.util;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class StringUtil {\nprivate final static char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n/**\n* \ubb38\uc790\uc5f4(UTF-16LE)\uc774 \uc800\uc7a5\ub420 \ub54c \ud544\uc694\ud55c byte\uc758 \uac1c\uc218\ub97c \ubc18\ud658\ud55c\ub2e4.\n*\n* @param s \ubb38\uc790\uc5f4\n* @return \ubb38\uc790\uc5f4(UTF - 16LE)\uc774 \uc800\uc7a5\ub420 \ub54c \ud544\uc694\ud55c byte\uc758 \uac1c\uc218\n*/\npublic static int getUTF16LEStringSize(String s) {\nif (s == null) {\nreturn 2;\n} else {\nreturn 2 + s.length() * 2;\n}\n}\n/**\n* \ubc14\uc774\ud2b8 \ubc30\uc5f4\uc744 16\uc9c4\uc218 \ubb38\uc790\uc5f4\ub85c \ubc14\uafbc\ub2e4.\n*\n* @param bytes \ubc14\uc774\ud2b8 \ubc30\uc5f4\n* @return 16\uc9c4\uc218 \ubb38\uc790\uc5f4\n*/\npublic static String bytesToHex(byte[] bytes) {\nchar[] hexChars = new char[bytes.length * 3];\nfor (int j = 0; j < bytes.length; j++) {\nint v = bytes[j] & 0xFF;\nhexChars[j * 3] = hexArray[v >>> 4];\nhexChars[j * 3 + 1] = hexArray[v & 0x0F];\nhexChars[j * 3 + 2] = ' ';\n}\nreturn new String(hexChars);\n}\npublic static boolean equals(String str1, String str2) {\nif (str1 == null) {\nreturn str2 == null;\n} else {\nreturn str1.equals(str2);\n}\n}\npublic static String replaceEach(final String text, final String[] searchList, final String[] replacementList) {\nreturn replaceEach(text, searchList, replacementList, false, 0);\n}\nprivate static String replaceEach(\nfinal String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {\n// mchyzer Performance note: This creates very few new objects (one major goal)\n// let me know if there are performance requests, we can create a harness to measure\n// if recursing, this shouldn't be less than 0\nif (timeToLive < 0) {\nfinal Set<String> searchSet = new HashSet<>(Arrays.asList(searchList));\nfinal Set<String> replacementSet = new HashSet<>(Arrays.asList(replacementList));\nsearchSet.retainAll(replacementSet);\nif (!searchSet.isEmpty()) {\nthrow new IllegalStateException(\"Aborting to protect against StackOverflowError - \" +\n\"output of one loop is the input of another\");\n}\n}\nif (isEmpty(text) || ArrayUtil.isEmpty(searchList) || ArrayUtil.isEmpty(replacementList) || (ArrayUtil.isNotEmpty(searchList) && timeToLive == -1)) {\nreturn text;\n}\nfinal int searchLength = searchList.length;\nfinal int replacementLength = replacementList.length;\n// make sure lengths are ok, these need to be equal\nif (searchLength != replacementLength) {\nthrow new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n+ searchLength\n+ \" vs \"\n+ replacementLength);\n}\n// keep track of which still have matches\nfinal boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n// index on index that the match was found\nint textIndex = -1;\nint replaceIndex = -1;\nint tempIndex = -1;\n// index of replace array that will replace the search string found\n// NOTE: logic duplicated below START\nfor (int i = 0; i < searchLength; i++) {\nif (noMoreMatchesForReplIndex[i] || isEmpty(searchList[i]) || replacementList[i] == null) {\ncontinue;\n}\ntempIndex = text.indexOf(searchList[i]);\n// see if we need to keep searching for this\nif (tempIndex == -1) {\nnoMoreMatchesForReplIndex[i] = true;\n} else if (textIndex == -1 || tempIndex < textIndex) {\ntextIndex = tempIndex;\nreplaceIndex = i;\n}\n}\n// NOTE: logic mostly below END\n// no search strings found, we are done\nif (textIndex == -1) {\nreturn text;\n}\nint start = 0;\n// get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit\nint increase = 0;\n// count the replacement text elements that are larger than their corresponding text being replaced\nfor (int i = 0; i < searchList.length; i++) {\nif (searchList[i] == null || replacementList[i] == null) {\ncontinue;\n}\nfinal int greater = replacementList[i].length() - searchList[i].length();\nif (greater > 0) {\nincrease += 3 * greater; // assume 3 matches\n}\n}\n// have upper-bound at 20% increase, then let Java take over\nincrease = Math.min(increase, text.length() / 5);\nfinal StringBuilder buf = new StringBuilder(text.length() + increase);\nwhile (textIndex != -1) {\nfor (int i = start; i < textIndex; i++) {\nbuf.append(text.charAt(i));\n}\nbuf.append(replacementList[replaceIndex]);\nstart = textIndex + searchList[replaceIndex].length();\ntextIndex = -1;\nreplaceIndex = -1;\n// find the next earliest match\n// NOTE: logic mostly duplicated above START\nfor (int i = 0; i < searchLength; i++) {\nif (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\nsearchList[i].isEmpty() || replacementList[i] == null) {\ncontinue;\n}\ntempIndex = text.indexOf(searchList[i], start);\n// see if we need to keep searching for this\nif (tempIndex == -1) {\nnoMoreMatchesForReplIndex[i] = true;\n} else if (textIndex == -1 || tempIndex < textIndex) {\ntextIndex = tempIndex;\nreplaceIndex = i;\n}\n}\n// NOTE: logic duplicated above END\n}\nfinal int textLength = text.length();\nfor (int i = start; i < textLength; i++) {\nbuf.append(text.charAt(i));\n}\nfinal String result = buf.toString();\nif (!repeat) {\nreturn result;\n}\nreturn replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\npublic static boolean isEmpty(final CharSequence cs) {\nreturn cs == null || cs.length() == 0;\n}\n}",
                        "max_stars_repo_path": "src/main/java/kr/dogfoot/hwplib/util/StringUtil.java",
                        "max_stars_repo_name": "gulnergulner/hwplib",
                        "max_stars_count": 329,
                        "__cluster__": 358
                },
                {
                        "id": "test_Lang-39",
                        "content": "private static String replaceEach(String text, String[] searchList, String[] replacementList,\nboolean repeat, int timeToLive)\n{\n// mchyzer Performance note: This creates very few new objects (one major goal)\n// let me know if there are performance requests, we can create a harness to measure\nif (text == null || text.length() == 0 || searchList == null ||\nsearchList.length == 0 || replacementList == null || replacementList.length == 0)\n{\nreturn text;\n}\n// if recursing, this shouldnt be less than 0\nif (timeToLive < 0) {\nthrow new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n}\nint searchLength = searchList.length;\nint replacementLength = replacementList.length;\n// make sure lengths are ok, these need to be equal\nif (searchLength != replacementLength) {\nthrow new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n+ searchLength\n+ \" vs \"\n+ replacementLength);\n}\n// keep track of which still have matches\nboolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n// index on index that the match was found\nint textIndex = -1;\nint replaceIndex = -1;\nint tempIndex = -1;\n// index of replace array that will replace the search string found\n// NOTE: logic duplicated below START\nfor (int i = 0; i < searchLength; i++) {\nif (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\nsearchList[i].length() == 0 || replacementList[i] == null)\n{\ncontinue;\n}\ntempIndex = text.indexOf(searchList[i]);\n// see if we need to keep searching for this\nif (tempIndex == -1) {\nnoMoreMatchesForReplIndex[i] = true;\n} else {\nif (textIndex == -1 || tempIndex < textIndex) {\ntextIndex = tempIndex;\nreplaceIndex = i;\n}\n}\n}\n// NOTE: logic mostly below END\n// no search strings found, we are done\nif (textIndex == -1) {\nreturn text;\n}\nint start = 0;\n// get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\nint increase = 0;\n// count the replacement text elements that are larger than their corresponding text being replaced\nfor (int i = 0; i < searchList.length; i++) {\nint greater = replacementList[i].length() - searchList[i].length();\nif (greater > 0) {\nincrease += 3 * greater; // assume 3 matches\n}\n}\n// have upper-bound at 20% increase, then let Java take over\nincrease = Math.min(increase, text.length() / 5);\nStringBuilder buf = new StringBuilder(text.length() + increase);\nwhile (textIndex != -1) {\nfor (int i = start; i < textIndex; i++) {\nbuf.append(text.charAt(i));\n}\nbuf.append(replacementList[replaceIndex]);\nstart = textIndex + searchList[replaceIndex].length();\ntextIndex = -1;\nreplaceIndex = -1;\ntempIndex = -1;\n// find the next earliest match\n// NOTE: logic mostly duplicated above START\nfor (int i = 0; i < searchLength; i++) {\nif (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\nsearchList[i].length() == 0 || replacementList[i] == null)\n{\ncontinue;\n}\ntempIndex = text.indexOf(searchList[i], start);\n// see if we need to keep searching for this\nif (tempIndex == -1) {\nnoMoreMatchesForReplIndex[i] = true;\n} else {\nif (textIndex == -1 || tempIndex < textIndex) {\ntextIndex = tempIndex;\nreplaceIndex = i;\n}\n}\n}\n// NOTE: logic duplicated above END\n}\nint textLength = text.length();\nfor (int i = start; i < textLength; i++) {\nbuf.append(text.charAt(i));\n}\nString result = buf.toString();\nif (!repeat) {\nreturn result;\n}\nreturn replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList,\nboolean repeat, int timeToLive)\n{\n// mchyzer Performance note: This creates very few new objects (one major goal)\n// let me know if there are performance requests, we can create a harness to measure\nif (text == null || text.length() == 0 || searchList == null ||\nsearchList.length == 0 || replacementList == null || replacementList.length == 0)\n{\nreturn text;\n}\n// if recursing, this shouldnt be less than 0\nif (timeToLive < 0) {\nthrow new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n}\nint searchLength = searchList.length;\nint replacementLength = replacementList.length;\n// make sure lengths are ok, these need to be equal\nif (searchLength != replacementLength) {\nthrow new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n+ searchLength\n+ \" vs \"\n+ replacementLength);\n}\n// keep track of which still have matches\nboolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n// index on index that the match was found\nint textIndex = -1;\nint replaceIndex = -1;\nint tempIndex = -1;\n// index of replace array that will replace the search string found\n// NOTE: logic duplicated below START\nfor (int i = 0; i < searchLength; i++) {\nif (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\nsearchList[i].length() == 0 || replacementList[i] == null)\n{\ncontinue;\n}\ntempIndex = text.indexOf(searchList[i]);\n// see if we need to keep searching for this\nif (tempIndex == -1) {\nnoMoreMatchesForReplIndex[i] = true;\n} else {\nif (textIndex == -1 || tempIndex < textIndex) {\ntextIndex = tempIndex;\nreplaceIndex = i;\n}\n}\n}\n// NOTE: logic mostly below END\n// no search strings found, we are done\nif (textIndex == -1) {\nreturn text;\n}\nint start = 0;\n// get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\nint increase = 0;\n// count the replacement text elements that are larger than their corresponding text being replaced\nfor (int i = 0; i < searchList.length; i++) {\nif (searchList[i] == null || replacementList[i] == null) {\ncontinue;\n}\nint greater = replacementList[i].length() - searchList[i].length();\nif (greater > 0) {\nincrease += 3 * greater; // assume 3 matches\n}\n}\n// have upper-bound at 20% increase, then let Java take over\nincrease = Math.min(increase, text.length() / 5);\nStringBuilder buf = new StringBuilder(text.length() + increase);\nwhile (textIndex != -1) {\nfor (int i = start; i < textIndex; i++) {\nbuf.append(text.charAt(i));\n}\nbuf.append(replacementList[replaceIndex]);\nstart = textIndex + searchList[replaceIndex].length();\ntextIndex = -1;\nreplaceIndex = -1;\ntempIndex = -1;\n// find the next earliest match\n// NOTE: logic mostly duplicated above START\nfor (int i = 0; i < searchLength; i++) {\nif (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\nsearchList[i].length() == 0 || replacementList[i] == null)\n{\ncontinue;\n}\ntempIndex = text.indexOf(searchList[i], start);\n// see if we need to keep searching for this\nif (tempIndex == -1) {\nnoMoreMatchesForReplIndex[i] = true;\n} else {\nif (textIndex == -1 || tempIndex < textIndex) {\ntextIndex = tempIndex;\nreplaceIndex = i;\n}\n}\n}\n// NOTE: logic duplicated above END\n}\nint textLength = text.length();\nfor (int i = start; i < textLength; i++) {\nbuf.append(text.charAt(i));\n}\nString result = buf.toString();\nif (!repeat) {\nreturn result;\n}\nreturn replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
                        "max_stars_repo_path": "src/java/org/apache/commons/lang3/StringUtils.java",
                        "max_stars_repo_name": "NA",
                        "max_stars_count": 0,
                        "__cluster__": 358
                },
                {
                        "real_dup": "2"
                }
        ]
]