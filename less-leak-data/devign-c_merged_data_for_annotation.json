[
        {
                "data_len": 16
        },
        [
                {
                        "id": "test_devign_test_set_data_18150",
                        "content": "static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\nint w, int h)\n{\nbool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\nsize_t bytes;\nint zywrle_level;\nif (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\nif (!vs->vd->lossy || vs->tight.quality < 0 || vs->tight.quality == 9) {\nzywrle_level = 0;\nvs->zrle.type = VNC_ENCODING_ZRLE;\n} else if (vs->tight.quality < 3) {\nzywrle_level = 3;\n} else if (vs->tight.quality < 6) {\nzywrle_level = 2;\n} else {\nzywrle_level = 1;\n}\n} else {\nzywrle_level = 0;\n}\nvnc_zrle_start(vs);\nswitch(vs->clientds.pf.bytes_per_pixel) {\ncase 1:\nzrle_encode_8ne(vs, x, y, w, h, zywrle_level);\nbreak;\ncase 2:\nif (vs->clientds.pf.gmax > 0x1F) {\nif (be) {\nzrle_encode_16be(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_16le(vs, x, y, w, h, zywrle_level);\n}\n} else {\nif (be) {\nzrle_encode_15be(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_15le(vs, x, y, w, h, zywrle_level);\n}\n}\nbreak;\ncase 4:\n{\nbool fits_in_ls3bytes;\nbool fits_in_ms3bytes;\nfits_in_ls3bytes =\n((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n(vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n(vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\nfits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\nvs->clientds.pf.gshift > 7 &&\nvs->clientds.pf.bshift > 7);\nif ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\nif (be) {\nzrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n}\n} else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\nif (be) {\nzrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n}\n} else {\nif (be) {\nzrle_encode_32be(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_32le(vs, x, y, w, h, zywrle_level);\n}\n}\n}\nbreak;\n}\nvnc_zrle_stop(vs);\nbytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\nvnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\nvnc_write_u32(vs, bytes);\nvnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\nreturn 1;\n}\nThe vulnerability label is: Non-vulnerable",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "__cluster__": 1784
                },
                {
                        "id": "pretrain_cpp_data_3422281",
                        "content": "static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\nint w, int h)\n{\nbool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\nsize_t bytes;\nint zywrle_level;\nif (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\nif (!vs->vd->lossy || vs->tight.quality == (uint8_t)-1\n|| vs->tight.quality == 9) {\nzywrle_level = 0;\nvs->zrle.type = VNC_ENCODING_ZRLE;\n} else if (vs->tight.quality < 3) {\nzywrle_level = 3;\n} else if (vs->tight.quality < 6) {\nzywrle_level = 2;\n} else {\nzywrle_level = 1;\n}\n} else {\nzywrle_level = 0;\n}\nvnc_zrle_start(vs);\nswitch(vs->clientds.pf.bytes_per_pixel) {\ncase 1:\nzrle_encode_8ne(vs, x, y, w, h, zywrle_level);\nbreak;\ncase 2:\nif (vs->clientds.pf.gmax > 0x1F) {\nif (be) {\nzrle_encode_16be(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_16le(vs, x, y, w, h, zywrle_level);\n}\n} else {\nif (be) {\nzrle_encode_15be(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_15le(vs, x, y, w, h, zywrle_level);\n}\n}\nbreak;\ncase 4:\n{\nbool fits_in_ls3bytes;\nbool fits_in_ms3bytes;\nfits_in_ls3bytes =\n((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n(vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n(vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\nfits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\nvs->clientds.pf.gshift > 7 &&\nvs->clientds.pf.bshift > 7);\nif ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\nif (be) {\nzrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n}\n} else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\nif (be) {\nzrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n}\n} else {\nif (be) {\nzrle_encode_32be(vs, x, y, w, h, zywrle_level);\n} else {\nzrle_encode_32le(vs, x, y, w, h, zywrle_level);\n}\n}\n}\nbreak;\n}\nvnc_zrle_stop(vs);\nbytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\nvnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\nvnc_write_u32(vs, bytes);\nvnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\nreturn 1;\n}",
                        "max_stars_count": 2.0,
                        "max_stars_repo_name": "awsm-research/LineVul",
                        "max_stars_repo_path": "cppcheck/data/c_files/620.cpp",
                        "__cluster__": 1784
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "pretrain_cpp_data_1200847",
                        "content": "<gh_stars>1-10\nstatic int dnxhd_find_frame_end(DNXHDParserContext *dctx,\nconst uint8_t *buf, int buf_size)\n{\nParseContext *pc = &dctx->pc;\nuint64_t state = pc->state64;\nint pic_found = pc->frame_start_found;\nint i = 0;\nif (!pic_found) {\nfor (i = 0; i < buf_size; i++) {\nstate = (state << 8) | buf[i];\nif (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\ni++;\npic_found = 1;\ndctx->cur_byte = 0;\ndctx->remaining = 0;\nbreak;\n}\n}\n}\nif (pic_found && !dctx->remaining) {\nif (!buf_size) /* EOF considered as end of frame */\nreturn 0;\nfor (; i < buf_size; i++) {\ndctx->cur_byte++;\nstate = (state << 8) | buf[i];\nif (dctx->cur_byte == 24) {\ndctx->h = (state >> 32) & 0xFFFF;\n} else if (dctx->cur_byte == 26) {\ndctx->w = (state >> 32) & 0xFFFF;\n} else if (dctx->cur_byte == 42) {\nint cid = (state >> 32) & 0xFFFFFFFF;\nif (cid <= 0)\ncontinue;\ndctx->remaining = avpriv_dnxhd_get_frame_size(cid);\nif (dctx->remaining <= 0) {\ndctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\nif (dctx->remaining <= 0)\nreturn dctx->remaining;\n}\nif (buf_size - i + 47 >= dctx->remaining) {\nint remaining = dctx->remaining;\npc->frame_start_found = 0;\npc->state64 = -1;\ndctx->cur_byte = 0;\ndctx->remaining = 0;\nreturn remaining;\n} else {\ndctx->remaining -= buf_size;\n}\n}\n}\n} else if (pic_found) {\nif (dctx->remaining > buf_size) {\ndctx->remaining -= buf_size;\n} else {\nint remaining = dctx->remaining;\npc->frame_start_found = 0;\npc->state64 = -1;\ndctx->cur_byte = 0;\ndctx->remaining = 0;\nreturn remaining;\n}\n}\npc->frame_start_found = pic_found;\npc->state64 = state;\nreturn END_NOT_FOUND;\n}",
                        "max_stars_count": 2.0,
                        "max_stars_repo_name": "awsm-research/LineVul",
                        "max_stars_repo_path": "cppcheck/data/c_files/396.cpp",
                        "__cluster__": 1951
                },
                {
                        "id": "test_devign_test_set_data_19728",
                        "content": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\nconst uint8_t *buf, int buf_size)\n{\nParseContext *pc = &dctx->pc;\nuint64_t state = pc->state64;\nint pic_found = pc->frame_start_found;\nint i = 0;\nif (!pic_found) {\nfor (i = 0; i < buf_size; i++) {\nstate = (state << 8) | buf[i];\nif (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\ni++;\npic_found = 1;\ndctx->cur_byte = 0;\ndctx->remaining = 0;\nbreak;\n}\n}\n}\nif (pic_found && !dctx->remaining) {\nif (!buf_size) /* EOF considered as end of frame */\nreturn 0;\nfor (; i < buf_size; i++) {\ndctx->cur_byte++;\nstate = (state << 8) | buf[i];\nif (dctx->cur_byte == 24) {\ndctx->h = (state >> 32) & 0xFFFF;\n} else if (dctx->cur_byte == 26) {\ndctx->w = (state >> 32) & 0xFFFF;\n} else if (dctx->cur_byte == 42) {\nint cid = (state >> 32) & 0xFFFFFFFF;\nif (cid <= 0)\ncontinue;\ndctx->remaining = avpriv_dnxhd_get_frame_size(cid);\nif (dctx->remaining <= 0) {\ndctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\nif (dctx->remaining <= 0)\nreturn dctx->remaining;\n}\nif (buf_size - i + 47 >= dctx->remaining) {\nint remaining = dctx->remaining;\npc->frame_start_found = 0;\npc->state64 = -1;\ndctx->cur_byte = 0;\ndctx->remaining = 0;\nreturn remaining;\n} else {\ndctx->remaining -= buf_size;\n}\n}\n}\n} else if (pic_found) {\nif (dctx->remaining > buf_size) {\ndctx->remaining -= buf_size;\n} else {\nint remaining = dctx->remaining;\npc->frame_start_found = 0;\npc->state64 = -1;\ndctx->cur_byte = 0;\ndctx->remaining = 0;\nreturn remaining;\n}\n}\npc->frame_start_found = pic_found;\npc->state64 = state;\nreturn END_NOT_FOUND;\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "max_stars_repo_path": "NA",
                        "__cluster__": 1951
                },
                {
                        "real_dup": "2"
                }
        ],
        [
                {
                        "id": "test_devign_test_set_data_18624",
                        "content": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\nlong i;\nfor (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\nlong a = *(long *)(src1 + i);\nlong b = *(long *)(src2 + i);\n*(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n}\nfor (; i < w; i++)\ndst[i] = src1[i] + src2[i];\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 1845
                },
                {
                        "id": "pretrain_c_data_3257346",
                        "content": "static void CVE_2013_7014_VULN_add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\nlong i;\nfor (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\nlong a = *(long *)(src1 + i);\nlong b = *(long *)(src2 + i);\n*(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n}\nfor (; i < w; i++)\ndst[i] = src1[i] + src2[i];\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2013_7014_VULN_add_bytes_l2_c.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 1845
                },
                {
                        "real_dup": "3"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_6541229",
                        "content": "<filename>dataset/source/NVD/CVE_2015_3395_VULN_msrle_decode_pal4.c\nstatic int CVE_2015_3395_VULN_msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\nGetByteContext *gb)\n{\nunsigned char rle_code;\nunsigned char extra_byte, odd_pixel;\nunsigned char stream_byte;\nunsigned int pixel_ptr = 0;\nint row_dec = pic->linesize[0];\nint row_ptr = (avctx->height - 1) * row_dec;\nint frame_size = row_dec * avctx->height;\nint i;\nwhile (row_ptr >= 0) {\nif (bytestream2_get_bytes_left(gb) <= 0) {\nav_log(avctx, AV_LOG_ERROR,\n\"MS RLE: bytestream overrun, %d rows left\\n\",\nrow_ptr);\nreturn AVERROR_INVALIDDATA;\n}\nrle_code = stream_byte = bytestream2_get_byteu(gb);\nif (rle_code == 0) {\n/* fetch the next byte to see how to handle escape code */\nstream_byte = bytestream2_get_byte(gb);\nif (stream_byte == 0) {\n/* line is done, goto the next one */\nrow_ptr -= row_dec;\npixel_ptr = 0;\n} else if (stream_byte == 1) {\n/* decode is done */\nreturn 0;\n} else if (stream_byte == 2) {\n/* reposition frame decode coordinates */\nstream_byte = bytestream2_get_byte(gb);\npixel_ptr += stream_byte;\nstream_byte = bytestream2_get_byte(gb);\nrow_ptr -= stream_byte * row_dec;\n} else {\n// copy pixels from encoded stream\nodd_pixel =  stream_byte & 1;\nrle_code = (stream_byte + 1) / 2;\nextra_byte = rle_code & 0x01;\nif (row_ptr + pixel_ptr + stream_byte > frame_size ||\nbytestream2_get_bytes_left(gb) < rle_code) {\nav_log(avctx, AV_LOG_ERROR,\n\"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nfor (i = 0; i < rle_code; i++) {\nif (pixel_ptr >= avctx->width)\nbreak;\nstream_byte = bytestream2_get_byteu(gb);\npic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\npixel_ptr++;\nif (i + 1 == rle_code && odd_pixel)\nbreak;\nif (pixel_ptr >= avctx->width)\nbreak;\npic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\npixel_ptr++;\n}\n// if the RLE code is odd, skip a byte in the stream\nif (extra_byte)\nbytestream2_skip(gb, 1);\n}\n} else {\n// decode a run of data\nif (row_ptr + pixel_ptr + stream_byte > frame_size) {\nav_log(avctx, AV_LOG_ERROR,\n\"MS RLE: frame ptr just went out of bounds (run)\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nstream_byte = bytestream2_get_byte(gb);\nfor (i = 0; i < rle_code; i++) {\nif (pixel_ptr >= avctx->width)\nbreak;\nif ((i & 1) == 0)\npic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\nelse\npic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\npixel_ptr++;\n}\n}\n}\n/* one last sanity check on the way out */\nif (bytestream2_get_bytes_left(gb)) {\nav_log(avctx, AV_LOG_ERROR,\n\"MS RLE: ended frame decode with %d bytes left over\\n\",\nbytestream2_get_bytes_left(gb));\nreturn AVERROR_INVALIDDATA;\n}\nreturn 0;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2015_3395_VULN_msrle_decode_pal4.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 1274
                },
                {
                        "id": "test_devign_test_set_data_12940",
                        "content": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\nGetByteContext *gb)\n{\nunsigned char rle_code;\nunsigned char extra_byte, odd_pixel;\nunsigned char stream_byte;\nunsigned int pixel_ptr = 0;\nint row_dec = pic->linesize[0];\nint row_ptr = (avctx->height - 1) * row_dec;\nint frame_size = row_dec * avctx->height;\nint i;\nwhile (row_ptr >= 0) {\nif (bytestream2_get_bytes_left(gb) <= 0) {\nav_log(avctx, AV_LOG_ERROR,\n\"MS RLE: bytestream overrun, %d rows left\\n\",\nrow_ptr);\nreturn AVERROR_INVALIDDATA;\n}\nrle_code = stream_byte = bytestream2_get_byteu(gb);\nif (rle_code == 0) {\n/* fetch the next byte to see how to handle escape code */\nstream_byte = bytestream2_get_byte(gb);\nif (stream_byte == 0) {\n/* line is done, goto the next one */\nrow_ptr -= row_dec;\npixel_ptr = 0;\n} else if (stream_byte == 1) {\n/* decode is done */\nreturn 0;\n} else if (stream_byte == 2) {\n/* reposition frame decode coordinates */\nstream_byte = bytestream2_get_byte(gb);\npixel_ptr += stream_byte;\nstream_byte = bytestream2_get_byte(gb);\nrow_ptr -= stream_byte * row_dec;\n} else {\n// copy pixels from encoded stream\nodd_pixel =  stream_byte & 1;\nrle_code = (stream_byte + 1) / 2;\nextra_byte = rle_code & 0x01;\nif (row_ptr + pixel_ptr + stream_byte > frame_size ||\nbytestream2_get_bytes_left(gb) < rle_code) {\nav_log(avctx, AV_LOG_ERROR,\n\"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nfor (i = 0; i < rle_code; i++) {\nif (pixel_ptr >= avctx->width)\nbreak;\nstream_byte = bytestream2_get_byteu(gb);\npic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\npixel_ptr++;\nif (i + 1 == rle_code && odd_pixel)\nbreak;\nif (pixel_ptr >= avctx->width)\nbreak;\npic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\npixel_ptr++;\n}\n// if the RLE code is odd, skip a byte in the stream\nif (extra_byte)\nbytestream2_skip(gb, 1);\n}\n} else {\n// decode a run of data\nif (row_ptr + pixel_ptr + stream_byte > frame_size) {\nav_log(avctx, AV_LOG_ERROR,\n\"MS RLE: frame ptr just went out of bounds (run)\\n\");\nreturn AVERROR_INVALIDDATA;\n}\nstream_byte = bytestream2_get_byte(gb);\nfor (i = 0; i < rle_code; i++) {\nif (pixel_ptr >= avctx->width)\nbreak;\nif ((i & 1) == 0)\npic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\nelse\npic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\npixel_ptr++;\n}\n}\n}\n/* one last sanity check on the way out */\nif (bytestream2_get_bytes_left(gb)) {\nav_log(avctx, AV_LOG_ERROR,\n\"MS RLE: ended frame decode with %d bytes left over\\n\",\nbytestream2_get_bytes_left(gb));\nreturn AVERROR_INVALIDDATA;\n}\nreturn 0;\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 1274
                },
                {
                        "real_dup": "3"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_8039055",
                        "content": "<filename>dataset/source/NVD/CVE_2013_7021_PATCHED_filter_frame.c\nstatic int CVE_2013_7021_PATCHED_filter_frame(AVFilterLink *inlink, AVFrame *buf)\n{\nAVFilterContext    *ctx = inlink->dst;\nFPSContext           *s = ctx->priv;\nAVFilterLink   *outlink = ctx->outputs[0];\nint64_t delta;\nint i, ret;\ns->frames_in++;\n/* discard frames until we get the first timestamp */\nif (s->pts == AV_NOPTS_VALUE) {\nif (buf->pts != AV_NOPTS_VALUE) {\nret = write_to_fifo(s->fifo, buf);\nif (ret < 0)\nreturn ret;\ns->first_pts = s->pts = buf->pts;\n} else {\nav_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n\"timestamp.\\n\");\nav_frame_free(&buf);\ns->drop++;\n}\nreturn 0;\n}\n/* now wait for the next timestamp */\nif (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) {\nreturn write_to_fifo(s->fifo, buf);\n}\n/* number of output frames */\ndelta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,\noutlink->time_base, s->rounding);\nif (delta < 1) {\n/* drop the frame and everything buffered except the first */\nAVFrame *tmp;\nint drop = av_fifo_size(s->fifo)/sizeof(AVFrame*);\nav_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\ns->drop += drop;\nav_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\nflush_fifo(s->fifo);\nret = write_to_fifo(s->fifo, tmp);\nav_frame_free(&buf);\nreturn ret;\n}\n/* can output >= 1 frames */\nfor (i = 0; i < delta; i++) {\nAVFrame *buf_out;\nav_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n/* duplicate the frame if needed */\nif (!av_fifo_size(s->fifo) && i < delta - 1) {\nAVFrame *dup = av_frame_clone(buf_out);\nav_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\nif (dup)\nret = write_to_fifo(s->fifo, dup);\nelse\nret = AVERROR(ENOMEM);\nif (ret < 0) {\nav_frame_free(&buf_out);\nav_frame_free(&buf);\nreturn ret;\n}\ns->dup++;\n}\nbuf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\noutlink->time_base) + s->frames_out;\nif ((ret = ff_filter_frame(outlink, buf_out)) < 0) {\nav_frame_free(&buf);\nreturn ret;\n}\ns->frames_out++;\n}\nflush_fifo(s->fifo);\nret = write_to_fifo(s->fifo, buf);\ns->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\nreturn ret;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2013_7021_PATCHED_filter_frame.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 2231
                },
                {
                        "id": "test_devign_test_set_data_22425",
                        "content": "static int end_frame(AVFilterLink *inlink)\n{\nAVFilterContext    *ctx = inlink->dst;\nFPSContext           *s = ctx->priv;\nAVFilterLink   *outlink = ctx->outputs[0];\nAVFilterBufferRef  *buf = inlink->cur_buf;\nint64_t delta;\nint i, ret;\ninlink->cur_buf = NULL;\ns->frames_in++;\n/* discard frames until we get the first timestamp */\nif (s->pts == AV_NOPTS_VALUE) {\nif (buf->pts != AV_NOPTS_VALUE) {\nwrite_to_fifo(s->fifo, buf);\ns->first_pts = s->pts = buf->pts;\n} else {\nav_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n\"timestamp.\\n\");\navfilter_unref_buffer(buf);\ns->drop++;\n}\nreturn 0;\n}\n/* now wait for the next timestamp */\nif (buf->pts == AV_NOPTS_VALUE) {\nreturn write_to_fifo(s->fifo, buf);\n}\n/* number of output frames */\ndelta = av_rescale_q(buf->pts - s->pts, inlink->time_base,\noutlink->time_base);\nif (delta < 1) {\n/* drop the frame and everything buffered except the first */\nAVFilterBufferRef *tmp;\nint drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);\nav_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\ns->drop += drop;\nav_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\nflush_fifo(s->fifo);\nret = write_to_fifo(s->fifo, tmp);\navfilter_unref_buffer(buf);\nreturn ret;\n}\n/* can output >= 1 frames */\nfor (i = 0; i < delta; i++) {\nAVFilterBufferRef *buf_out;\nav_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n/* duplicate the frame if needed */\nif (!av_fifo_size(s->fifo) && i < delta - 1) {\nav_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\nwrite_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));\ns->dup++;\n}\nbuf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\noutlink->time_base) + s->frames_out;\nif ((ret = ff_start_frame(outlink, buf_out)) < 0 ||\n(ret = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||\n(ret = ff_end_frame(outlink)) < 0) {\navfilter_unref_bufferp(&buf);\nreturn ret;\n}\ns->frames_out++;\n}\nflush_fifo(s->fifo);\nret = write_to_fifo(s->fifo, buf);\ns->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\nreturn ret;\n}\nThe vulnerability label is: Non-vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 2231
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "test_devign_test_set_data_5357",
                        "content": "int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,\nconst char *filename, void *logctx,\nunsigned int offset, unsigned int max_probe_size)\n{\nAVProbeData pd = { filename ? filename : \"\", NULL, -offset };\nunsigned char *buf = NULL;\nint ret = 0, probe_size;\nif (!max_probe_size) {\nmax_probe_size = PROBE_BUF_MAX;\n} else if (max_probe_size > PROBE_BUF_MAX) {\nmax_probe_size = PROBE_BUF_MAX;\n} else if (max_probe_size < PROBE_BUF_MIN) {\nreturn AVERROR(EINVAL);\n}\nif (offset >= max_probe_size) {\nreturn AVERROR(EINVAL);\n}\nfor(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;\nprobe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) {\nint score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0;\nint buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;\nvoid *buftmp;\nif (probe_size < offset) {\ncontinue;\n}\n/* read probe data */\nbuftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\nif(!buftmp){\nav_free(buf);\nreturn AVERROR(ENOMEM);\n}\nbuf=buftmp;\nif ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n/* fail if error was not end of file, otherwise, lower score */\nif (ret != AVERROR_EOF) {\nav_free(buf);\nreturn ret;\n}\nscore = 0;\nret = 0;            /* error was end of file, nothing read */\n}\npd.buf_size += ret;\npd.buf = &buf[offset];\nmemset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n/* guess file format */\n*fmt = av_probe_input_format2(&pd, 1, &score);\nif(*fmt){\nif(score <= AVPROBE_SCORE_RETRY){ //this can only be true in the last iteration\nav_log(logctx, AV_LOG_WARNING, \"Format %s detected only with low score of %d, misdetection possible!\\n\", (*fmt)->name, score);\n}else\nav_log(logctx, AV_LOG_DEBUG, \"Format %s probed with size=%d and score=%d\\n\", (*fmt)->name, probe_size, score);\n}\n}\nif (!*fmt) {\nav_free(buf);\nreturn AVERROR_INVALIDDATA;\n}\n/* rewind. reuse probe buffer to avoid seeking */\nret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size);\nreturn ret;\n}\nThe vulnerability label is: Non-vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 521
                },
                {
                        "id": "pretrain_c_data_1843254",
                        "content": "int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,\nconst char *filename, void *logctx,\nunsigned int offset, unsigned int max_probe_size)\n{\nAVProbeData pd = { filename ? filename : \"\", NULL, -offset };\nunsigned char *buf = NULL;\nint ret = 0, probe_size;\nif (!max_probe_size) {\nmax_probe_size = PROBE_BUF_MAX;\n} else if (max_probe_size > PROBE_BUF_MAX) {\nmax_probe_size = PROBE_BUF_MAX;\n} else if (max_probe_size < PROBE_BUF_MIN) {\nreturn AVERROR(EINVAL);\n}\nif (offset >= max_probe_size) {\nreturn AVERROR(EINVAL);\n}\nfor(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;\nprobe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) {\nint score = probe_size < max_probe_size ? AVPROBE_SCORE_MAX/4 : 0;\nint buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;\nvoid *buftmp;\nif (probe_size < offset) {\ncontinue;\n}\n/* read probe data */\nbuftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\nif(!buftmp){\nav_free(buf);\nreturn AVERROR(ENOMEM);\n}\nbuf=buftmp;\nif ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n/* fail if error was not end of file, otherwise, lower score */\nif (ret != AVERROR_EOF) {\nav_free(buf);\nreturn ret;\n}\nscore = 0;\nret = 0;            /* error was end of file, nothing read */\n}\npd.buf_size += ret;\npd.buf = &buf[offset];\nmemset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n/* guess file format */\n*fmt = av_probe_input_format2(&pd, 1, &score);\nif(*fmt){\nif(score <= AVPROBE_SCORE_MAX/4){ //this can only be true in the last iteration\nav_log(logctx, AV_LOG_WARNING, \"Format %s detected only with low score of %d, misdetection possible!\\n\", (*fmt)->name, score);\n}else\nav_log(logctx, AV_LOG_DEBUG, \"Format %s probed with size=%d and score=%d\\n\", (*fmt)->name, probe_size, score);\n}\n}\nif (!*fmt) {\nav_free(buf);\nreturn AVERROR_INVALIDDATA;\n}\n/* rewind. reuse probe buffer to avoid seeking */\nif ((ret = ffio_rewind_with_probe_data(pb, buf, pd.buf_size)) < 0)\nav_free(buf);\nreturn ret;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2012_6618_VULN_av_probe_input_buffer.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 521
                },
                {
                        "real_dup": 2
                }
        ],


        [
                {
                        "id": "pretrain_c_data_3545597",
                        "content": "static int CVE_2012_2779_PATCHED_decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)\n{\nif (get_bits(&ctx->gb, 5) != 0x1F) {\nav_log(avctx, AV_LOG_ERROR, \"Invalid picture start code!\\n\");\nreturn -1;\n}\nctx->prev_frame_type = ctx->frame_type;\nctx->frame_type      = get_bits(&ctx->gb, 3);\nif (ctx->frame_type >= 5) {\nav_log(avctx, AV_LOG_ERROR, \"Invalid frame type: %d \\n\", ctx->frame_type);\nreturn -1;\n}\nctx->frame_num = get_bits(&ctx->gb, 8);\nif (ctx->frame_type == FRAMETYPE_INTRA) {\nctx->gop_invalid = 1;\nif (decode_gop_header(ctx, avctx))\nreturn -1;\nctx->gop_invalid = 0;\n}\nif (ctx->frame_type != FRAMETYPE_NULL) {\nctx->frame_flags = get_bits(&ctx->gb, 8);\nctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;\nctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;\n/* skip unknown extension if any */\nif (ctx->frame_flags & 0x20)\nskip_hdr_extension(&ctx->gb); /* XXX: untested */\n/* decode macroblock huffman codebook */\nif (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))\nreturn -1;\nskip_bits(&ctx->gb, 3); /* FIXME: unknown meaning! */\n}\nalign_get_bits(&ctx->gb);\nreturn 0;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2012_2779_PATCHED_decode_pic_hdr.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 1036
                },
                {
                        "id": "test_devign_test_set_data_10671",
                        "content": "static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)\n{\nif (get_bits(&ctx->gb, 5) != 0x1F) {\nav_log(avctx, AV_LOG_ERROR, \"Invalid picture start code!\\n\");\nreturn -1;\nctx->prev_frame_type = ctx->frame_type;\nctx->frame_type      = get_bits(&ctx->gb, 3);\nif (ctx->frame_type >= 5) {\nav_log(avctx, AV_LOG_ERROR, \"Invalid frame type: %d \\n\", ctx->frame_type);\nreturn -1;\nctx->frame_num = get_bits(&ctx->gb, 8);\nif (ctx->frame_type == FRAMETYPE_INTRA) {\nctx->gop_invalid = 1;\nif (decode_gop_header(ctx, avctx))\nreturn -1;\nctx->gop_invalid = 0;\nif (ctx->frame_type != FRAMETYPE_NULL) {\nctx->frame_flags = get_bits(&ctx->gb, 8);\nctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;\nctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;\n/* skip unknown extension if any */\nif (ctx->frame_flags & 0x20)\nskip_hdr_extension(&ctx->gb); /* XXX: untested */\n/* decode macroblock huffman codebook */\nif (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))\nreturn -1;\nskip_bits(&ctx->gb, 3); /* FIXME: unknown meaning! */\nalign_get_bits(&ctx->gb);\nreturn 0;\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 1036
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_5023885",
                        "content": "#include \"find_bits.h\"\nunsigned long\nfind_next_zero_bit(const unsigned long *addr, unsigned long size,\nunsigned long offset)\n{\nconst unsigned long *p = addr + BITOP_WORD(offset);\nunsigned long result = offset & ~(BITS_PER_LONG-1);\nunsigned long tmp;\nif (offset >= size)\nreturn size;\nsize -= result;\noffset %= BITS_PER_LONG;\nif (offset) {\ntmp = *(p++);\ntmp |= ~0UL >> (BITS_PER_LONG - offset);\nif (size < BITS_PER_LONG)\ngoto found_first;\nif (~tmp)\ngoto found_middle;\nsize -= BITS_PER_LONG;\nresult += BITS_PER_LONG;\n}\nwhile (size & ~(BITS_PER_LONG-1)) {\nif (~(tmp = *(p++)))\ngoto found_middle;\nresult += BITS_PER_LONG;\nsize -= BITS_PER_LONG;\n}\nif (!size)\nreturn result;\ntmp = *p;\nfound_first:\ntmp |= ~0UL << size;\nif (tmp == ~0UL)/* Are any bits zero? */\nreturn result + size;   /* Nope. */\nfound_middle:\nreturn result + ffz(tmp);\n}\n",
                        "max_stars_repo_path": "src/find_bits.c",
                        "max_stars_count": 1.0,
                        "max_stars_repo_name": "caiolima/xv6-public",
                        "__cluster__": 2375
                },
                {
                        "id": "test_devign_test_set_data_23888",
                        "content": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\nunsigned long offset)\n{\nconst unsigned long *p = addr + BITOP_WORD(offset);\nunsigned long result = offset & ~(BITS_PER_LONG-1);\nunsigned long tmp;\nif (offset >= size) {\nreturn size;\n}\nsize -= result;\noffset %= BITS_PER_LONG;\nif (offset) {\ntmp = *(p++);\ntmp |= ~0UL >> (BITS_PER_LONG - offset);\nif (size < BITS_PER_LONG) {\ngoto found_first;\n}\nif (~tmp) {\ngoto found_middle;\n}\nsize -= BITS_PER_LONG;\nresult += BITS_PER_LONG;\n}\nwhile (size & ~(BITS_PER_LONG-1)) {\nif (~(tmp = *(p++))) {\ngoto found_middle;\n}\nresult += BITS_PER_LONG;\nsize -= BITS_PER_LONG;\n}\nif (!size) {\nreturn result;\n}\ntmp = *p;\nfound_first:\ntmp |= ~0UL << size;\nif (tmp == ~0UL) {\t/* Are any bits zero? */\nreturn result + size;\t/* Nope. */\n}\nfound_middle:\nreturn result + ffz(tmp);\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 2375
                },
                {
                        "real_dup": "2"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_6683377",
                        "content": "static int CVE_2013_3670_PATCHED_rle_unpack(const unsigned char *src, int src_len, int src_count,\nunsigned char *dest, int dest_len)\n{\nconst unsigned char *ps;\nconst unsigned char *ps_end;\nunsigned char *pd;\nint i, j, l;\nunsigned char *dest_end = dest + dest_len;\nps = src;\nps_end = src + src_len;\npd = dest;\nif (src_count & 1) {\nif (ps_end - ps < 1)\nreturn 0;\n*pd++ = *ps++;\n}\nsrc_count >>= 1;\ni = 0;\ndo {\nif (ps_end - ps < 1)\nbreak;\nl = *ps++;\nif (l & 0x80) {\nl = (l & 0x7F) * 2;\nif (dest_end - pd < l || ps_end - ps < l)\nreturn ps - src;\nmemcpy(pd, ps, l);\nps += l;\npd += l;\n} else {\nif (dest_end - pd < 2*l || ps_end - ps < 2)\nreturn ps - src;\nfor (j = 0; j < l; j++) {\n*pd++ = ps[0];\n*pd++ = ps[1];\n}\nps += 2;\n}\ni += l;\n} while (i < src_count);\nreturn ps - src;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2013_3670_PATCHED_rle_unpack.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 854
                },
                {
                        "id": "test_devign_test_set_data_8900",
                        "content": "static int rle_unpack(const unsigned char *src, int src_len, int src_count,\nunsigned char *dest, int dest_len)\n{\nconst unsigned char *ps;\nconst unsigned char *ps_end;\nunsigned char *pd;\nint i, l;\nunsigned char *dest_end = dest + dest_len;\nps = src;\nps_end = src + src_len;\npd = dest;\nif (src_count & 1) {\nif (ps_end - ps < 1)\nreturn 0;\n*pd++ = *ps++;\n}\nsrc_count >>= 1;\ni = 0;\ndo {\nif (ps_end - ps < 1)\nbreak;\nl = *ps++;\nif (l & 0x80) {\nl = (l & 0x7F) * 2;\nif (pd + l > dest_end || ps_end - ps < l)\nreturn ps - src;\nmemcpy(pd, ps, l);\nps += l;\npd += l;\n} else {\nif (pd + i > dest_end || ps_end - ps < 2)\nreturn ps - src;\nfor (i = 0; i < l; i++) {\n*pd++ = ps[0];\n*pd++ = ps[1];\n}\nps += 2;\n}\ni += l;\n} while (i < src_count);\nreturn ps - src;\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 854
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_6683377",
                        "content": "static int CVE_2013_3670_PATCHED_rle_unpack(const unsigned char *src, int src_len, int src_count,\nunsigned char *dest, int dest_len)\n{\nconst unsigned char *ps;\nconst unsigned char *ps_end;\nunsigned char *pd;\nint i, j, l;\nunsigned char *dest_end = dest + dest_len;\nps = src;\nps_end = src + src_len;\npd = dest;\nif (src_count & 1) {\nif (ps_end - ps < 1)\nreturn 0;\n*pd++ = *ps++;\n}\nsrc_count >>= 1;\ni = 0;\ndo {\nif (ps_end - ps < 1)\nbreak;\nl = *ps++;\nif (l & 0x80) {\nl = (l & 0x7F) * 2;\nif (dest_end - pd < l || ps_end - ps < l)\nreturn ps - src;\nmemcpy(pd, ps, l);\nps += l;\npd += l;\n} else {\nif (dest_end - pd < 2*l || ps_end - ps < 2)\nreturn ps - src;\nfor (j = 0; j < l; j++) {\n*pd++ = ps[0];\n*pd++ = ps[1];\n}\nps += 2;\n}\ni += l;\n} while (i < src_count);\nreturn ps - src;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2013_3670_PATCHED_rle_unpack.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 854
                },
                {
                        "id": "test_devign_test_set_data_13859",
                        "content": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\nint src_len, int dest_len)\n{\nconst unsigned char *ps;\nunsigned char *pd;\nint i, l;\nunsigned char *dest_end = dest + dest_len;\nps = src;\npd = dest;\nif (src_len & 1)\n*pd++ = *ps++;\nsrc_len >>= 1;\ni = 0;\ndo {\nl = *ps++;\nif (l & 0x80) {\nl = (l & 0x7F) * 2;\nif (pd + l > dest_end)\nreturn ps - src;\nmemcpy(pd, ps, l);\nps += l;\npd += l;\n} else {\nif (pd + i > dest_end)\nreturn ps - src;\nfor (i = 0; i < l; i++) {\n*pd++ = ps[0];\n*pd++ = ps[1];\n}\nps += 2;\n}\ni += l;\n} while (i < src_len);\nreturn ps - src;\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 854
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_576370",
                        "content": "<reponame>kppw99/enVAS\nstatic int CVE_2013_7024_VULN_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\nAVFrame *picture)\n{\nint compno, reslevelno, bandno;\nint x, y;\nuint8_t *line;\nJpeg2000T1Context t1;\n/* Loop on tile components */\nfor (compno = 0; compno < s->ncomponents; compno++) {\nJpeg2000Component *comp     = tile->comp + compno;\nJpeg2000CodingStyle *codsty = tile->codsty + compno;\n/* Loop on resolution levels */\nfor (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\nJpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n/* Loop on bands */\nfor (bandno = 0; bandno < rlevel->nbands; bandno++) {\nint nb_precincts, precno;\nJpeg2000Band *band = rlevel->band + bandno;\nint cblkno = 0, bandpos;\nbandpos = bandno + (reslevelno > 0);\nif (band->coord[0][0] == band->coord[0][1] ||\nband->coord[1][0] == band->coord[1][1])\ncontinue;\nnb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n/* Loop on precincts */\nfor (precno = 0; precno < nb_precincts; precno++) {\nJpeg2000Prec *prec = band->prec + precno;\n/* Loop on codeblocks */\nfor (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\nint x, y;\nJpeg2000Cblk *cblk = prec->cblk + cblkno;\ndecode_cblk(s, codsty, &t1, cblk,\ncblk->coord[0][1] - cblk->coord[0][0],\ncblk->coord[1][1] - cblk->coord[1][0],\nbandpos);\nx = cblk->coord[0][0];\ny = cblk->coord[1][0];\nif (codsty->transform == FF_DWT97)\ndequantization_float(x, y, cblk, comp, &t1, band);\nelse\ndequantization_int(x, y, cblk, comp, &t1, band);\n} /* end cblk */\n} /*end prec */\n} /* end band */\n} /* end reslevel */\n/* inverse DWT */\nff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n} /*end comp */\n/* inverse MCT transformation */\nif (tile->codsty[0].mct)\nmct_decode(s, tile);\nif (s->cdef[0] < 0) {\nfor (x = 0; x < s->ncomponents; x++)\ns->cdef[x] = x + 1;\nif ((s->ncomponents & 1) == 0)\ns->cdef[s->ncomponents-1] = 0;\n}\nif (s->precision <= 8) {\nfor (compno = 0; compno < s->ncomponents; compno++) {\nJpeg2000Component *comp = tile->comp + compno;\nJpeg2000CodingStyle *codsty = tile->codsty + compno;\nfloat *datap = comp->f_data;\nint32_t *i_datap = comp->i_data;\nint cbps = s->cbps[compno];\nint w = tile->comp[compno].coord[0][1] - s->image_offset_x;\nint planar = !!picture->data[2];\nint pixelsize = planar ? 1 : s->ncomponents;\nint plane = 0;\nif (planar)\nplane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\ny    = tile->comp[compno].coord[1][0] - s->image_offset_y;\nline = picture->data[plane] + y * picture->linesize[plane];\nfor (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\nuint8_t *dst;\nx   = tile->comp[compno].coord[0][0] - s->image_offset_x;\ndst = line + x * pixelsize + compno*!planar;\nif (codsty->transform == FF_DWT97) {\nfor (; x < w; x += s->cdx[compno]) {\nint val = lrintf(*datap) + (1 << (cbps - 1));\n/* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\nval = av_clip(val, 0, (1 << cbps) - 1);\n*dst = val << (8 - cbps);\ndatap++;\ndst += pixelsize;\n}\n} else {\nfor (; x < w; x += s->cdx[compno]) {\nint val = *i_datap + (1 << (cbps - 1));\n/* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\nval = av_clip(val, 0, (1 << cbps) - 1);\n*dst = val << (8 - cbps);\ni_datap++;\ndst += pixelsize;\n}\n}\nline += picture->linesize[plane];\n}\n}\n} else {\nfor (compno = 0; compno < s->ncomponents; compno++) {\nJpeg2000Component *comp = tile->comp + compno;\nJpeg2000CodingStyle *codsty = tile->codsty + compno;\nfloat *datap = comp->f_data;\nint32_t *i_datap = comp->i_data;\nuint16_t *linel;\nint cbps = s->cbps[compno];\nint w = tile->comp[compno].coord[0][1] - s->image_offset_x;\nint planar = !!picture->data[2];\nint pixelsize = planar ? 1 : s->ncomponents;\nint plane = 0;\nif (planar)\nplane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\ny     = tile->comp[compno].coord[1][0] - s->image_offset_y;\nlinel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\nfor (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\nuint16_t *dst;\nx   = tile->comp[compno].coord[0][0] - s->image_offset_x;\ndst = linel + (x * pixelsize + compno*!planar);\nif (codsty->transform == FF_DWT97) {\nfor (; x < w; x += s-> cdx[compno]) {\nint  val = lrintf(*datap) + (1 << (cbps - 1));\n/* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\nval = av_clip(val, 0, (1 << cbps) - 1);\n/* align 12 bit values in little-endian mode */\n*dst = val << (16 - cbps);\ndatap++;\ndst += pixelsize;\n}\n} else {\nfor (; x < w; x += s-> cdx[compno]) {\nint val = *i_datap + (1 << (cbps - 1));\n/* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\nval = av_clip(val, 0, (1 << cbps) - 1);\n/* align 12 bit values in little-endian mode */\n*dst = val << (16 - cbps);\ni_datap++;\ndst += pixelsize;\n}\n}\nlinel += picture->linesize[plane] >> 1;\n}\n}\n}\nreturn 0;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2013_7024_VULN_jpeg2000_decode_tile.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 1502
                },
                {
                        "id": "test_devign_test_set_data_15420",
                        "content": "static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\nAVFrame *picture)\n{\nint compno, reslevelno, bandno;\nint x, y;\nuint8_t *line;\nJpeg2000T1Context t1;\n/* Loop on tile components */\nfor (compno = 0; compno < s->ncomponents; compno++) {\nJpeg2000Component *comp     = tile->comp + compno;\nJpeg2000CodingStyle *codsty = tile->codsty + compno;\n/* Loop on resolution levels */\nfor (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\nJpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n/* Loop on bands */\nfor (bandno = 0; bandno < rlevel->nbands; bandno++) {\nint nb_precincts, precno;\nJpeg2000Band *band = rlevel->band + bandno;\nint cblkno = 0, bandpos;\nbandpos = bandno + (reslevelno > 0);\nif (band->coord[0][0] == band->coord[0][1] ||\nband->coord[1][0] == band->coord[1][1])\ncontinue;\nnb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n/* Loop on precincts */\nfor (precno = 0; precno < nb_precincts; precno++) {\nJpeg2000Prec *prec = band->prec + precno;\n/* Loop on codeblocks */\nfor (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\nint x, y;\nJpeg2000Cblk *cblk = prec->cblk + cblkno;\ndecode_cblk(s, codsty, &t1, cblk,\ncblk->coord[0][1] - cblk->coord[0][0],\ncblk->coord[1][1] - cblk->coord[1][0],\nbandpos);\nx = cblk->coord[0][0];\ny = cblk->coord[1][0];\nif (codsty->transform == FF_DWT97)\ndequantization_float(x, y, cblk, comp, &t1, band);\nelse\ndequantization_int(x, y, cblk, comp, &t1, band);\n} /* end cblk */\n} /*end prec */\n} /* end band */\n} /* end reslevel */\n/* inverse DWT */\nff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n} /*end comp */\n/* inverse MCT transformation */\nif (tile->codsty[0].mct)\nmct_decode(s, tile);\nif (s->cdef[0] < 0) {\nfor (x = 0; x < s->ncomponents; x++)\ns->cdef[x] = x + 1;\nif ((s->ncomponents & 1) == 0)\ns->cdef[s->ncomponents-1] = 0;\n}\nif (s->precision <= 8) {\nfor (compno = 0; compno < s->ncomponents; compno++) {\nJpeg2000Component *comp = tile->comp + compno;\nJpeg2000CodingStyle *codsty = tile->codsty + compno;\nfloat *datap = comp->f_data;\nint32_t *i_datap = comp->i_data;\nint cbps = s->cbps[compno];\nint w = tile->comp[compno].coord[0][1] - s->image_offset_x;\nint planar = !!picture->data[2];\nint pixelsize = planar ? 1 : s->ncomponents;\nint plane = 0;\nif (planar)\nplane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\ny    = tile->comp[compno].coord[1][0] - s->image_offset_y;\nline = picture->data[plane] + y * picture->linesize[plane];\nfor (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\nuint8_t *dst;\nx   = tile->comp[compno].coord[0][0] - s->image_offset_x;\ndst = line + x * pixelsize + compno*!planar;\nif (codsty->transform == FF_DWT97) {\nfor (; x < w; x += s->cdx[compno]) {\nint val = lrintf(*datap) + (1 << (cbps - 1));\n/* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\nval = av_clip(val, 0, (1 << cbps) - 1);\n*dst = val << (8 - cbps);\ndatap++;\ndst += pixelsize;\n}\n} else {\nfor (; x < w; x += s->cdx[compno]) {\nint val = *i_datap + (1 << (cbps - 1));\n/* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\nval = av_clip(val, 0, (1 << cbps) - 1);\n*dst = val << (8 - cbps);\ni_datap++;\ndst += pixelsize;\n}\n}\nline += picture->linesize[plane];\n}\n}\n} else {\nfor (compno = 0; compno < s->ncomponents; compno++) {\nJpeg2000Component *comp = tile->comp + compno;\nJpeg2000CodingStyle *codsty = tile->codsty + compno;\nfloat *datap = comp->f_data;\nint32_t *i_datap = comp->i_data;\nuint16_t *linel;\nint cbps = s->cbps[compno];\nint w = tile->comp[compno].coord[0][1] - s->image_offset_x;\nint planar = !!picture->data[2];\nint pixelsize = planar ? 1 : s->ncomponents;\nint plane = 0;\nif (planar)\nplane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\ny     = tile->comp[compno].coord[1][0] - s->image_offset_y;\nlinel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\nfor (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\nuint16_t *dst;\nx   = tile->comp[compno].coord[0][0] - s->image_offset_x;\ndst = linel + (x * pixelsize + compno*!planar);\nif (codsty->transform == FF_DWT97) {\nfor (; x < w; x += s-> cdx[compno]) {\nint  val = lrintf(*datap) + (1 << (cbps - 1));\n/* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\nval = av_clip(val, 0, (1 << cbps) - 1);\n/* align 12 bit values in little-endian mode */\n*dst = val << (16 - cbps);\ndatap++;\ndst += pixelsize;\n}\n} else {\nfor (; x < w; x += s-> cdx[compno]) {\nint val = *i_datap + (1 << (cbps - 1));\n/* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\nval = av_clip(val, 0, (1 << cbps) - 1);\n/* align 12 bit values in little-endian mode */\n*dst = val << (16 - cbps);\ni_datap++;\ndst += pixelsize;\n}\n}\nlinel += picture->linesize[plane] >> 1;\n}\n}\n}\nreturn 0;\n}\nThe vulnerability label is: Non-vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 1502
                },
                {
                        "real_dup": "3"
                }
        ],


        [
                {
                        "id": "test_devign_test_set_data_24472",
                        "content": "static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){\nlong i;\n#if !HAVE_FAST_UNALIGNED\nif((long)src2 & (sizeof(long)-1)){\nfor(i=0; i+7<w; i+=8){\ndst[i+0] = src1[i+0]-src2[i+0];\ndst[i+1] = src1[i+1]-src2[i+1];\ndst[i+2] = src1[i+2]-src2[i+2];\ndst[i+3] = src1[i+3]-src2[i+3];\ndst[i+4] = src1[i+4]-src2[i+4];\ndst[i+5] = src1[i+5]-src2[i+5];\ndst[i+6] = src1[i+6]-src2[i+6];\ndst[i+7] = src1[i+7]-src2[i+7];\n}\n}else\n#endif\nfor(i=0; i<=w-sizeof(long); i+=sizeof(long)){\nlong a = *(long*)(src1+i);\nlong b = *(long*)(src2+i);\n*(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n}\nfor(; i<w; i++)\ndst[i+0] = src1[i+0]-src2[i+0];\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 2440
                },
                {
                        "id": "pretrain_c_data_2269137",
                        "content": "static void CVE_2013_7010_PATCHED_diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\nlong i;\n#if !HAVE_FAST_UNALIGNED\nif((long)src2 & (sizeof(long)-1)){\nfor(i=0; i+7<w; i+=8){\ndst[i+0] = src1[i+0]-src2[i+0];\ndst[i+1] = src1[i+1]-src2[i+1];\ndst[i+2] = src1[i+2]-src2[i+2];\ndst[i+3] = src1[i+3]-src2[i+3];\ndst[i+4] = src1[i+4]-src2[i+4];\ndst[i+5] = src1[i+5]-src2[i+5];\ndst[i+6] = src1[i+6]-src2[i+6];\ndst[i+7] = src1[i+7]-src2[i+7];\n}\n}else\n#endif\nfor(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\nlong a = *(long*)(src1+i);\nlong b = *(long*)(src2+i);\n*(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n}\nfor(; i<w; i++)\ndst[i+0] = src1[i+0]-src2[i+0];\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2013_7010_PATCHED_diff_bytes_c.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 2440
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_2453071",
                        "content": "#include <monitor/monitor.h>\n#include <sysemu/sysemu.h>\n#include <sysemu/blockdev.h>\nint pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n{\n/* On non-x86 we don't do PCI hotplug */\nmonitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\nreturn -1;\n}",
                        "max_stars_repo_path": "xen-4.6.0/tools/qemu-xen/stubs/pci-drive-hot-add.c",
                        "max_stars_count": 473.0,
                        "max_stars_repo_name": "StanPlatinum/VMI-as-a-Service",
                        "__cluster__": 959
                },
                {
                        "id": "test_devign_test_set_data_9845",
                        "content": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n{\n/* On non-x86 we don't do PCI hotplug */\nmonitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\nreturn -1;\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 959
                },
                {
                        "real_dup": "3"
                }
        ],


        [
                {
                        "id": "test_devign_test_set_data_7749",
                        "content": "static void realview_init(ram_addr_t ram_size, int vga_ram_size,\nconst char *boot_device, DisplayState *ds,\nconst char *kernel_filename, const char *kernel_cmdline,\nconst char *initrd_filename, const char *cpu_model)\n{\nCPUState *env;\nqemu_irq *pic;\nvoid *scsi_hba;\nPCIBus *pci_bus;\nNICInfo *nd;\nint n;\nint done_smc = 0;\nqemu_irq cpu_irq[4];\nint ncpu;\nint index;\nif (!cpu_model)\ncpu_model = \"arm926\";\n/* FIXME: obey smp_cpus.  */\nif (strcmp(cpu_model, \"arm11mpcore\") == 0) {\nncpu = 4;\n} else {\nncpu = 1;\n}\nfor (n = 0; n < ncpu; n++) {\nenv = cpu_init(cpu_model);\nif (!env) {\nfprintf(stderr, \"Unable to find CPU definition\\n\");\nexit(1);\n}\npic = arm_pic_init_cpu(env);\ncpu_irq[n] = pic[ARM_PIC_CPU_IRQ];\nif (n > 0) {\n/* Set entry point for secondary CPUs.  This assumes we're using\nthe init code from arm_boot.c.  Real hardware resets all CPUs\nthe same.  */\nenv->regs[15] = 0x80000000;\n}\n}\n/* ??? RAM should repeat to fill physical memory space.  */\n/* SDRAM at address zero.  */\ncpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\narm_sysctl_init(0x10000000, 0xc1400400);\nif (ncpu == 1) {\n/* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3\nis nIRQ (there are inconsistencies).  However Linux 2.6.17 expects\nGIC1 to be nIRQ and ignores all the others, so do that for now.  */\npic = realview_gic_init(0x10040000, cpu_irq[0]);\n} else {\npic = mpcore_irq_init(cpu_irq);\n}\npl050_init(0x10006000, pic[20], 0);\npl050_init(0x10007000, pic[21], 1);\npl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM);\npl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM);\npl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM);\npl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM);\n/* DMA controller is optional, apparently.  */\npl080_init(0x10030000, pic[24], 2);\nsp804_init(0x10011000, pic[4]);\nsp804_init(0x10012000, pic[5]);\npl110_init(ds, 0x10020000, pic[23], 1);\nindex = drive_get_index(IF_SD, 0, 0);\nif (index == -1) {\nfprintf(stderr, \"qemu: missing SecureDigital card\\n\");\nexit(1);\n}\npl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]);\npl031_init(0x10017000, pic[10]);\npci_bus = pci_vpb_init(pic, 48, 1);\nif (usb_enabled) {\nusb_ohci_init_pci(pci_bus, 3, -1);\n}\nif (drive_get_max_bus(IF_SCSI) > 0) {\nfprintf(stderr, \"qemu: too many SCSI bus\\n\");\nexit(1);\n}\nscsi_hba = lsi_scsi_init(pci_bus, -1);\nfor (n = 0; n < LSI_MAX_DEVS; n++) {\nindex = drive_get_index(IF_SCSI, 0, n);\nif (index == -1)\ncontinue;\nlsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n}\nfor(n = 0; n < nb_nics; n++) {\nnd = &nd_table[n];\nif (!nd->model)\nnd->model = done_smc ? \"rtl8139\" : \"smc91c111\";\nif (strcmp(nd->model, \"smc91c111\") == 0) {\nsmc91c111_init(nd, 0x4e000000, pic[28]);\n} else {\npci_nic_init(pci_bus, nd, -1);\n}\n}\n/* Memory map for RealView Emulation Baseboard:  */\n/* 0x10000000 System registers.  */\n/*  0x10001000 System controller.  */\n/*  0x10002000 Two-Wire Serial Bus.  */\n/* 0x10003000 Reserved.  */\n/*  0x10004000 AACI.  */\n/*  0x10005000 MCI.  */\n/* 0x10006000 KMI0.  */\n/* 0x10007000 KMI1.  */\n/*  0x10008000 Character LCD.  */\n/* 0x10009000 UART0.  */\n/* 0x1000a000 UART1.  */\n/* 0x1000b000 UART2.  */\n/* 0x1000c000 UART3.  */\n/*  0x1000d000 SSPI.  */\n/*  0x1000e000 SCI.  */\n/* 0x1000f000 Reserved.  */\n/*  0x10010000 Watchdog.  */\n/* 0x10011000 Timer 0+1.  */\n/* 0x10012000 Timer 2+3.  */\n/*  0x10013000 GPIO 0.  */\n/*  0x10014000 GPIO 1.  */\n/*  0x10015000 GPIO 2.  */\n/* 0x10016000 Reserved.  */\n/* 0x10017000 RTC.  */\n/*  0x10018000 DMC.  */\n/*  0x10019000 PCI controller config.  */\n/*  0x10020000 CLCD.  */\n/* 0x10030000 DMA Controller.  */\n/* 0x10040000 GIC1.  */\n/* 0x10050000 GIC2.  */\n/* 0x10060000 GIC3.  */\n/* 0x10070000 GIC4.  */\n/*  0x10080000 SMC.  */\n/*  0x40000000 NOR flash.  */\n/*  0x44000000 DoC flash.  */\n/*  0x48000000 SRAM.  */\n/*  0x4c000000 Configuration flash.  */\n/* 0x4e000000 Ethernet.  */\n/*  0x4f000000 USB.  */\n/*  0x50000000 PISMO.  */\n/*  0x54000000 PISMO.  */\n/*  0x58000000 PISMO.  */\n/*  0x5c000000 PISMO.  */\n/* 0x60000000 PCI.  */\n/* 0x61000000 PCI Self Config.  */\n/* 0x62000000 PCI Config.  */\n/* 0x63000000 PCI IO.  */\n/* 0x64000000 PCI mem 0.  */\n/* 0x68000000 PCI mem 1.  */\n/* 0x6c000000 PCI mem 2.  */\nrealview_binfo.ram_size = ram_size;\nrealview_binfo.kernel_filename = kernel_filename;\nrealview_binfo.kernel_cmdline = kernel_cmdline;\nrealview_binfo.initrd_filename = initrd_filename;\nrealview_binfo.nb_cpus = ncpu;\narm_load_kernel(first_cpu, &realview_binfo);\n/* ??? Hack to map an additional page of ram for the secondary CPU\nstartup code.  I guess this works on real hardware because the\nBootROM happens to be in ROM/flash or in memory that isn't clobbered\nuntil after Linux boots the secondary CPUs.  */\ncpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);\n}\nThe vulnerability label is: Non-vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 746
                },
                {
                        "id": "pretrain_c_data_4016663",
                        "content": "/*\n* ARM RealView Baseboard System emulation.\n*\n* Copyright (c) 2006-2007 CodeSourcery.\n* Written by <NAME>\n*\n* This code is licenced under the GPL.\n*/\n#include \"hw.h\"\n#include \"arm-misc.h\"\n#include \"primecell.h\"\n#include \"devices.h\"\n#include \"pci.h\"\n#include \"net.h\"\n#include \"sysemu.h\"\n#include \"boards.h\"\n/* Board init.  */\nstatic struct arm_boot_info realview_binfo = {\n.loader_start = 0x0,\n.board_id = 0x33b,\n};\nstatic void realview_init(ram_addr_t ram_size, int vga_ram_size,\nconst char *boot_device,\nconst char *kernel_filename, const char *kernel_cmdline,\nconst char *initrd_filename, const char *cpu_model)\n{\nCPUState *env;\nqemu_irq *pic;\nvoid *scsi_hba;\nPCIBus *pci_bus;\nNICInfo *nd;\nint n;\nint done_smc = 0;\nqemu_irq cpu_irq[4];\nint ncpu;\nint index;\nif (!cpu_model)\ncpu_model = \"arm926\";\n/* FIXME: obey smp_cpus.  */\nif (strcmp(cpu_model, \"arm11mpcore\") == 0) {\nncpu = 4;\n} else {\nncpu = 1;\n}\nfor (n = 0; n < ncpu; n++) {\nenv = cpu_init(cpu_model);\nif (!env) {\nfprintf(stderr, \"Unable to find CPU definition\\n\");\nexit(1);\n}\npic = arm_pic_init_cpu(env);\ncpu_irq[n] = pic[ARM_PIC_CPU_IRQ];\nif (n > 0) {\n/* Set entry point for secondary CPUs.  This assumes we're using\nthe init code from arm_boot.c.  Real hardware resets all CPUs\nthe same.  */\nenv->regs[15] = 0x80000000;\n}\n}\n/* ??? RAM should repeat to fill physical memory space.  */\n/* SDRAM at address zero.  */\ncpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\narm_sysctl_init(0x10000000, 0xc1400400);\nif (ncpu == 1) {\n/* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3\nis nIRQ (there are inconsistencies).  However Linux 2.6.17 expects\nGIC1 to be nIRQ and ignores all the others, so do that for now.  */\npic = realview_gic_init(0x10040000, cpu_irq[0]);\n} else {\npic = mpcore_irq_init(cpu_irq);\n}\npl050_init(0x10006000, pic[20], 0);\npl050_init(0x10007000, pic[21], 1);\npl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM);\npl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM);\npl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM);\npl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM);\n/* DMA controller is optional, apparently.  */\npl080_init(0x10030000, pic[24], 2);\nsp804_init(0x10011000, pic[4]);\nsp804_init(0x10012000, pic[5]);\npl110_init(0x10020000, pic[23], 1);\nindex = drive_get_index(IF_SD, 0, 0);\nif (index == -1) {\nfprintf(stderr, \"qemu: missing SecureDigital card\\n\");\nexit(1);\n}\npl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]);\npl031_init(0x10017000, pic[10]);\npci_bus = pci_vpb_init(pic, 48, 1);\nif (usb_enabled) {\nusb_ohci_init_pci(pci_bus, 3, -1);\n}\nif (drive_get_max_bus(IF_SCSI) > 0) {\nfprintf(stderr, \"qemu: too many SCSI bus\\n\");\nexit(1);\n}\nscsi_hba = lsi_scsi_init(pci_bus, -1);\nfor (n = 0; n < LSI_MAX_DEVS; n++) {\nindex = drive_get_index(IF_SCSI, 0, n);\nif (index == -1)\ncontinue;\nlsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n}\nfor(n = 0; n < nb_nics; n++) {\nnd = &nd_table[n];\nif ((!nd->model && !done_smc) || strcmp(nd->model, \"smc91c111\") == 0) {\nsmc91c111_init(nd, 0x4e000000, pic[28]);\ndone_smc = 1;\n} else {\npci_nic_init(pci_bus, nd, -1, \"rtl8139\");\n}\n}\n/* Memory map for RealView Emulation Baseboard:  */\n/* 0x10000000 System registers.  */\n/*  0x10001000 System controller.  */\n/*  0x10002000 Two-Wire Serial Bus.  */\n/* 0x10003000 Reserved.  */\n/*  0x10004000 AACI.  */\n/*  0x10005000 MCI.  */\n/* 0x10006000 KMI0.  */\n/* 0x10007000 KMI1.  */\n/*  0x10008000 Character LCD.  */\n/* 0x10009000 UART0.  */\n/* 0x1000a000 UART1.  */\n/* 0x1000b000 UART2.  */\n/* 0x1000c000 UART3.  */\n/*  0x1000d000 SSPI.  */\n/*  0x1000e000 SCI.  */\n/* 0x1000f000 Reserved.  */\n/*  0x10010000 Watchdog.  */\n/* 0x10011000 Timer 0+1.  */\n/* 0x10012000 Timer 2+3.  */\n/*  0x10013000 GPIO 0.  */\n/*  0x10014000 GPIO 1.  */\n/*  0x10015000 GPIO 2.  */\n/* 0x10016000 Reserved.  */\n/* 0x10017000 RTC.  */\n/*  0x10018000 DMC.  */\n/*  0x10019000 PCI controller config.  */\n/*  0x10020000 CLCD.  */\n/* 0x10030000 DMA Controller.  */\n/* 0x10040000 GIC1.  */\n/* 0x10050000 GIC2.  */\n/* 0x10060000 GIC3.  */\n/* 0x10070000 GIC4.  */\n/*  0x10080000 SMC.  */\n/*  0x40000000 NOR flash.  */\n/*  0x44000000 DoC flash.  */\n/*  0x48000000 SRAM.  */\n/*  0x4c000000 Configuration flash.  */\n/* 0x4e000000 Ethernet.  */\n/*  0x4f000000 USB.  */\n/*  0x50000000 PISMO.  */\n/*  0x54000000 PISMO.  */\n/*  0x58000000 PISMO.  */\n/*  0x5c000000 PISMO.  */\n/* 0x60000000 PCI.  */\n/* 0x61000000 PCI Self Config.  */\n/* 0x62000000 PCI Config.  */\n/* 0x63000000 PCI IO.  */\n/* 0x64000000 PCI mem 0.  */\n/* 0x68000000 PCI mem 1.  */\n/* 0x6c000000 PCI mem 2.  */\nrealview_binfo.ram_size = ram_size;\nrealview_binfo.kernel_filename = kernel_filename;\nrealview_binfo.kernel_cmdline = kernel_cmdline;\nrealview_binfo.initrd_filename = initrd_filename;\nrealview_binfo.nb_cpus = ncpu;\narm_load_kernel(first_cpu, &realview_binfo);\n/* ??? Hack to map an additional page of ram for the secondary CPU\nstartup code.  I guess this works on real hardware because the\nBootROM happens to be in ROM/flash or in memory that isn't clobbered\nuntil after Linux boots the secondary CPUs.  */\ncpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);\n}\nQEMUMachine realview_machine = {\n.name = \"realview\",\n.desc = \"ARM RealView Emulation Baseboard (ARM926EJ-S)\",\n.init = realview_init,\n.ram_require = 0x1000,\n.use_scsi = 1,\n};",
                        "max_stars_repo_path": "xen/xen-4.2.2/tools/qemu-xen-traditional/hw/realview.c",
                        "max_stars_count": 3.0,
                        "max_stars_repo_name": "zhiming-shen/Xen-Blanket-NG",
                        "__cluster__": 746
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "test_devign_test_set_data_13130",
                        "content": "static int cpu_load_old(QEMUFile *f, void *opaque, int version_id)\n{\nPowerPCCPU *cpu = opaque;\nCPUPPCState *env = &cpu->env;\nunsigned int i, j;\ntarget_ulong sdr1;\nuint32_t fpscr;\ntarget_ulong xer;\nfor (i = 0; i < 32; i++)\nqemu_get_betls(f, &env->gpr[i]);\n#if !defined(TARGET_PPC64)\nfor (i = 0; i < 32; i++)\nqemu_get_betls(f, &env->gprh[i]);\n#endif\nqemu_get_betls(f, &env->lr);\nqemu_get_betls(f, &env->ctr);\nfor (i = 0; i < 8; i++)\nqemu_get_be32s(f, &env->crf[i]);\nqemu_get_betls(f, &xer);\ncpu_write_xer(env, xer);\nqemu_get_betls(f, &env->reserve_addr);\nqemu_get_betls(f, &env->msr);\nfor (i = 0; i < 4; i++)\nqemu_get_betls(f, &env->tgpr[i]);\nfor (i = 0; i < 32; i++) {\nunion {\nfloat64 d;\nuint64_t l;\n} u;\nu.l = qemu_get_be64(f);\nenv->fpr[i] = u.d;\n}\nqemu_get_be32s(f, &fpscr);\nenv->fpscr = fpscr;\nqemu_get_sbe32s(f, &env->access_type);\n#if defined(TARGET_PPC64)\nqemu_get_betls(f, &env->spr[SPR_ASR]);\nqemu_get_sbe32s(f, &env->slb_nr);\n#endif\nqemu_get_betls(f, &sdr1);\nfor (i = 0; i < 32; i++)\nqemu_get_betls(f, &env->sr[i]);\nfor (i = 0; i < 2; i++)\nfor (j = 0; j < 8; j++)\nqemu_get_betls(f, &env->DBAT[i][j]);\nfor (i = 0; i < 2; i++)\nfor (j = 0; j < 8; j++)\nqemu_get_betls(f, &env->IBAT[i][j]);\nqemu_get_sbe32s(f, &env->nb_tlb);\nqemu_get_sbe32s(f, &env->tlb_per_way);\nqemu_get_sbe32s(f, &env->nb_ways);\nqemu_get_sbe32s(f, &env->last_way);\nqemu_get_sbe32s(f, &env->id_tlbs);\nqemu_get_sbe32s(f, &env->nb_pids);\nif (env->tlb.tlb6) {\n// XXX assumes 6xx\nfor (i = 0; i < env->nb_tlb; i++) {\nqemu_get_betls(f, &env->tlb.tlb6[i].pte0);\nqemu_get_betls(f, &env->tlb.tlb6[i].pte1);\nqemu_get_betls(f, &env->tlb.tlb6[i].EPN);\n}\n}\nfor (i = 0; i < 4; i++)\nqemu_get_betls(f, &env->pb[i]);\nfor (i = 0; i < 1024; i++)\nqemu_get_betls(f, &env->spr[i]);\nppc_store_sdr1(env, sdr1);\nqemu_get_be32s(f, &env->vscr);\nqemu_get_be64s(f, &env->spe_acc);\nqemu_get_be32s(f, &env->spe_fscr);\nqemu_get_betls(f, &env->msr_mask);\nqemu_get_be32s(f, &env->flags);\nqemu_get_sbe32s(f, &env->error_code);\nqemu_get_be32s(f, &env->pending_interrupts);\nqemu_get_be32s(f, &env->irq_input_state);\nfor (i = 0; i < POWERPC_EXCP_NB; i++)\nqemu_get_betls(f, &env->excp_vectors[i]);\nqemu_get_betls(f, &env->excp_prefix);\nqemu_get_betls(f, &env->ivor_mask);\nqemu_get_betls(f, &env->ivpr_mask);\nqemu_get_betls(f, &env->hreset_vector);\nqemu_get_betls(f, &env->nip);\nqemu_get_betls(f, &env->hflags);\nqemu_get_betls(f, &env->hflags_nmsr);\nqemu_get_sbe32s(f, &env->mmu_idx);\nqemu_get_sbe32(f); /* Discard unused power_mode */\nreturn 0;\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 1296
                },
                {
                        "id": "pretrain_c_data_6196322",
                        "content": "#include \"hw/hw.h\"\n#include \"hw/boards.h\"\n#include \"kvm.h\"\nvoid cpu_save(QEMUFile *f, void *opaque)\n{\nCPUState *env = (CPUState *)opaque;\nunsigned int i, j;\nfor (i = 0; i < 32; i++)\nqemu_put_betls(f, &env->gpr[i]);\n#if !defined(TARGET_PPC64)\nfor (i = 0; i < 32; i++)\nqemu_put_betls(f, &env->gprh[i]);\n#endif\nqemu_put_betls(f, &env->lr);\nqemu_put_betls(f, &env->ctr);\nfor (i = 0; i < 8; i++)\nqemu_put_be32s(f, &env->crf[i]);\nqemu_put_betls(f, &env->xer);\nqemu_put_betls(f, &env->reserve_addr);\nqemu_put_betls(f, &env->msr);\nfor (i = 0; i < 4; i++)\nqemu_put_betls(f, &env->tgpr[i]);\nfor (i = 0; i < 32; i++) {\nunion {\nfloat64 d;\nuint64_t l;\n} u;\nu.d = env->fpr[i];\nqemu_put_be64(f, u.l);\n}\nqemu_put_be32s(f, &env->fpscr);\nqemu_put_sbe32s(f, &env->access_type);\n#if !defined(CONFIG_USER_ONLY)\n#if defined(TARGET_PPC64)\nqemu_put_betls(f, &env->asr);\nqemu_put_sbe32s(f, &env->slb_nr);\n#endif\nqemu_put_betls(f, &env->spr[SPR_SDR1]);\nfor (i = 0; i < 32; i++)\nqemu_put_betls(f, &env->sr[i]);\nfor (i = 0; i < 2; i++)\nfor (j = 0; j < 8; j++)\nqemu_put_betls(f, &env->DBAT[i][j]);\nfor (i = 0; i < 2; i++)\nfor (j = 0; j < 8; j++)\nqemu_put_betls(f, &env->IBAT[i][j]);\nqemu_put_sbe32s(f, &env->nb_tlb);\nqemu_put_sbe32s(f, &env->tlb_per_way);\nqemu_put_sbe32s(f, &env->nb_ways);\nqemu_put_sbe32s(f, &env->last_way);\nqemu_put_sbe32s(f, &env->id_tlbs);\nqemu_put_sbe32s(f, &env->nb_pids);\nif (env->tlb) {\n// XXX assumes 6xx\nfor (i = 0; i < env->nb_tlb; i++) {\nqemu_put_betls(f, &env->tlb[i].tlb6.pte0);\nqemu_put_betls(f, &env->tlb[i].tlb6.pte1);\nqemu_put_betls(f, &env->tlb[i].tlb6.EPN);\n}\n}\nfor (i = 0; i < 4; i++)\nqemu_put_betls(f, &env->pb[i]);\n#endif\nfor (i = 0; i < 1024; i++)\nqemu_put_betls(f, &env->spr[i]);\nqemu_put_be32s(f, &env->vscr);\nqemu_put_be64s(f, &env->spe_acc);\nqemu_put_be32s(f, &env->spe_fscr);\nqemu_put_betls(f, &env->msr_mask);\nqemu_put_be32s(f, &env->flags);\nqemu_put_sbe32s(f, &env->error_code);\nqemu_put_be32s(f, &env->pending_interrupts);\n#if !defined(CONFIG_USER_ONLY)\nqemu_put_be32s(f, &env->irq_input_state);\nfor (i = 0; i < POWERPC_EXCP_NB; i++)\nqemu_put_betls(f, &env->excp_vectors[i]);\nqemu_put_betls(f, &env->excp_prefix);\nqemu_put_betls(f, &env->hreset_excp_prefix);\nqemu_put_betls(f, &env->ivor_mask);\nqemu_put_betls(f, &env->ivpr_mask);\nqemu_put_betls(f, &env->hreset_vector);\n#endif\nqemu_put_betls(f, &env->nip);\nqemu_put_betls(f, &env->hflags);\nqemu_put_betls(f, &env->hflags_nmsr);\nqemu_put_sbe32s(f, &env->mmu_idx);\nqemu_put_sbe32s(f, &env->power_mode);\n}\nint cpu_load(QEMUFile *f, void *opaque, int version_id)\n{\nCPUState *env = (CPUState *)opaque;\nunsigned int i, j;\ntarget_ulong sdr1;\nfor (i = 0; i < 32; i++)\nqemu_get_betls(f, &env->gpr[i]);\n#if !defined(TARGET_PPC64)\nfor (i = 0; i < 32; i++)\nqemu_get_betls(f, &env->gprh[i]);\n#endif\nqemu_get_betls(f, &env->lr);\nqemu_get_betls(f, &env->ctr);\nfor (i = 0; i < 8; i++)\nqemu_get_be32s(f, &env->crf[i]);\nqemu_get_betls(f, &env->xer);\nqemu_get_betls(f, &env->reserve_addr);\nqemu_get_betls(f, &env->msr);\nfor (i = 0; i < 4; i++)\nqemu_get_betls(f, &env->tgpr[i]);\nfor (i = 0; i < 32; i++) {\nunion {\nfloat64 d;\nuint64_t l;\n} u;\nu.l = qemu_get_be64(f);\nenv->fpr[i] = u.d;\n}\nqemu_get_be32s(f, &env->fpscr);\nqemu_get_sbe32s(f, &env->access_type);\n#if !defined(CONFIG_USER_ONLY)\n#if defined(TARGET_PPC64)\nqemu_get_betls(f, &env->asr);\nqemu_get_sbe32s(f, &env->slb_nr);\n#endif\nqemu_get_betls(f, &sdr1);\nfor (i = 0; i < 32; i++)\nqemu_get_betls(f, &env->sr[i]);\nfor (i = 0; i < 2; i++)\nfor (j = 0; j < 8; j++)\nqemu_get_betls(f, &env->DBAT[i][j]);\nfor (i = 0; i < 2; i++)\nfor (j = 0; j < 8; j++)\nqemu_get_betls(f, &env->IBAT[i][j]);\nqemu_get_sbe32s(f, &env->nb_tlb);\nqemu_get_sbe32s(f, &env->tlb_per_way);\nqemu_get_sbe32s(f, &env->nb_ways);\nqemu_get_sbe32s(f, &env->last_way);\nqemu_get_sbe32s(f, &env->id_tlbs);\nqemu_get_sbe32s(f, &env->nb_pids);\nif (env->tlb) {\n// XXX assumes 6xx\nfor (i = 0; i < env->nb_tlb; i++) {\nqemu_get_betls(f, &env->tlb[i].tlb6.pte0);\nqemu_get_betls(f, &env->tlb[i].tlb6.pte1);\nqemu_get_betls(f, &env->tlb[i].tlb6.EPN);\n}\n}\nfor (i = 0; i < 4; i++)\nqemu_get_betls(f, &env->pb[i]);\n#endif\nfor (i = 0; i < 1024; i++)\nqemu_get_betls(f, &env->spr[i]);\nppc_store_sdr1(env, sdr1);\nqemu_get_be32s(f, &env->vscr);\nqemu_get_be64s(f, &env->spe_acc);\nqemu_get_be32s(f, &env->spe_fscr);\nqemu_get_betls(f, &env->msr_mask);\nqemu_get_be32s(f, &env->flags);\nqemu_get_sbe32s(f, &env->error_code);\nqemu_get_be32s(f, &env->pending_interrupts);\n#if !defined(CONFIG_USER_ONLY)\nqemu_get_be32s(f, &env->irq_input_state);\nfor (i = 0; i < POWERPC_EXCP_NB; i++)\nqemu_get_betls(f, &env->excp_vectors[i]);\nqemu_get_betls(f, &env->excp_prefix);\nqemu_get_betls(f, &env->hreset_excp_prefix);\nqemu_get_betls(f, &env->ivor_mask);\nqemu_get_betls(f, &env->ivpr_mask);\nqemu_get_betls(f, &env->hreset_vector);\n#endif\nqemu_get_betls(f, &env->nip);\nqemu_get_betls(f, &env->hflags);\nqemu_get_betls(f, &env->hflags_nmsr);\nqemu_get_sbe32s(f, &env->mmu_idx);\nqemu_get_sbe32s(f, &env->power_mode);\nreturn 0;\n}",
                        "max_stars_repo_path": "Main/linux/target-ppc/machine.c",
                        "max_stars_count": 18.0,
                        "max_stars_repo_name": "userlandkernel/iDeviceEMU",
                        "__cluster__": 1296
                },
                {
                        "real_dup": "1"
                }
        ],


        [
                {
                        "id": "pretrain_c_data_4717128",
                        "content": "<reponame>kppw99/enVAS\nstatic int CVE_2013_0869_VULN_field_end(H264Context *h, int in_setup)\n{\nMpegEncContext *const s     = &h->s;\nAVCodecContext *const avctx = s->avctx;\nint err = 0;\ns->mb_y = 0;\nif (!in_setup && !s->dropable)\nff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX,\ns->picture_structure == PICT_BOTTOM_FIELD);\nif (CONFIG_H264_VDPAU_DECODER &&\ns->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\nff_vdpau_h264_set_reference_frames(s);\nif (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\nif (!s->dropable) {\nerr = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\nh->prev_poc_msb = h->poc_msb;\nh->prev_poc_lsb = h->poc_lsb;\n}\nh->prev_frame_num_offset = h->frame_num_offset;\nh->prev_frame_num        = h->frame_num;\nh->outputed_poc          = h->next_outputed_poc;\n}\nif (avctx->hwaccel) {\nif (avctx->hwaccel->end_frame(avctx) < 0)\nav_log(avctx, AV_LOG_ERROR,\n\"hardware accelerator failed to decode picture\\n\");\n}\nif (CONFIG_H264_VDPAU_DECODER &&\ns->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\nff_vdpau_h264_picture_complete(s);\n/*\n* FIXME: Error handling code does not seem to support interlaced\n* when slices span multiple rows\n* The ff_er_add_slice calls don't work right for bottom\n* fields; they cause massive erroneous error concealing\n* Error marking covers both fields (top and bottom).\n* This causes a mismatched s->error_count\n* and a bad error table. Further, the error count goes to\n* INT_MAX when called for bottom field, because mb_y is\n* past end by one (callers fault) and resync_mb_y != 0\n* causes problems for the first MB line, too.\n*/\nif (!FIELD_PICTURE && h->current_slice)\nff_er_frame_end(s);\nff_MPV_frame_end(s);\nh->current_slice = 0;\nreturn err;\n}",
                        "max_stars_repo_path": "dataset/source/NVD/CVE_2013_0869_VULN_field_end.c",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "kppw99/enVAS",
                        "__cluster__": 2684
                },
                {
                        "id": "test_devign_test_set_data_26836",
                        "content": "int ff_h264_field_end(H264Context *h, int in_setup)\n{\nAVCodecContext *const avctx = h->avctx;\nint err = 0;\nh->mb_y = 0;\nif (CONFIG_H264_VDPAU_DECODER &&\nh->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\nff_vdpau_h264_set_reference_frames(h);\nif (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\nif (!h->droppable) {\nerr = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\nh->prev_poc_msb = h->poc_msb;\nh->prev_poc_lsb = h->poc_lsb;\n}\nh->prev_frame_num_offset = h->frame_num_offset;\nh->prev_frame_num        = h->frame_num;\nh->outputed_poc          = h->next_outputed_poc;\n}\nif (avctx->hwaccel) {\nif (avctx->hwaccel->end_frame(avctx) < 0)\nav_log(avctx, AV_LOG_ERROR,\n\"hardware accelerator failed to decode picture\\n\");\n}\nif (CONFIG_H264_VDPAU_DECODER &&\nh->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\nff_vdpau_h264_picture_complete(h);\n#if CONFIG_ERROR_RESILIENCE\n/*\n* FIXME: Error handling code does not seem to support interlaced\n* when slices span multiple rows\n* The ff_er_add_slice calls don't work right for bottom\n* fields; they cause massive erroneous error concealing\n* Error marking covers both fields (top and bottom).\n* This causes a mismatched s->error_count\n* and a bad error table. Further, the error count goes to\n* INT_MAX when called for bottom field, because mb_y is\n* past end by one (callers fault) and resync_mb_y != 0\n* causes problems for the first MB line, too.\n*/\nif (!FIELD_PICTURE(h) && h->current_slice && !h->sps.new) {\nff_h264_set_erpic(&h->er.cur_pic, h->cur_pic_ptr);\nff_er_frame_end(&h->er);\n}\n#endif /* CONFIG_ERROR_RESILIENCE */\nif (!in_setup && !h->droppable)\nff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\nh->picture_structure == PICT_BOTTOM_FIELD);\nemms_c();\nh->current_slice = 0;\nreturn err;\n}\nThe vulnerability label is: Vulnerable",
                        "max_stars_repo_path": "NA",
                        "max_stars_count": 0.0,
                        "max_stars_repo_name": "NA",
                        "__cluster__": 2684
                },
                {
                        "real_dup": "1"
                }
        ]
]